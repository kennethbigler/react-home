{"version":3,"sources":["../../src/invariant.ts","../node_modules/@wry/equality/lib/equality.esm.js","../node_modules/process/browser.js","../node_modules/tslib/tslib.es6.js","../../src/context/ApolloContext.ts","../../src/parser/parser.ts","../../src/context/ApolloProvider.tsx","../node_modules/graphql/language/visitor.mjs","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/graphql-tag/src/index.js","../node_modules/@apollo/react-hooks/node_modules/tslib/tslib.es6.js","../../src/equality.ts","../../src/data/OperationData.ts","../../src/data/QueryData.ts","../../src/utils/useBaseQuery.ts","../../src/utils/useDeepMemo.ts","../../src/useQuery.ts","../../src/data/MutationData.ts","../../src/useMutation.ts","../../src/data/SubscriptionData.ts","../../src/ssr/RenderPromises.ts","../node_modules/fast-json-stable-stringify/index.js","../../src/linkUtils.ts","../../src/link.ts","../../src/zenObservable.ts","../../src/getFromAST.ts","../../src/util/canUse.ts","../../src/util/cloneDeep.ts","../../src/util/mergeDeep.ts","../../src/util/warnOnce.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/graphql/jsutils/inspect.mjs","../node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs","../node_modules/graphql/language/blockString.mjs","../../src/core/networkStatus.ts","../../src/util/Observable.ts","../../src/util/arrays.ts","../../src/errors/ApolloError.ts","../../src/core/types.ts","../../src/core/ObservableQuery.ts","../../src/data/mutations.ts","../../src/data/queries.ts","../../src/core/LocalState.ts","../../src/util/capitalizeFirstLetter.ts","../../src/util/observables.ts","../../src/core/QueryManager.ts","../../src/data/store.ts","../../src/version.ts","../../src/ApolloClient.ts","../node_modules/apollo-client/node_modules/tslib/tslib.es6.js","../node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js","../node_modules/zen-observable/index.js","../node_modules/zen-observable/lib/Observable.js","../../src/storeUtils.ts","../../src/directives.ts","../../src/util/assign.ts","../../src/util/filterInPlace.ts","../../src/transform.ts","../../src/util/errorHandling.ts","../../src/index.ts","../../src/util/environment.ts","../../src/util/maybeDeepFreeze.ts","../../src/fragments.ts","../node_modules/apollo-cache/node_modules/tslib/tslib.es6.js","../node_modules/graphql/jsutils/devAssert.mjs","../node_modules/graphql/jsutils/defineToJSON.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/kinds.mjs","../node_modules/graphql/language/source.mjs","../node_modules/graphql/jsutils/defineToStringTag.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/parser.mjs","../../src/utils.ts","../../src/types/Cache.ts","../../src/cache.ts","../../src/slot.ts","../../src/context.ts","../../src/entry.ts","../../src/key-trie.ts","../../src/fragmentMatcher.ts","../../src/depTrackingCache.ts","../../src/readFromStore.ts","../../src/objectCache.ts","../../src/writeToStore.ts","../../src/inMemoryCache.ts","../node_modules/graphql/language/printer.mjs","../../src/httpLink.ts"],"names":["genericMessage","setPrototypeOf","message","framesToPop","name","InvariantError","prototype","Error","invariant","condition","wrapConsoleMethod","method","console","apply","arguments","warn","error","processStub","env","process","Function","atLeastWeTried","_a","Object","toString","hasOwnProperty","checker","Checker","this","aStack","bStack","reset","length","check","a","b","_this","aTag","call","bTag","withCycleGuard","aKeys","keys","bKeys","every","key","size","aIterator","entries","info","next","done","value","aKey","aValue","has","get","callback","aIndex","lastIndexOf","bIndex","push","pop","equal","cachedSetTimeout","cachedClearTimeout","module","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","i","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","extendStatics","d","__proto__","p","__extends","__","constructor","create","__assign","assign","t","s","n","__rest","indexOf","getOwnPropertySymbols","apolloContext","getApolloContext","createContext","DocumentType","ApolloProvider","client","children","ApolloContext","context","Provider","cache","Map","operationName","type","Query","Mutation","Subscription","parser","document","variables","cached","fragments","definitions","filter","x","kind","queries","operation","mutations","subscriptions","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","BREAK","freeze","visit","root","visitor","visitorKeys","undefined","stack","inArray","isArray","index","edits","node","parent","path","ancestors","newRoot","isLeaving","isEdited","slice","clone","_i2","_Object$keys2","k","editOffset","ii","editKey","editValue","splice","prev","result","isNode","inspect","visitFn","getVisitFn","maybeNode","Boolean","kindVisitor","kindSpecificVisitor","leave","enter","specificVisitor","specificKindVisitor","_taggedTemplateLiteral","strings","raw","defineProperties","parse","require","normalize","string","replace","trim","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","parseDocument","doc","cacheKey","parsed","stripLoc","removeLocAtThisLevel","docType","map","loc","startToken","endToken","valueType","ast","astFragmentMap","fragmentDefinition","fragmentName","sourceKey","source","body","substring","start","end","processFragments","gql","literals","default","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","previousComparisons","previouslyCompared","keyCount","isMap","clear","bSet","set","Set","add","options","isMounted","previousOptions","getOptions","setOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","isNew","cleanup","verifyDocumentType","forceUpdate","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","getQueryResult","startQuerySubscription","obsRefetch","query","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","execute","skip","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","loading","networkStatus","ready","called","data","fetchData","ssr","obs","getCurrentResult","afterExecute","lazy","handleErrorOrCompleted","resetQueryStoreErrors","bind","treeRenderingInitiated","renderPromises","ssrDisabled","fetchDisabled","disableNetworkFetches","ssrLoading","addQueryPromise","prepareObservableQueryOptions","displayName","fetchPolicy","metadata","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","watchQuery","registerSSRObservable","newObservableQueryOptions","catch","subscription","obsQuery","subscribe","previousResult","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","observableQueryFields","currentResult","partial","errors","graphQLErrors","partialRefetch","onCompleted","onError","unsubscribe","useBaseQuery","tick","updatedOptions","queryDataRef","current","queryData","memoFn","ref","useDeepMemo","queryResult","useQuery","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","then","response","onMutationCompleted","onMutationError","mutation","mostRecentMutationId","optimisticResponse","update","awaitRefetchQueries","mutateOptions","mutateVariables","refetchQueries","mutationContext","ignoreResults","updateResult","isMostRecentMutation","useMutation","mutationDataRef","mutationData","initialize","getLoadingResult","shouldResubscribe","startSubscription","endSubscription","updateCurrentData","updateError","complete","completeSubscription","onSubscriptionData","subscriptionData","onSubscriptionComplete","queryPromises","queryInfoTrie","observable","props","lookupQueryInfo","queryInstance","finish","seen","Promise","resolve","hasPromises","consumeAndAwaitPromises","promises","forEach","promise","all","varMap","variablesString","JSON","stringify","opts","cmp","f","cycles","aobj","bobj","toJSON","isFinite","out","TypeError","seenIndex","sort","link","isTerminating","request","fromError","errorValue","observer","createOperation","starting","defineProperty","enumerable","getKey","passthrough","op","forward","of","toLink","handler","ApolloLink","empty","from","links","reduce","y","split","test","left","right","leftLink","rightLink","first","second","firstLink","nextLink","transformedOperation","extensions","transformOperation","OPERATION_FIELDS","validateOperation","Observable","getOperationName","definition","WeakMap","navigator","product","_objectWithoutProperties","excluded","target","sourceKeys","sourceSymbolKeys","propertyIsEnumerable","_typeof","obj","Symbol","iterator","MAX_ARRAY_LENGTH","MAX_RECURSIVE_DEPTH","formatValue","seenValues","previouslySeenValues","customInspectFn","object","String","nodejsCustomInspectSymbol","getCustomFn","customValue","Math","min","remaining","items","join","formatArray","tag","getObjectTag","formatObject","formatObjectValue","for","dedentBlockStringValue","rawString","lines","commonIndent","line","indent","leadingWhitespace","getBlockStringIndentation","isBlank","shift","str","printBlockString","indentation","preferMultipleLines","isSingleLine","hasLeadingSpace","hasTrailingQuote","printAsMultipleLines","NetworkStatus","isNetworkRequestInFlight","LinkObservable","isNonEmptyArray","FetchType","generateErrorMessage","err","graphQLError","errorMessage","networkError","extraInfo","ApolloError","queryManager","shouldSubscribe","onSubscribe","observers","isTornDown","queryId","generateQueryId","opDef","queryName","reject","delete","removeQuery","storeValue","policy","queryStoreValue","queryStore","isNetworkFetchPolicy","errorPolicy","updateLastResult","stale","isDifferentFromLastResult","newResult","lastResultSnapshot","snapshot","fetchQuery","combinedOptions","qid","normal","fetchMoreResult","stopQuery","startGraphQLSubscription","previous","setVariables","oldFetchPolicy","fetchResults","tryFetch","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","assertNotCacheFirstOrOnly","startPollingQuery","assumeImmutableResults","subObserver","_subscription","_observer","defaultSubscriptionObserverErrorCallback","setUpQuery","tearDownQuery","addObservableQuery","iterateObserversSafely","observeQuery","transform","hasClientExports","getLocalState","addExportedVariables","previousVariables","serverQuery","sub","removeObservableQuery","argument","observersWithMethod","store","getStore","initMutation","markMutationError","markMutationResult","initQuery","previousQuery","resolvers","fragmentMatcher","addResolvers","setFragmentMatcher","resolverGroup","setResolvers","getResolvers","runResolvers","remoteResult","onlyRunForcedResolvers","resolveDocument","localResult","getFragmentMatcher","clientQuery","prepareContext","getCacheKey","config","dataIdFromObject","buildRootValueFromCache","exportedVariables","shouldForceResolvers","forceResolvers","some","arg","diff","returnPartialData","optimistic","rootValue","mainDefinition","fragmentMap","definitionOperation","defaultOperationType","charAt","toUpperCase","execContext","resolveSelectionSet","selectionSet","resultsToMerge","selection","resolveField","fieldResult","fragment","typeCondition","fragmentResult","selections","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolverType","__typename","resolverMap","directives","directive","resolveSubSelectedArray","item","multiplex","inner","queryDeduplication","onBroadcast","ssrMode","clientAwareness","localState","mutationStore","MutationStore","QueryStore","idCounter","fetchQueryRejectFns","transformCache","inFlightLinkObservables","pollingInfoByQueryId","LocalState","getCache","stop","_info","stopQueryNoBroadcast","updateQueries","setQuery","getVariables","generateUpdateQueriesInfo","ret","updateQueriesByName","observableQuery","updater","markMutationInit","updateWithProxyFn","self","storeResult","getObservableFromLink","markMutationComplete","refetchQueryPromises","refetchQuery","queryOptions","fetchType","fetchMoreForQueryId","needToFetch","isNetworkOnly","shouldFetch","requestId","cancel","updateQueryWatch","lastRequestId","invalidated","invalidate","storePreviousVariables","isPoll","poll","isRefetch","networkResult","fetchRequest","getQuery","markQueryError","markQueryResultClient","hasForcedResolvers","markQueryResult","newData","queryListenerForObserver","invoke","networkStatusChanged","shouldNotifyIfLoading","notifyOnNetworkStatusChange","hasGraphQLErrors","isMissing","errorStatusChanged","diffResult","resultFromStore","transformed","transformDocument","forLink","transformForLink","defaultVars","transformedOptions","ObservableQuery","watchedQuery","stopQueryInStore","stopQueryInStoreNoBroadcast","addQueryListener","listener","watch","clearStore","resetIds","resetStore","reFetchObservableQueries","includeStandby","observableQueryPromises","startQuery","makeObservable","markSubscriptionResult","getCurrentQueryResult","getQueryWithPreviousResult","queryIdOrObservable","foundObserveableQuery","id","deduplication","forceFetch","activeNextCount","completed","asyncMap","errorsFromStore","fqrfId","newInfo","newContext","checkInFlight","interval","initialCache","ignoreErrors","writeWithErrors","write","dataId","recordOptimisticTransaction","c","orig","nextQueryResult","currentQueryResult","mutationResult","queryVariables","performTransaction","removeOptimistic","defaultOptions","resetStoreCallbacks","clearStoreCallbacks","ssrForceFetchDelay","connectToDevTools","typeDefs","DataStore","window","__APOLLO_CLIENT__","QueryManager","clientAwarenessName","clientAwarenessVersion","devToolsHookCb","action","state","dataWithOptimisticResults","extract","readQuery","readFragment","writeQuery","writeFragment","writeData","__actionHookForDevTools","cb","__requestRaw","payload","initQueryManager","fn","onResetStore","onClearStore","restore","serializedState","setLocalStateFragmentMatcher","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","rejected","__generator","g","_","label","sent","trys","ops","verb","v","__spreadArrays","il","r","j","jl","_createClass","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","hasSymbols","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","ctor","isObservable","hostReportError","log","enqueue","cleanupSubscription","_cleanup","closeSubscription","_queue","_state","notifySubscription","m","onNotify","flushSubscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscriber","_this2","_this3","_this4","C","hasSeed","hasValue","seed","acc","_this5","_len","sources","_key","startNext","_this6","outer","completeIfDone","closed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","return","_len2","_key2","symbol","valueToObjectRepresentation","argObj","isIntValue","isFloatValue","Number","isBooleanValue","isStringValue","isObjectValue","fields","isVariable","variableValue","isListValue","values","listValue","nestedArgArrayObj","isEnumValue","isNullValue","argumentsObjectFromField","resultKeyNameFromField","alias","isField","isInlineFragment","shouldInclude","isInclusionDirective","directiveArguments","ifArgument","ifValue","evaledValue","hasDirectives","names","getDirectiveNames","checkDocument","operations","getOperationDefinition","getFragmentDefinitions","getMainDefinition","queryDoc","createFragmentMap","symTable","getDefaultValues","variableDefinitions","defaultValues","defaultValue","variable","defaultValueObj","filterInPlace","elem","nullIfDocIsEmpty","isEmpty","fragmentDef","getFragmentDefinition","getDirectiveMatcher","removeDirectivesFromDocument","variablesInUse","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","remove","getAllFragmentSpreadsFromSelectionSet","allFragments","frag","argMatcher","aConfig","getArgumentMatcher","varDef","argConfig","removeArgumentsFromDocument","fs","def","removeFragmentSpreadFromDocument","connectionRemoveConfig","willRemove","removeConnectionDirectiveFromDocument","buildQueryFromSelectionSet","removeClientSetsFromDocument","canUseWeakMap","cloneDeep","cloneDeepHelper","val","child","getPrototypeOf","tryFunctionOrLogError","graphQLResultHasError","mergeDeep","mergeDeepArray","count","pastCopies","shallowCopyForMerge","mergeHelper","isObject","isExtensible","sourceValue","targetValue","storeKeyNameFromField","directivesObj","getStoreKeyName","KNOWN_DIRECTIVES","filterKeys","completeFieldName","stringifiedArgs","isIdValue","idObject","generated","toIdValue","idConfig","typename","isJsonValue","jsonObject","getDirectiveInfoFromField","getQueryDefinition","queryDef","TYPENAME_FIELD","addTypenameToDocument","isEnv","isProduction","isTest","maybeDeepFreeze","deepFreeze","o","getOwnPropertyNames","prop","isFrozen","getFragmentQueryDocument","actualFragmentName","devAssert","defineToJSON","classObject","getLocation","position","match","lineRegexp","column","exec","printLocation","location","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","locationLine","sublineIndex","floor","sublineColumnNum","sublines","printPrefixedLines","subline","existingLines","_ref","padLen","max","_ref2","_ref3","prefix","GraphQLError","nodes","positions","originalError","_nodes","_source","_locations","_positions","list","pos","_extensions","originalExtensions","locations","captureStackTrace","syntaxError","description","output","_error$nodes2","_i4","_error$locations2","printError","Kind","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Source","toStringTag","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","advanceLexer","lastToken","token","lookahead","readToken","Tok","printCharCode","code","isNaN","fromCharCode","lexer","bodyLength","startPosition","charCodeAt","lineStart","positionAfterWhitespace","col","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","char2hex","invalidSequence","readString","unexpectedCharacterMessage","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Parser","parseValue","expectToken","parseValueLiteral","parseType","parseTypeReference","sourceObj","_lexer","startOfFileToken","advance","createLexer","_options","_proto","parseName","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","parseVariable","expectOptionalToken","parseSelection","parseFragment","parseField","nameOrAlias","parseArguments","isConst","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","parseNamedType","expectKeyword","parseList","parseObject","parseStringLiteral","block","any","parseObjectField","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","types","allowLegacySDLImplementsInterfaces","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","noLocation","Loc","getTokenDesc","atToken","openKind","parseFn","closeKind","queryFromPojo","selectionSetFromObj","Cache","justTypenameQuery","currentContext","MISSING_VALUE","host","Slot","Date","now","random","slots","getValue","withValue","saved","noContext","defaultDispose","dispose","newest","oldest","entry","getEntry","older","newer","clean","parentEntrySlot","reusableEmptyArray","emptySetPool","POOL_TARGET_SIZE","assert","optionalMessage","valueGet","parents","childValues","dirtyChildren","dirty","recomputing","Entry","recompute","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","recomputeNewValue","maybeUnsubscribe","setDirty","maybeSubscribe","reportClean","setClean","reallyRecompute","reportDirty","forgetChild","childValue","valueIs","removeDirtyChild","dc","reportOrphan","_value","weakness","lookup","lookupArray","getChildTrie","isObjRef","weak","strong","KeyTrie","haveWarned","shouldWarn","answer","ensureReady","canBypassInit","idValue","isRootQuery","hasOwn","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","implementingTypes","introspectionResultData","typeMap","__schema","possibleTypes","implementingType","depend","wrap","disposable","makeCacheKey","toObject","defaultNormalizedCacheFactory","cacheKeyRoot","freezeResults","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","contextValue","variableValues","readQueryFromStore","diffQueryAgainstStore","rootId","fragmentMatcherFunction","queryDefinition","cacheRedirects","execResult","hasMissingFields","missing","tolerable","finalResult","objectsToMerge","handleMissing","executeField","fragmentExecResult","readStoreResult","resultKey","storeKeyName","fieldValue","resolver","storeObj","json","readStoreResolver","combineExecResults","assertSelectionSetForIdValue","execResults","childResult","defaultFragmentMatcher","writeQueryToStore","writeResultToStore","operationDefinition","writeSelectionSetToStore","processedData","enhancedError","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","matches","fakeContext","ObjectCache","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","real","madeChanges","realValue","newRealValue","itemDataId","defaultConfig","HeuristicFragmentMatcher","_id","addTypename","resultCaching","optimisticId","transaction","watches","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","read","broadcastWatches","evict","idToRemove","toReapply","removedCount","layer","print","printDocASTReducer","varDefs","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","addDescription","_ref22","_ref23","_ref24","hasMultilineItems","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","maybeArray","separator","maybeString","isMultiline","fallbackHttpConfig","http","includeQuery","includeExtensions","headers","accept","throwServerError","statusCode","status","serialized","parseError","linkOptions","uri","fetch","useGETForQueries","fetcher","linkConfig","requestOptions","fetchOptions","credentials","chosenURI","fallbackURI","contextURI","getContext","selectURI","clientAwarenessHeaders","controller","contextHeaders","contextConfig","fallbackConfig","configs","signal","AbortController","_controller","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","queryParamsPrefix","newURI","setContext","text","bodyText","abort"],"mappings":"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","file":"static/js/29.73f37f15.chunk.js","sourcesContent":["const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(condition: any, message?: string | number) {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nfunction wrapConsoleMethod(method: \"warn\" | \"error\") {\n  return function () {\n    return console[method].apply(console, arguments as any);\n  } as (...args: any[]) => void;\n}\n\nexport namespace invariant {\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\n// Code that uses ts-invariant with rollup-plugin-invariant may want to\n// import this process stub to avoid errors evaluating process.env.NODE_ENV.\n// However, because most ESM-to-CJS compilers will rewrite the process import\n// as tsInvariant.process, which prevents proper replacement by minifiers, we\n// also attempt to define the stub globally when it is not already defined.\nlet processStub: NodeJS.Process = { env: {} } as any;\nexport { processStub as process };\nif (typeof process === \"object\") {\n  processStub = process;\n} else try {\n  // Using Function to evaluate this assignment in global scope also escapes\n  // the strict mode of the current module, thereby allowing the assignment.\n  // Inspired by https://github.com/facebook/regenerator/pull/369.\n  Function(\"stub\", \"process = stub\")(processStub);\n} catch (atLeastWeTried) {\n  // The assignment can fail if a Content Security Policy heavy-handedly\n  // forbids Function usage. In those environments, developers should take\n  // extra care to replace process.env.NODE_ENV in their production builds,\n  // or define an appropriate global.process polyfill.\n}\n\nexport default invariant;\n","var _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;\r\nvar Checker = /** @class */ (function () {\r\n    function Checker() {\r\n        this.aStack = [];\r\n        this.bStack = [];\r\n    }\r\n    Checker.prototype.reset = function () {\r\n        this.aStack.length = 0;\r\n        this.bStack.length = 0;\r\n        return this;\r\n    };\r\n    Checker.prototype.check = function (a, b) {\r\n        var _this = this;\r\n        // If the two values are strictly equal, our job is easy.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // Object.prototype.toString returns a representation of the runtime type of\r\n        // the given value that is considerably more precise than typeof.\r\n        var aTag = toString.call(a);\r\n        var bTag = toString.call(b);\r\n        // If the runtime types of a and b are different, they could maybe be equal\r\n        // under some interpretation of equality, but for simplicity and performance\r\n        // we just return false instead.\r\n        if (aTag !== bTag) {\r\n            return false;\r\n        }\r\n        switch (aTag) {\r\n            case '[object Array]':\r\n                // Arrays are a lot like other objects, but we can cheaply compare their\r\n                // lengths as a short-cut before comparing their elements.\r\n                if (a.length !== b.length) {\r\n                    return false;\r\n                }\r\n            // Fall through to object case...\r\n            case '[object Object]':\r\n                return this.withCycleGuard(a, b, function () {\r\n                    var aKeys = Object.keys(a);\r\n                    var bKeys = Object.keys(b);\r\n                    return (\r\n                    // If `a` and `b` have a different number of enumerable keys, they\r\n                    // must be different.\r\n                    aKeys.length === bKeys.length &&\r\n                        // Now make sure they have the same keys.\r\n                        bKeys.every(function (key) { return hasOwnProperty.call(a, key); }) &&\r\n                        // Finally, check deep equality of all child properties.\r\n                        aKeys.every(function (key) { return _this.check(a[key], b[key]); }));\r\n                });\r\n            case '[object Error]':\r\n                return a.name === b.name && a.message === b.message;\r\n            case '[object Number]':\r\n                // Handle NaN, which is !== itself.\r\n                if (a !== a)\r\n                    return b !== b;\r\n            // Fall through to shared +a === +b case...\r\n            case '[object Boolean]':\r\n            case '[object Date]':\r\n                return +a === +b;\r\n            case '[object RegExp]':\r\n            case '[object String]':\r\n                return a == \"\" + b;\r\n            case '[object Map]':\r\n            case '[object Set]': {\r\n                if (a.size !== b.size) {\r\n                    return false;\r\n                }\r\n                return this.withCycleGuard(a, b, function () {\r\n                    var aIterator = a.entries();\r\n                    while (true) {\r\n                        var info = aIterator.next();\r\n                        if (info.done)\r\n                            break;\r\n                        // If a instanceof Set, aValue === aKey.\r\n                        var _a = info.value, aKey = _a[0], aValue = _a[1];\r\n                        // So this works the same way for both Set and Map.\r\n                        if (!b.has(aKey)) {\r\n                            return false;\r\n                        }\r\n                        if (\r\n                        // However, we care about deep equality of values only when dealing\r\n                        // with Map structures.\r\n                        aTag === '[object Map]' &&\r\n                            !_this.check(aValue, b.get(aKey))) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                });\r\n            }\r\n        }\r\n        // Otherwise the values are not equal.\r\n        return false;\r\n    };\r\n    Checker.prototype.withCycleGuard = function (a, b, callback) {\r\n        // Although we may detect cycles at different depths along the same\r\n        // path, once the first object enters a cycle of length N, every nested\r\n        // child of that object will also be identical to its Nth ancestor, so\r\n        // we can safely keep recursing until the other object enters a cycle of\r\n        // length M. If the other object does not have a cycle in this subtree,\r\n        // the recursion will terminate normally, and equal(a, b) will return\r\n        // false. If the other object has a cycle, and N === M, we consider the\r\n        // cycles equivalent. If N !== M, there's a chance the cycles are\r\n        // somehow isomorphic, but as a matter of policy we say they are not the\r\n        // same because their structures are, in fact, different.\r\n        var aIndex = this.aStack.lastIndexOf(a);\r\n        if (aIndex >= 0) {\r\n            var bIndex = this.bStack.lastIndexOf(b);\r\n            if (bIndex >= 0) {\r\n                return aIndex === bIndex;\r\n            }\r\n        }\r\n        this.aStack.push(a);\r\n        this.bStack.push(b);\r\n        try {\r\n            return callback();\r\n        }\r\n        finally {\r\n            this.aStack.pop();\r\n            this.bStack.pop();\r\n        }\r\n    };\r\n    return Checker;\r\n}());\r\nvar checker = new Checker();\r\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\r\nfunction equal(a, b) {\r\n    return checker.reset().check(a, b);\r\n}\n\nexport default equal;\nexport { equal };\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: Record<any, any>;\n}\n\nlet apolloContext: React.Context<ApolloContextValue>;\n\nexport function getApolloContext() {\n  if (!apolloContext) {\n    apolloContext = React.createContext<ApolloContextValue>({});\n  }\n  return apolloContext;\n}\n\nexport function resetApolloContext() {\n  apolloContext = React.createContext<ApolloContextValue>({});\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to saftey check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n","import inspect from '../jsutils/inspect';\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + inspect(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const { toString, hasOwnProperty } = Object.prototype;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = Object.keys(a);\n      const bKeys = Object.keys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n","import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private forceUpdate: any;\n\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    forceUpdate\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    forceUpdate: any;\n  }) {\n    super(options, context);\n    this.forceUpdate = forceUpdate;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined\n          } as QueryResult<TData, TVariables>\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n\n      // When the component is done rendering stored query errors, we'll\n      // remove those errors from the `ObservableQuery` query store, so they\n      // aren't re-displayed on subsequent (potentially error free)\n      // requests/responses.\n      setTimeout(() => {\n        this.currentObservable.query &&\n          this.currentObservable.query.resetQueryStoreErrors();\n      });\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.forceUpdate();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const treeRenderingInitiated = this.context && this.context.renderPromises;\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (treeRenderingInitiated || fetchDisabled)) {\n      return ssrLoading;\n    }\n\n    let result;\n    if (treeRenderingInitiated) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.context &&\n      this.context.renderPromises &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } }\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.currentObservable.query = this.context.renderPromises.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions\n      });\n\n      if (this.context && this.context.renderPromises) {\n        this.context.renderPromises.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.forceUpdate();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.forceUpdate();\n        }\n      }\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery) return;\n\n    const { data, loading, error } = obsQuery.getCurrentResult();\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { useContext, useEffect, useReducer, useRef } from 'react';\nimport {\n  getApolloContext,\n  OperationVariables,\n  QueryResult\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions, QueryOptions, QueryTuple } from '../types';\nimport { QueryData } from '../data/QueryData';\nimport { useDeepMemo } from './useDeepMemo';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n\n  if (!queryDataRef.current) {\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryOptions<TData, TVariables>,\n      context,\n      forceUpdate\n    });\n  }\n\n  const queryData = queryDataRef.current;\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: { ...updatedOptions, onError: undefined, onCompleted: undefined },\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data\n  ]);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  return result;\n}\n","import { useRef } from 'react';\nimport { equal as isEqual } from '@wry/equality';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n */\nexport function useDeepMemo<TKey, TValue>(\n  memoFn: () => TValue,\n  key: TKey\n): TValue {\n  const ref = useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n","import { OperationVariables, QueryResult } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions } from './types';\nimport { useBaseQuery } from './utils/useBaseQuery';\n\nexport function useQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>\n) {\n  return useBaseQuery<TData, TVariables>(query, options, false) as QueryResult<\n    TData,\n    TVariables\n  >;\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { getApolloContext, OperationVariables } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { MutationHookOptions, MutationTuple } from './types';\nimport { MutationData } from './data/MutationData';\n\nexport function useMutation<TData = any, TVariables = OperationVariables>(\n  mutation: DocumentNode,\n  options?: MutationHookOptions<TData, TVariables>\n): MutationTuple<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const [result, setResult] = useState({ called: false, loading: false });\n  const updatedOptions = options ? { ...options, mutation } : { mutation };\n\n  const mutationDataRef = useRef<MutationData<TData, TVariables>>();\n  function getMutationDataRef() {\n    if (!mutationDataRef.current) {\n      mutationDataRef.current = new MutationData<TData, TVariables>({\n        options: updatedOptions,\n        context,\n        result,\n        setResult\n      });\n    }\n    return mutationDataRef.current;\n  }\n\n  const mutationData = getMutationDataRef();\n  mutationData.setOptions(updatedOptions);\n  mutationData.context = context;\n\n  useEffect(() => mutationData.afterExecute());\n\n  return mutationData.execute(result);\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","import Observable from 'zen-observable-ts';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nimport { getOperationName } from 'apollo-utilities';\nimport { invariant, InvariantError } from 'ts-invariant';\nexport { getOperationName };\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX We're assuming here that query and variables will be serialized in\n  // the same order, which might not always be true.\n  const { query, variables, operationName } = operation;\n  return JSON.stringify([operationName, query, variables]);\n}\n","import Observable from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nexport function empty(): ApolloLink {\n  return new ApolloLink(() => Observable.of());\n}\n\nexport function from(links: ApolloLink[]): ApolloLink {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n}\n\nexport function split(\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right?: ApolloLink | RequestHandler,\n): ApolloLink {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    invariant.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  invariant(mutationDef, 'Must contain a mutation definition.');\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  invariant(def, `GraphQL document is missing an operation`);\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export const canUseWeakMap = typeof WeakMap === 'function' && !(\n  typeof navigator === 'object' &&\n  navigator.product === 'ReactNative'\n);\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","const { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || {} as T;\n  const count = sources.length;\n  if (count > 1) {\n    const pastCopies: any[] = [];\n    target = shallowCopyForMerge(target, pastCopies);\n    for (let i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n  return target;\n}\n\nfunction isObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(\n  target: any,\n  source: any,\n  pastCopies: any[],\n) {\n  if (isObject(source) && isObject(target)) {\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceValue = source[sourceKey];\n      if (hasOwnProperty.call(target, sourceKey)) {\n        const targetValue = target[sourceKey];\n        if (sourceValue !== targetValue) {\n          // When there is a key collision, we need to make a shallow copy of\n          // target[sourceKey] so the merge does not modify any source objects.\n          // To avoid making unnecessary copies, we use a simple array to track\n          // past copies, since it's safe to modify copies created earlier in\n          // the merge. We use an array for pastCopies instead of a Map or Set,\n          // since the number of copies should be relatively small, and some\n          // Map/Set polyfills modify their keys.\n          target[sourceKey] = mergeHelper(\n            shallowCopyForMerge(targetValue, pastCopies),\n            sourceValue,\n            pastCopies,\n          );\n        }\n      } else {\n        // If there is no collision, the target can safely share memory with\n        // the source, and the recursion can terminate here.\n        target[sourceKey] = sourceValue;\n      }\n    });\n\n    return target;\n  }\n\n  // If source (or target) is not an object, let source replace target.\n  return source;\n}\n\nfunction shallowCopyForMerge<T>(value: T, pastCopies: any[]): T {\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    pastCopies.indexOf(value) < 0\n  ) {\n    if (Array.isArray(value)) {\n      value = (value as any).slice(0);\n    } else {\n      value = {\n        __proto__: Object.getPrototypeOf(value),\n        ...value,\n      };\n    }\n    pastCopies.push(value);\n  }\n  return value;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nexport default function inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\nexport default nodejsCustomInspectSymbol;\n","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","import {\n  ExecutionResult,\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: ExecutionResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<ExecutionResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: ExecutionResult) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result as FetchResult<T>;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult as ExecutionResult);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: ExecutionResult) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.6.8\"","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","module.exports = require('./lib/Observable.js').Observable;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species');\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, SymbolObservable);\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new InvariantError(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { invariant } from 'ts-invariant';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  return getInclusionDirectives(\n    selection.directives,\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  return directives ? directives.filter(isInclusionDirective).map(directive => {\n    const directiveArguments = directive.arguments;\n    const directiveName = directive.name.value;\n\n    invariant(\n      directiveArguments && directiveArguments.length === 1,\n      `Incorrect number of arguments for the @${directiveName} directive.`,\n    );\n\n    const ifArgument = directiveArguments[0];\n    invariant(\n      ifArgument.name && ifArgument.name.value === 'if',\n      `Invalid argument for the @${directiveName} directive.`,\n    );\n\n    const ifValue: ValueNode = ifArgument.value;\n\n    // means it has to be a variable value if this is a valid @skip or @include directive\n    invariant(\n      ifValue &&\n        (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n      `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n    );\n\n    return { directive, ifArgument };\n  }) : [];\n}\n\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nimport { invariant } from 'ts-invariant';\nimport { isField, isInlineFragment } from './storeUtils';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll fist check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // docuemnt.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      SelectionSet: {\n        enter(node, _key, _parent, path) {\n          const currentPath = path.join('-');\n\n          if (\n            !parentPath ||\n            currentPath === parentPath ||\n            !currentPath.startsWith(parentPath)\n          ) {\n            if (node.selections) {\n              const selectionsWithDirectives = node.selections.filter(\n                selection => hasDirectivesInSelection(directives, selection),\n              );\n\n              if (hasDirectivesInSelectionSet(directives, node, false)) {\n                parentPath = currentPath;\n              }\n\n              return {\n                ...node,\n                selections: selectionsWithDirectives,\n              };\n            } else {\n              return null;\n            }\n          }\n        },\n      },\n    }),\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ),\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            node.arguments.forEach(arg => {\n              if (argMatcher(arg)) {\n                argMatchCount += 1;\n              }\n            });\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\nimport { InvariantError } from 'ts-invariant';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.name = 'ServerError';\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.name = 'ServerParseError';\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: WindowOrWorkerGlobalScope['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new InvariantError(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new InvariantError(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export default function devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n","import nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\n\nexport default function defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport default function isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from '../language/location';\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","import isObjectLike from '../jsutils/isObjectLike';\nimport { getLocation } from '../language/location';\nimport { printLocation, printSourceLocation } from '../language/printLocation';\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport function GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if (isObjectLike(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nexport function printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n","import { GraphQLError } from './GraphQLError';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","import devAssert from '../jsutils/devAssert';\nimport defineToStringTag from '../jsutils/defineToStringTag';\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nexport var Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive');\n  this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive');\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(Source);\n","/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nexport default function defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n","import defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { dedentBlockStringValue } from './blockString';\nimport { TokenKind } from './tokenKind';\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport function createLexer(source, options) {\n  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n// @internal\nexport function isPunctuatorToken(token) {\n  var kind = token.kind;\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or e\n\n\n  if (code === 46 || code === 69 || code === 101) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n}\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","import inspect from '../jsutils/inspect';\nimport devAssert from '../jsutils/devAssert';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { Kind } from './kinds';\nimport { Source } from './source';\nimport { createLexer } from './lexer';\nimport { DirectiveLocation } from './directiveLocation';\nimport { TokenKind } from './tokenKind';\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj)));\n    this._lexer = createLexer(sourceObj);\n    this._options = options || {};\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        if (token.value === 'true' || token.value === 'false') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.BOOLEAN,\n            value: token.value === 'true',\n            loc: this.loc(token)\n          };\n        } else if (token.value === 'null') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    // Legacy support for the SDL?\n    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token)));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n","interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K) {\n    return this.map.has(key);\n  }\n\n  public get(key: K) {\n    const entry = this.getEntry(key);\n    return entry && entry.value;\n  }\n\n  private getEntry(key: K): Node<K, V> | void {\n    const entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      const { older, newer } = entry;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older!.newer = entry;\n\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  }\n\n  public set(key: K, value: V) {\n    let entry = this.getEntry(key);\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n\n    this.map.set(key, entry);\n\n    return entry.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K) {\n    const entry = this.map.get(key);\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n","type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult>(\n    callback: (...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: any) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n","import { AnyEntry } from \"./entry\";\nimport { Slot } from \"@wry/context\";\n\nexport const parentEntrySlot = new Slot<AnyEntry>();\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n","import { parentEntrySlot } from \"./context\";\nimport { OptimisticWrapOptions } from \"./index\";\n\nconst reusableEmptyArray: AnyEntry[] = [];\nconst emptySetPool: Set<AnyEntry>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe?: () => any;\n  public reportOrphan?: (this: Entry<TArgs, TValue>) => any;\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n    public args: TArgs,\n  ) {\n    ++Entry.count;\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n\n    if (! rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0 as any;\n    }\n\n    return mightBeDirty(this)\n      ? reallyRecompute(this)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    this.parents.forEach(parent => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  const originalChildren = forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  child.parents.forEach(parent => reportDirtyChild(parent, child));\n}\n\nfunction reportClean(child: AnyEntry) {\n  child.parents.forEach(parent => reportCleanChild(parent, child));\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry: AnyEntry) {\n  return entry.parents.size === 0 &&\n    typeof entry.reportOrphan === \"function\" &&\n    entry.reportOrphan() === true;\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  let children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction maybeUnsubscribe(entry: AnyEntry) {\n  const { unsubscribe } = entry;\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n","// A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nexport class KeyTrie<K> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, KeyTrie<K>>;\n  private strong?: Map<any, KeyTrie<K>>;\n  private data?: K;\n\n  constructor(private readonly weakness: boolean) {}\n\n  public lookup<T extends any[]>(...array: T): K {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends any[]>(array: T): K {\n    let node: KeyTrie<K> = this;\n    array.forEach(key => node = node.getChildTrie(key));\n    return node.data || (node.data = Object.create(null));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, KeyTrie<K>>())\n      : this.strong || (this.strong = new Map<any, KeyTrie<K>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie<K>(this.weakness));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n","import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it cant pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n","import { visit } from './visitor';\nimport { printBlockString } from './blockString';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch if nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders['apollographql-client-name'] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders['apollographql-client-version'] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so it's already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we don't call next, the UI can only show networkError because AC didn't\n            // get any graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n"],"sourceRoot":""}