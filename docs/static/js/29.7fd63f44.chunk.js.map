{"version":3,"sources":["../../src/invariant.ts","../node_modules/@wry/equality/lib/equality.esm.js","../node_modules/process/browser.js","../node_modules/tslib/tslib.es6.js","../../src/context/ApolloContext.ts","../../src/parser/parser.ts","../../src/context/ApolloProvider.tsx","../node_modules/graphql/language/visitor.mjs","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js","../node_modules/graphql-tag/src/index.js","../node_modules/@apollo/react-hooks/node_modules/tslib/tslib.es6.js","../../src/equality.ts","../../src/data/OperationData.ts","../../src/data/QueryData.ts","../../src/utils/useBaseQuery.ts","../../src/utils/useDeepMemo.ts","../../src/useQuery.ts","../../src/data/MutationData.ts","../../src/useMutation.ts","../../src/data/SubscriptionData.ts","../../src/ssr/RenderPromises.ts","../node_modules/fast-json-stable-stringify/index.js","../../src/linkUtils.ts","../../src/link.ts","../../src/zenObservable.ts","../../src/getFromAST.ts","../../src/util/canUse.ts","../../src/util/cloneDeep.ts","../../src/util/mergeDeep.ts","../../src/util/warnOnce.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/graphql/jsutils/inspect.mjs","../node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs","../node_modules/graphql/language/blockString.mjs","../../src/core/networkStatus.ts","../../src/util/Observable.ts","../../src/util/arrays.ts","../../src/errors/ApolloError.ts","../../src/core/types.ts","../../src/core/ObservableQuery.ts","../../src/data/mutations.ts","../../src/data/queries.ts","../../src/core/LocalState.ts","../../src/util/capitalizeFirstLetter.ts","../../src/util/observables.ts","../../src/core/QueryManager.ts","../../src/data/store.ts","../../src/ApolloClient.ts","../../src/version.ts","../node_modules/apollo-client/node_modules/tslib/tslib.es6.js","../node_modules/apollo-cache-inmemory/node_modules/tslib/tslib.es6.js","../node_modules/zen-observable/index.js","../node_modules/zen-observable/lib/Observable.js","../../src/storeUtils.ts","../../src/directives.ts","../../src/util/assign.ts","../../src/util/filterInPlace.ts","../../src/transform.ts","../../src/util/errorHandling.ts","../../src/index.ts","../../src/util/environment.ts","../../src/util/maybeDeepFreeze.ts","../../src/fragments.ts","../node_modules/apollo-cache/node_modules/tslib/tslib.es6.js","../node_modules/graphql/jsutils/devAssert.mjs","../node_modules/graphql/jsutils/defineToJSON.mjs","../node_modules/graphql/jsutils/isObjectLike.mjs","../node_modules/graphql/language/location.mjs","../node_modules/graphql/language/printLocation.mjs","../node_modules/graphql/error/GraphQLError.mjs","../node_modules/graphql/error/syntaxError.mjs","../node_modules/graphql/language/kinds.mjs","../node_modules/graphql/language/source.mjs","../node_modules/graphql/jsutils/defineToStringTag.mjs","../node_modules/graphql/language/tokenKind.mjs","../node_modules/graphql/language/lexer.mjs","../node_modules/graphql/language/directiveLocation.mjs","../node_modules/graphql/language/parser.mjs","../../src/utils.ts","../../src/types/Cache.ts","../../src/cache.ts","../../src/slot.ts","../../src/context.ts","../../src/entry.ts","../../src/key-trie.ts","../../src/fragmentMatcher.ts","../../src/depTrackingCache.ts","../../src/readFromStore.ts","../../src/objectCache.ts","../../src/writeToStore.ts","../../src/inMemoryCache.ts","../node_modules/graphql/language/printer.mjs","../../src/httpLink.ts"],"names":["setPrototypeOf","message","genericMessage","framesToPop","name","InvariantError","prototype","Error","invariant","condition","wrapConsoleMethod","method","console","apply","arguments","warn","error","processStub","env","process","Function","atLeastWeTried","_a","Object","toString","hasOwnProperty","checker","Checker","this","aStack","bStack","reset","length","check","a","b","_this","aTag","call","bTag","withCycleGuard","aKeys","keys","bKeys","every","key","size","aIterator","entries","info","next","done","value","aKey","aValue","has","get","callback","aIndex","lastIndexOf","bIndex","push","pop","equal","cachedSetTimeout","cachedClearTimeout","module","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","i","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","extendStatics","d","__proto__","p","__extends","__","constructor","create","__assign","assign","t","s","n","__rest","indexOf","getOwnPropertySymbols","apolloContext","getApolloContext","createContext","DocumentType","ApolloProvider","client","children","ApolloContext","context","Provider","cache","Map","operationName","type","Query","Mutation","Subscription","parser","document","variables","cached","fragments","definitions","filter","x","kind","queries","operation","mutations","subscriptions","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","BREAK","freeze","visit","root","visitor","visitorKeys","undefined","stack","inArray","isArray","index","edits","node","parent","path","ancestors","newRoot","isLeaving","isEdited","slice","clone","_i2","_Object$keys2","k","editOffset","ii","editKey","editValue","splice","prev","result","isNode","inspect","visitFn","getVisitFn","maybeNode","Boolean","kindVisitor","kindSpecificVisitor","leave","enter","specificVisitor","specificKindVisitor","_taggedTemplateLiteral","strings","raw","defineProperties","parse","require","normalize","string","replace","trim","docCache","fragmentSourceMap","printFragmentWarnings","experimentalFragmentVariables","parseDocument","doc","cacheKey","parsed","stripLoc","removeLocAtThisLevel","docType","map","loc","startToken","endToken","valueType","ast","astFragmentMap","fragmentDefinition","fragmentName","sourceKey","source","body","substring","start","end","processFragments","gql","literals","default","resetCaches","disableFragmentWarnings","enableExperimentalFragmentVariables","disableExperimentalFragmentVariables","previousComparisons","previouslyCompared","keyCount","isMap","clear","bSet","set","Set","add","options","isMounted","previousOptions","getOptions","setOptions","newOptions","storePrevious","isEqual","unmount","refreshClient","isNew","cleanup","verifyDocumentType","forceUpdate","previousData","currentObservable","runLazy","runLazyQuery","lazyOptions","getExecuteResult","getQueryResult","startQuerySubscription","obsRefetch","query","refetch","obsFetchMore","fetchMoreOptions","fetchMore","obsUpdateQuery","mapFn","updateQuery","obsStartPolling","pollInterval","startPolling","obsStopPolling","stopPolling","obsSubscribeToMore","subscribeToMore","execute","skip","removeQuerySubscription","updateObservableQuery","getExecuteSsrResult","executeLazy","loading","networkStatus","ready","called","data","fetchData","ssr","obs","getCurrentResult","afterExecute","lazy","handleErrorOrCompleted","resetQueryStoreErrors","bind","treeRenderingInitiated","renderPromises","ssrDisabled","fetchDisabled","disableNetworkFetches","ssrLoading","addQueryPromise","prepareObservableQueryOptions","displayName","fetchPolicy","metadata","reactComponent","initializeObservableQuery","getSSRObservable","observableQueryOptions","watchQuery","registerSSRObservable","newObservableQueryOptions","catch","subscription","obsQuery","subscribe","previousResult","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","observableQueryFields","currentResult","partial","errors","graphQLErrors","partialRefetch","onCompleted","onError","unsubscribe","useBaseQuery","tick","updatedOptions","queryDataRef","current","queryData","memoFn","ref","useDeepMemo","queryResult","useQuery","setResult","runMutation","mutationFunctionOptions","onMutationStart","mutationId","generateNewMutationId","mutate","then","response","onMutationCompleted","onMutationError","mutation","mostRecentMutationId","optimisticResponse","update","awaitRefetchQueries","mutateOptions","mutateVariables","refetchQueries","mutationContext","ignoreResults","updateResult","isMostRecentMutation","useMutation","mutationDataRef","mutationData","initialize","getLoadingResult","shouldResubscribe","startSubscription","endSubscription","updateCurrentData","updateError","complete","completeSubscription","onSubscriptionData","subscriptionData","onSubscriptionComplete","queryPromises","queryInfoTrie","observable","props","lookupQueryInfo","queryInstance","finish","seen","Promise","resolve","hasPromises","consumeAndAwaitPromises","promises","forEach","promise","all","varMap","variablesString","JSON","stringify","opts","cmp","f","cycles","aobj","bobj","toJSON","isFinite","out","TypeError","seenIndex","sort","link","isTerminating","request","fromError","errorValue","observer","createOperation","starting","defineProperty","enumerable","getKey","passthrough","op","forward","of","toLink","handler","ApolloLink","empty","from","links","reduce","y","split","test","left","right","leftLink","rightLink","first","second","firstLink","nextLink","transformedOperation","extensions","transformOperation","OPERATION_FIELDS","validateOperation","Observable","getOperationName","definition","WeakMap","navigator","product","_objectWithoutProperties","excluded","target","sourceKeys","sourceSymbolKeys","propertyIsEnumerable","_typeof","obj","Symbol","iterator","formatValue","seenValues","previouslySeenValues","customInspectFn","object","String","nodejsCustomInspectSymbol","getCustomFn","customValue","Math","min","remaining","items","join","formatArray","tag","getObjectTag","formatObject","formatObjectValue","for","dedentBlockStringValue","rawString","lines","commonIndent","line","indent","leadingWhitespace","getBlockStringIndentation","isBlank","shift","str","printBlockString","indentation","preferMultipleLines","isSingleLine","hasLeadingSpace","hasTrailingQuote","printAsMultipleLines","NetworkStatus","isNetworkRequestInFlight","LinkObservable","isNonEmptyArray","FetchType","networkError","errorMessage","extraInfo","err","graphQLError","generateErrorMessage","ApolloError","queryManager","shouldSubscribe","onSubscribe","observers","isTornDown","queryId","generateQueryId","opDef","queryName","reject","delete","removeQuery","storeValue","policy","queryStoreValue","queryStore","isNetworkFetchPolicy","errorPolicy","updateLastResult","stale","isDifferentFromLastResult","newResult","lastResultSnapshot","snapshot","fetchQuery","combinedOptions","qid","normal","fetchMoreResult","stopQuery","startGraphQLSubscription","previous","setVariables","oldFetchPolicy","fetchResults","tryFetch","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","assertNotCacheFirstOrOnly","startPollingQuery","assumeImmutableResults","subObserver","_subscription","_observer","defaultSubscriptionObserverErrorCallback","setUpQuery","tearDownQuery","addObservableQuery","iterateObserversSafely","observeQuery","transform","hasClientExports","getLocalState","addExportedVariables","previousVariables","serverQuery","sub","removeObservableQuery","argument","observersWithMethod","store","getStore","initMutation","markMutationError","markMutationResult","initQuery","previousQuery","resolvers","fragmentMatcher","addResolvers","setFragmentMatcher","resolverGroup","setResolvers","getResolvers","runResolvers","remoteResult","onlyRunForcedResolvers","resolveDocument","localResult","getFragmentMatcher","clientQuery","prepareContext","getCacheKey","config","dataIdFromObject","buildRootValueFromCache","exportedVariables","shouldForceResolvers","forceResolvers","some","arg","diff","returnPartialData","optimistic","rootValue","mainDefinition","fragmentMap","definitionOperation","defaultOperationType","charAt","toUpperCase","execContext","resolveSelectionSet","selectionSet","resultsToMerge","selection","resolveField","fieldResult","fragment","typeCondition","fragmentResult","selections","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","resolverType","__typename","resolverMap","directives","directive","resolveSubSelectedArray","item","multiplex","inner","queryDeduplication","onBroadcast","ssrMode","clientAwareness","localState","mutationStore","MutationStore","QueryStore","idCounter","fetchQueryRejectFns","transformCache","inFlightLinkObservables","pollingInfoByQueryId","LocalState","getCache","stop","_info","stopQueryNoBroadcast","updateQueries","setQuery","getVariables","generateUpdateQueriesInfo","ret","updateQueriesByName","observableQuery","updater","markMutationInit","updateWithProxyFn","self","storeResult","getObservableFromLink","markMutationComplete","refetchQueryPromises","refetchQuery","queryOptions","fetchType","fetchMoreForQueryId","needToFetch","isNetworkOnly","shouldFetch","requestId","cancel","updateQueryWatch","lastRequestId","invalidated","invalidate","storePreviousVariables","isPoll","poll","isRefetch","networkResult","fetchRequest","getQuery","markQueryError","markQueryResultClient","hasForcedResolvers","markQueryResult","newData","queryListenerForObserver","invoke","networkStatusChanged","shouldNotifyIfLoading","notifyOnNetworkStatusChange","hasGraphQLErrors","isMissing","errorStatusChanged","diffResult","resultFromStore","transformed","transformDocument","forLink","transformForLink","defaultVars","transformedOptions","ObservableQuery","watchedQuery","stopQueryInStore","stopQueryInStoreNoBroadcast","addQueryListener","listener","watch","clearStore","resetIds","resetStore","reFetchObservableQueries","includeStandby","observableQueryPromises","startQuery","makeObservable","markSubscriptionResult","getCurrentQueryResult","getQueryWithPreviousResult","queryIdOrObservable","foundObserveableQuery","id","deduplication","forceFetch","activeNextCount","completed","asyncMap","errorsFromStore","fqrfId","newInfo","newContext","checkInFlight","interval","initialCache","ignoreErrors","writeWithErrors","write","dataId","recordOptimisticTransaction","c","orig","nextQueryResult","currentQueryResult","mutationResult","queryVariables","performTransaction","removeOptimistic","defaultOptions","resetStoreCallbacks","clearStoreCallbacks","ssrForceFetchDelay","connectToDevTools","typeDefs","DataStore","window","__APOLLO_CLIENT__","QueryManager","clientAwarenessName","clientAwarenessVersion","devToolsHookCb","action","state","dataWithOptimisticResults","extract","readQuery","readFragment","writeQuery","writeFragment","writeData","__actionHookForDevTools","cb","__requestRaw","payload","initQueryManager","fn","onResetStore","onClearStore","restore","serializedState","setLocalStateFragmentMatcher","__awaiter","thisArg","_arguments","P","generator","fulfilled","step","rejected","__generator","g","_","label","sent","trys","ops","verb","v","__spreadArrays","il","r","j","jl","_createClass","descriptor","configurable","writable","Constructor","protoProps","staticProps","_classCallCheck","instance","hasSymbols","hasSymbol","getSymbol","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","getSpecies","ctor","isObservable","hostReportError","log","enqueue","cleanupSubscription","_cleanup","closeSubscription","_queue","_state","notifySubscription","m","onNotify","flushSubscription","subscriber","subscriptionObserver","SubscriptionObserver","_subscriber","_this2","_this3","_this4","C","hasSeed","hasValue","seed","acc","_this5","_len","sources","_key","startNext","_this6","outer","completeIfDone","closed","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","return","_len2","_key2","symbol","valueToObjectRepresentation","argObj","isIntValue","isFloatValue","Number","isBooleanValue","isStringValue","isObjectValue","fields","isVariable","variableValue","isListValue","values","listValue","nestedArgArrayObj","isEnumValue","isNullValue","argumentsObjectFromField","resultKeyNameFromField","alias","isField","isInlineFragment","shouldInclude","isInclusionDirective","directiveArguments","ifArgument","ifValue","evaledValue","hasDirectives","names","getDirectiveNames","checkDocument","operations","getOperationDefinition","getFragmentDefinitions","getMainDefinition","queryDoc","createFragmentMap","symTable","getDefaultValues","variableDefinitions","defaultValues","defaultValue","variable","defaultValueObj","filterInPlace","elem","nullIfDocIsEmpty","isEmpty","fragmentDef","getFragmentDefinition","getDirectiveMatcher","removeDirectivesFromDocument","variablesInUse","variablesToRemove","fragmentSpreadsInUse","fragmentSpreadsToRemove","modifiedDoc","remove","getAllFragmentSpreadsFromSelectionSet","allFragments","frag","argMatcher","aConfig","getArgumentMatcher","varDef","argConfig","removeArgumentsFromDocument","fs","def","removeFragmentSpreadFromDocument","connectionRemoveConfig","willRemove","removeConnectionDirectiveFromDocument","buildQueryFromSelectionSet","removeClientSetsFromDocument","canUseWeakMap","cloneDeep","cloneDeepHelper","val","child","getPrototypeOf","tryFunctionOrLogError","graphQLResultHasError","mergeDeep","mergeDeepArray","count","pastCopies","shallowCopyForMerge","mergeHelper","isObject","isExtensible","sourceValue","targetValue","storeKeyNameFromField","directivesObj","getStoreKeyName","KNOWN_DIRECTIVES","filterKeys","completeFieldName","stringifiedArgs","isIdValue","idObject","generated","toIdValue","idConfig","typename","isJsonValue","jsonObject","getDirectiveInfoFromField","getQueryDefinition","queryDef","TYPENAME_FIELD","addTypenameToDocument","isEnv","isProduction","isTest","maybeDeepFreeze","deepFreeze","o","getOwnPropertyNames","prop","isFrozen","getFragmentQueryDocument","actualFragmentName","devAssert","defineToJSON","classObject","getLocation","position","match","lineRegexp","column","exec","printLocation","location","printSourceLocation","sourceLocation","firstLineColumnOffset","locationOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","locationLine","sublineIndex","floor","sublineColumnNum","sublines","printPrefixedLines","subline","existingLines","_ref","padLen","max","_ref2","_ref3","prefix","GraphQLError","nodes","positions","originalError","_nodes","_source","_locations","_positions","list","pos","_extensions","originalExtensions","locations","captureStackTrace","syntaxError","description","output","_error$nodes2","_i4","_error$locations2","printError","Kind","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","Source","toStringTag","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","advanceLexer","lastToken","token","lookahead","readToken","Tok","printCharCode","code","isNaN","fromCharCode","lexer","bodyLength","startPosition","charCodeAt","lineStart","positionAfterWhitespace","col","readComment","readName","firstCode","isFloat","readDigits","readNumber","chunkStart","rawValue","readBlockString","charCode","char2hex","invalidSequence","readString","unexpectedCharacterMessage","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Parser","parseValue","expectToken","parseValueLiteral","parseType","parseTypeReference","sourceObj","_lexer","startOfFileToken","advance","createLexer","_options","_proto","parseName","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","parseVariable","expectOptionalToken","parseSelection","parseFragment","parseField","nameOrAlias","parseArguments","isConst","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","parseNamedType","expectKeyword","parseList","parseObject","parseStringLiteral","block","any","parseObjectField","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","types","allowLegacySDLImplementsInterfaces","allowLegacySDLEmptyFields","parseFieldDefinition","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","parseDirectiveLocations","parseDirectiveLocation","noLocation","Loc","getTokenDesc","atToken","openKind","parseFn","closeKind","queryFromPojo","selectionSetFromObj","Cache","justTypenameQuery","currentContext","MISSING_VALUE","host","Slot","Date","now","random","slots","getValue","withValue","saved","noContext","defaultDispose","dispose","newest","oldest","entry","getEntry","older","newer","clean","parentEntrySlot","reusableEmptyArray","emptySetPool","assert","optionalMessage","valueGet","parents","childValues","dirtyChildren","dirty","recomputing","Entry","recompute","mightBeDirty","reportDirtyChild","reportCleanChild","rememberParent","maybeReportOrphan","originalChildren","forgetChildren","recomputeNewValue","maybeUnsubscribe","setDirty","maybeSubscribe","reportClean","setClean","reallyRecompute","reportDirty","forgetChild","childValue","valueIs","removeDirtyChild","dc","reportOrphan","_value","weakness","lookup","lookupArray","getChildTrie","isObjRef","weak","strong","KeyTrie","haveWarned","shouldWarn","answer","ensureReady","canBypassInit","idValue","isRootQuery","hasOwn","introspectionQueryResultData","possibleTypesMap","parseIntrospectionResult","isReady","implementingTypes","introspectionResultData","typeMap","__schema","possibleTypes","implementingType","depend","wrap","disposable","makeCacheKey","toObject","defaultNormalizedCacheFactory","cacheKeyRoot","freezeResults","executeStoreQuery","executeSelectionSet","executeSubSelectedArray","contextValue","variableValues","readQueryFromStore","diffQueryAgainstStore","rootId","fragmentMatcherFunction","queryDefinition","cacheRedirects","execResult","hasMissingFields","missing","tolerable","finalResult","objectsToMerge","handleMissing","executeField","fragmentExecResult","readStoreResult","resultKey","storeKeyName","fieldValue","resolver","storeObj","json","readStoreResolver","combineExecResults","assertSelectionSetForIdValue","execResults","childResult","defaultFragmentMatcher","writeQueryToStore","writeResultToStore","operationDefinition","writeSelectionSetToStore","processedData","enhancedError","enhanceErrorWithDocument","resultFieldKey","writeFieldToStore","isDefered","isClient","matches","fakeContext","ObjectCache","storeObject","storeFieldName","generatedId","processArrayValue","valueDataId","isGeneratedId","semanticId","isDataProcessed","escapedId","hadTypename","hasTypename","typenameChanged","mergeWithGenerated","generatedKey","realKey","real","madeChanges","realValue","newRealValue","itemDataId","defaultConfig","HeuristicFragmentMatcher","_id","addTypename","resultCaching","optimisticId","transaction","watches","typenameDocumentCache","silenceBroadcast","customResolvers","cacheResolvers","optimisticData","storeWriter","storeReader","maybeBroadcastWatch","read","broadcastWatches","evict","idToRemove","toReapply","removedCount","layer","print","printDocASTReducer","varDefs","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","_ref20","_ref21","addDescription","_ref22","_ref23","_ref24","hasMultilineItems","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","maybeArray","separator","maybeString","isMultiline","fallbackHttpConfig","http","includeQuery","includeExtensions","headers","accept","throwServerError","statusCode","status","serialized","parseError","linkOptions","uri","fetch","useGETForQueries","fetcher","linkConfig","requestOptions","fetchOptions","credentials","chosenURI","fallbackURI","contextURI","getContext","selectURI","clientAwarenessHeaders","controller","contextHeaders","contextConfig","fallbackConfig","configs","signal","AbortController","_controller","queryParams","addQueryParam","encodeURIComponent","serializedVariables","serializedExtensions","preFragment","fragmentStart","substr","queryParamsPrefix","newURI","setContext","text","bodyText","abort"],"mappings":";+MAEE,SAAAA,sBAAA,oB,wBAGC,EAGH,cAGE,WAAYC,QAAA,IAAAA,MAXS,uBAWrB,MACE,YACqB,kBAAZA,EACAC,wBAAmBD,EAAO,6DAC7BA,IACL,K,OAPH,EAAAE,YAAc,EACd,EAAAC,KAVqB,sBAiBnBJ,EAAe,EAAMK,EAAeC,W,EAExC,OAXoC,iBAWpC,EAXA,CAAoCC,O,SAapBC,EAAUC,EAAgBR,GACxC,IAAKQ,EACH,MAAM,IAAIJ,EAAeJ,GAI7B,SAASS,EAAkBC,GACzB,OAAO,WACL,OAAOC,QAAQD,GAAQE,MAAMD,QAASE,aAI1C,SAAiBN,GACF,EAAAO,KAAOL,EAAkB,QACzB,EAAAM,MAAQN,EAAkB,SAFzC,CAAiBF,MAAS,KAU1B,IAAIS,EAA8B,CAAEC,IAAK,IAEzC,GAAuB,kBAAZC,EACTF,EAAcE,OACT,IAILC,SAAS,OAAQ,iBAAjBA,CAAmCH,GACnC,MAAOI,O,oDCpDT,sCAAIC,EAAKC,OAAOjB,UAAWkB,EAAWF,EAAGE,SAAUC,EAAiBH,EAAGG,eA2HnEC,EAAU,IA1He,WACzB,SAASC,IACLC,KAAKC,OAAS,GACdD,KAAKE,OAAS,GAqHlB,OAnHAH,EAAQrB,UAAUyB,MAAQ,WAGtB,OAFAH,KAAKC,OAAOG,OAAS,EACrBJ,KAAKE,OAAOE,OAAS,EACdJ,MAEXD,EAAQrB,UAAU2B,MAAQ,SAAUC,EAAGC,GACnC,IAAIC,EAAQR,KAEZ,GAAIM,IAAMC,EACN,OAAO,EAIX,IAAIE,EAAOb,EAASc,KAAKJ,GACrBK,EAAOf,EAASc,KAAKH,GAIzB,GAAIE,IAASE,EACT,OAAO,EAEX,OAAQF,GACJ,IAAK,iBAGD,GAAIH,EAAEF,SAAWG,EAAEH,OACf,OAAO,EAGf,IAAK,kBACD,OAAOJ,KAAKY,eAAeN,EAAGC,GAAG,WAC7B,IAAIM,EAAQlB,OAAOmB,KAAKR,GACpBS,EAAQpB,OAAOmB,KAAKP,GACxB,OAGAM,EAAMT,SAAWW,EAAMX,QAEnBW,EAAMC,OAAM,SAAUC,GAAO,OAAOpB,EAAea,KAAKJ,EAAGW,OAE3DJ,EAAMG,OAAM,SAAUC,GAAO,OAAOT,EAAMH,MAAMC,EAAEW,GAAMV,EAAEU,UAEtE,IAAK,iBACD,OAAOX,EAAE9B,OAAS+B,EAAE/B,MAAQ8B,EAAEjC,UAAYkC,EAAElC,QAChD,IAAK,kBAED,GAAIiC,IAAMA,EACN,OAAOC,IAAMA,EAErB,IAAK,mBACL,IAAK,gBACD,OAAQD,KAAOC,EACnB,IAAK,kBACL,IAAK,kBACD,OAAOD,GAAK,GAAKC,EACrB,IAAK,eACL,IAAK,eACD,OAAID,EAAEY,OAASX,EAAEW,MAGVlB,KAAKY,eAAeN,EAAGC,GAAG,WAE7B,IADA,IAAIY,EAAYb,EAAEc,YACL,CACT,IAAIC,EAAOF,EAAUG,OACrB,GAAID,EAAKE,KACL,MAEJ,IAAI7B,EAAK2B,EAAKG,MAAOC,EAAO/B,EAAG,GAAIgC,EAAShC,EAAG,GAE/C,IAAKa,EAAEoB,IAAIF,GACP,OAAO,EAEX,GAGS,iBAAThB,IACKD,EAAMH,MAAMqB,EAAQnB,EAAEqB,IAAIH,IAC3B,OAAO,EAGf,OAAO,KAKnB,OAAO,GAEX1B,EAAQrB,UAAUkC,eAAiB,SAAUN,EAAGC,EAAGsB,GAW/C,IAAIC,EAAS9B,KAAKC,OAAO8B,YAAYzB,GACrC,GAAIwB,GAAU,EAAG,CACb,IAAIE,EAAShC,KAAKE,OAAO6B,YAAYxB,GACrC,GAAIyB,GAAU,EACV,OAAOF,IAAWE,EAG1BhC,KAAKC,OAAOgC,KAAK3B,GACjBN,KAAKE,OAAO+B,KAAK1B,GACjB,IACI,OAAOsB,IADX,QAII7B,KAAKC,OAAOiC,MACZlC,KAAKE,OAAOgC,QAGbnC,EAxHkB,IA8H7B,SAASoC,EAAM7B,EAAGC,GACd,OAAOT,EAAQK,QAAQE,MAAMC,EAAGC,K,kBC/HpC,IAOI6B,EACAC,EARA9C,EAAU+C,EAAOC,QAAU,GAU/B,SAASC,IACL,MAAM,IAAI7D,MAAM,mCAEpB,SAAS8D,IACL,MAAM,IAAI9D,MAAM,qCAsBpB,SAAS+D,EAAWC,GAChB,GAAIP,IAAqBQ,WAErB,OAAOA,WAAWD,EAAK,GAG3B,IAAKP,IAAqBI,IAAqBJ,IAAqBQ,WAEhE,OADAR,EAAmBQ,WACZA,WAAWD,EAAK,GAE3B,IAEI,OAAOP,EAAiBO,EAAK,GAC/B,MAAME,GACJ,IAEI,OAAOT,EAAiB1B,KAAK,KAAMiC,EAAK,GAC1C,MAAME,GAEJ,OAAOT,EAAiB1B,KAAKV,KAAM2C,EAAK,MAvCnD,WACG,IAEQP,EADsB,oBAAfQ,WACYA,WAEAJ,EAEzB,MAAOK,GACLT,EAAmBI,EAEvB,IAEQH,EADwB,oBAAjBS,aACcA,aAEAL,EAE3B,MAAOI,GACLR,EAAqBI,GAjB5B,GAwED,IAEIM,EAFAC,EAAQ,GACRC,GAAW,EAEXC,GAAc,EAElB,SAASC,IACAF,GAAaF,IAGlBE,GAAW,EACPF,EAAa3C,OACb4C,EAAQD,EAAaK,OAAOJ,GAE5BE,GAAc,EAEdF,EAAM5C,QACNiD,KAIR,SAASA,IACL,IAAIJ,EAAJ,CAGA,IAAIK,EAAUZ,EAAWS,GACzBF,GAAW,EAGX,IADA,IAAIM,EAAMP,EAAM5C,OACVmD,GAAK,CAGP,IAFAR,EAAeC,EACfA,EAAQ,KACCE,EAAaK,GACdR,GACAA,EAAaG,GAAYM,MAGjCN,GAAc,EACdK,EAAMP,EAAM5C,OAEhB2C,EAAe,KACfE,GAAW,EAnEf,SAAyBQ,GACrB,GAAIpB,IAAuBS,aAEvB,OAAOA,aAAaW,GAGxB,IAAKpB,IAAuBI,IAAwBJ,IAAuBS,aAEvE,OADAT,EAAqBS,aACdA,aAAaW,GAExB,IAEWpB,EAAmBoB,GAC5B,MAAOZ,GACL,IAEI,OAAOR,EAAmB3B,KAAK,KAAM+C,GACvC,MAAOZ,GAGL,OAAOR,EAAmB3B,KAAKV,KAAMyD,KAgD7CC,CAAgBJ,IAiBpB,SAASK,EAAKhB,EAAKiB,GACf5D,KAAK2C,IAAMA,EACX3C,KAAK4D,MAAQA,EAYjB,SAASC,KA5BTtE,EAAQuE,SAAW,SAAUnB,GACzB,IAAIoB,EAAO,IAAIC,MAAM9E,UAAUkB,OAAS,GACxC,GAAIlB,UAAUkB,OAAS,EACnB,IAAK,IAAI6D,EAAI,EAAGA,EAAI/E,UAAUkB,OAAQ6D,IAClCF,EAAKE,EAAI,GAAK/E,UAAU+E,GAGhCjB,EAAMf,KAAK,IAAI0B,EAAKhB,EAAKoB,IACJ,IAAjBf,EAAM5C,QAAiB6C,GACvBP,EAAWW,IASnBM,EAAKjF,UAAU8E,IAAM,WACjBxD,KAAK2C,IAAI1D,MAAM,KAAMe,KAAK4D,QAE9BrE,EAAQ2E,MAAQ,UAChB3E,EAAQ4E,SAAU,EAClB5E,EAAQD,IAAM,GACdC,EAAQ6E,KAAO,GACf7E,EAAQ8E,QAAU,GAClB9E,EAAQ+E,SAAW,GAInB/E,EAAQgF,GAAKV,EACbtE,EAAQiF,YAAcX,EACtBtE,EAAQkF,KAAOZ,EACftE,EAAQmF,IAAMb,EACdtE,EAAQoF,eAAiBd,EACzBtE,EAAQqF,mBAAqBf,EAC7BtE,EAAQsF,KAAOhB,EACftE,EAAQuF,gBAAkBjB,EAC1BtE,EAAQwF,oBAAsBlB,EAE9BtE,EAAQyF,UAAY,SAAUxG,GAAQ,MAAO,IAE7Ce,EAAQ0F,QAAU,SAAUzG,GACxB,MAAM,IAAIG,MAAM,qCAGpBY,EAAQ2F,IAAM,WAAc,MAAO,KACnC3F,EAAQ4F,MAAQ,SAAUC,GACtB,MAAM,IAAIzG,MAAM,mCAEpBY,EAAQ8F,MAAQ,WAAa,OAAO,I,iCCvLpC,sGAgBA,IAAIC,EAAgB,SAASC,EAAGhF,GAI5B,OAHA+E,EAAgB3F,OAAOvB,gBAClB,CAAEoH,UAAW,cAAgBxB,OAAS,SAAUuB,EAAGhF,GAAKgF,EAAEC,UAAYjF,IACvE,SAAUgF,EAAGhF,GAAK,IAAK,IAAIkF,KAAKlF,EAAOA,EAAEV,eAAe4F,KAAIF,EAAEE,GAAKlF,EAAEkF,MACpDF,EAAGhF,IAGrB,SAASmF,EAAUH,EAAGhF,GAEzB,SAASoF,IAAO3F,KAAK4F,YAAcL,EADnCD,EAAcC,EAAGhF,GAEjBgF,EAAE7G,UAAkB,OAAN6B,EAAaZ,OAAOkG,OAAOtF,IAAMoF,EAAGjH,UAAY6B,EAAE7B,UAAW,IAAIiH,GAG5E,IAAIG,EAAW,WAQlB,OAPAA,EAAWnG,OAAOoG,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGhC,EAAI,EAAGiC,EAAIhH,UAAUkB,OAAQ6D,EAAIiC,EAAGjC,IAE5C,IAAK,IAAIwB,KADTQ,EAAI/G,UAAU+E,GACOtE,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,KAAIO,EAAEP,GAAKQ,EAAER,IAE9E,OAAOO,IAEK/G,MAAMe,KAAMd,YAGzB,SAASiH,EAAOF,EAAGpD,GACtB,IAAImD,EAAI,GACR,IAAK,IAAIP,KAAKQ,EAAOtG,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,IAAM5C,EAAEuD,QAAQX,GAAK,IAC9EO,EAAEP,GAAKQ,EAAER,IACb,GAAS,MAALQ,GAAqD,oBAAjCtG,OAAO0G,sBACtB,KAAIpC,EAAI,EAAb,IAAgBwB,EAAI9F,OAAO0G,sBAAsBJ,GAAIhC,EAAIwB,EAAErF,OAAQ6D,IAASpB,EAAEuD,QAAQX,EAAExB,IAAM,IAC1F+B,EAAEP,EAAExB,IAAMgC,EAAER,EAAExB,KACtB,OAAO+B,I,+MCvCPM,E,yBAEJ,SAAgBC,IAId,OAHKD,IACHA,EAAgB,IAAME,cAAkC,KAEnDF,E,ICNGG,ECGCC,EAAqD,SAAC,G,IACjEC,EAAA,EAAAA,OACAC,EAAA,EAAAA,SAEMC,EAAgBN,IACtB,OAAO,oBACS,2BAYV,YAXA,IAAAO,MAAA,IACIH,GAAUG,EAAQH,SAAWA,IAC/BG,EAAUnH,OAAOoG,OAAO,GAAIe,EAAS,CAAEH,OAAM,KAG/C,wBAOE,kBAACE,EAAcE,SAAQ,CAACvF,MAAOsF,GAC5BF,QDvBb,SAAYH,GACV,qBACA,2BACA,mCAHF,CAAYA,MAAY,KAYxB,IAAMO,EAAQ,IAAIC,IAElB,SAAgBC,EAAcC,GAC5B,IAAI3I,EACJ,OAAQ2I,GACN,KAAKV,EAAaW,MAChB5I,EAAO,QACP,MACF,KAAKiI,EAAaY,SAChB7I,EAAO,WACP,MACF,KAAKiI,EAAaa,aAChB9I,EAAO,eAGX,OAAOA,EAIT,SAAgB+I,EAAOC,GACrB,IAGIC,EAAWN,EAHTO,EAASV,EAAMpF,IAAI4F,GACzB,GAAIE,EAAQ,OAAOA,EAKF,mBACQ,UAKzB,IAAMC,EAAYH,EAASI,YAAYC,QACrC,SAACC,GAAsB,MAAW,uBAAXA,EAAEC,QAGrBC,EAAUR,EAASI,YAAYC,QACnC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,UAAhBD,EAAEG,aAGpCC,EAAYV,EAASI,YAAYC,QACrC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,aAAhBD,EAAEG,aAGpCE,EAAgBX,EAASI,YAAYC,QACzC,SAACC,GACC,MAAW,wBAAXA,EAAEC,MAAkD,iBAAhBD,EAAEG,aAI9B,uBACPD,EAAQ5H,QAAU8H,EAAU9H,QAAU+H,EAAc/H,OACvD,GAOmC,cAAa,gBAAA+H,EAAc/H,QAAd,KAMlD,EAAI,SAAoB,mBAAkB,UAAoB,WAExD,kB,IACJ,WACE,E,SAEA,EAGF,E,4BAOF,WAEA,IAAuB,wBAOvB,YANE,EAAA5B,MAA6B,SAA7B,EAA6B,U,oBAMH,oB,OAC5B,W,qCEjHF,iFACW4J,EAAoB,CAC7BC,KAAM,GACNC,SAAU,CAAC,eACXC,oBAAqB,CAAC,OAAQ,sBAAuB,aAAc,gBACnEC,mBAAoB,CAAC,WAAY,OAAQ,eAAgB,cACzDC,SAAU,CAAC,QACXC,aAAc,CAAC,cACfC,MAAO,CAAC,QAAS,OAAQ,YAAa,aAAc,gBACpDC,SAAU,CAAC,OAAQ,SACnBC,eAAgB,CAAC,OAAQ,cACzBC,eAAgB,CAAC,gBAAiB,aAAc,gBAChDC,mBAAoB,CAAC,OAErB,sBAAuB,gBAAiB,aAAc,gBACtDC,SAAU,GACVC,WAAY,GACZC,YAAa,GACbC,aAAc,GACdC,UAAW,GACXC,UAAW,GACXC,UAAW,CAAC,UACZC,YAAa,CAAC,UACdC,YAAa,CAAC,OAAQ,SACtBC,UAAW,CAAC,OAAQ,aACpBC,UAAW,CAAC,QACZC,SAAU,CAAC,QACXC,YAAa,CAAC,QACdC,iBAAkB,CAAC,aAAc,kBACjCC,wBAAyB,CAAC,QAC1BC,qBAAsB,CAAC,cAAe,OAAQ,cAC9CC,qBAAsB,CAAC,cAAe,OAAQ,aAAc,aAAc,UAC1EC,gBAAiB,CAAC,cAAe,OAAQ,YAAa,OAAQ,cAC9DC,qBAAsB,CAAC,cAAe,OAAQ,OAAQ,eAAgB,cACtEC,wBAAyB,CAAC,cAAe,OAAQ,aAAc,UAC/DC,oBAAqB,CAAC,cAAe,OAAQ,aAAc,SAC3DC,mBAAoB,CAAC,cAAe,OAAQ,aAAc,UAC1DC,oBAAqB,CAAC,cAAe,OAAQ,cAC7CC,0BAA2B,CAAC,cAAe,OAAQ,aAAc,UACjEC,oBAAqB,CAAC,cAAe,OAAQ,YAAa,aAC1DC,gBAAiB,CAAC,aAAc,kBAChCC,oBAAqB,CAAC,OAAQ,cAC9BC,oBAAqB,CAAC,OAAQ,aAAc,aAAc,UAC1DC,uBAAwB,CAAC,OAAQ,aAAc,UAC/CC,mBAAoB,CAAC,OAAQ,aAAc,SAC3CC,kBAAmB,CAAC,OAAQ,aAAc,UAC1CC,yBAA0B,CAAC,OAAQ,aAAc,WAExCC,EAAQrL,OAAOsL,OAAO,IAwF1B,SAASC,EAAMC,EAAMC,GAC1B,IAAIC,EAAcnM,UAAUkB,OAAS,QAAsBkL,IAAjBpM,UAAU,GAAmBA,UAAU,GAAKkJ,EAGlFmD,OAAQD,EACRE,EAAUxH,MAAMyH,QAAQN,GACxBrK,EAAO,CAACqK,GACRO,GAAS,EACTC,EAAQ,GACRC,OAAON,EACPrK,OAAMqK,EACNO,OAASP,EACTQ,EAAO,GACPC,EAAY,GACZC,EAAUb,EAGd,EAAG,CAED,IAAIc,IADJP,IAC0B5K,EAAKV,OAC3B8L,EAAWD,GAA8B,IAAjBN,EAAMvL,OAElC,GAAI6L,EAAW,CAKb,GAJAhL,EAA2B,IAArB8K,EAAU3L,YAAekL,EAAYQ,EAAKA,EAAK1L,OAAS,GAC9DwL,EAAOC,EACPA,EAASE,EAAU7J,MAEfgK,EAAU,CACZ,GAAIV,EACFI,EAAOA,EAAKO,YACP,CAGL,IAFA,IAAIC,EAAQ,GAEHC,EAAM,EAAGC,EAAgB3M,OAAOmB,KAAK8K,GAAOS,EAAMC,EAAclM,OAAQiM,IAAO,CACtF,IAAIE,EAAID,EAAcD,GACtBD,EAAMG,GAAKX,EAAKW,GAGlBX,EAAOQ,EAKT,IAFA,IAAII,EAAa,EAERC,EAAK,EAAGA,EAAKd,EAAMvL,OAAQqM,IAAM,CACxC,IAAIC,EAAUf,EAAMc,GAAI,GACpBE,EAAYhB,EAAMc,GAAI,GAEtBjB,IACFkB,GAAWF,GAGThB,GAAyB,OAAdmB,GACbf,EAAKgB,OAAOF,EAAS,GACrBF,KAEAZ,EAAKc,GAAWC,GAKtBjB,EAAQH,EAAMG,MACd5K,EAAOyK,EAAMzK,KACb6K,EAAQJ,EAAMI,MACdH,EAAUD,EAAMC,QAChBD,EAAQA,EAAMsB,SACT,CAIL,GAHA5L,EAAM4K,EAASL,EAAUE,EAAQ5K,EAAK4K,QAASJ,EAGlC,QAFbM,EAAOC,EAASA,EAAO5K,GAAO+K,SAEAV,IAATM,EACnB,SAGEC,GACFC,EAAK7J,KAAKhB,GAId,IAAI6L,OAAS,EAEb,IAAK9I,MAAMyH,QAAQG,GAAO,CACxB,IAAKmB,EAAOnB,GACV,MAAM,IAAIjN,MAAM,qBAAuBqO,YAAQpB,IAGjD,IAAIqB,EAAUC,EAAW9B,EAASQ,EAAK7D,KAAMkE,GAE7C,GAAIgB,EAAS,CAGX,IAFAH,EAASG,EAAQvM,KAAK0K,EAASQ,EAAM3K,EAAK4K,EAAQC,EAAMC,MAEzCf,EACb,MAGF,IAAe,IAAX8B,GACF,IAAKb,EAAW,CACdH,EAAK5J,MACL,eAEG,QAAeoJ,IAAXwB,IACTnB,EAAM1J,KAAK,CAAChB,EAAK6L,KAEZb,GAAW,CACd,IAAIc,EAAOD,GAEJ,CACLhB,EAAK5J,MACL,SAHA0J,EAAOkB,SAUFxB,IAAXwB,GAAwBZ,GAC1BP,EAAM1J,KAAK,CAAChB,EAAK2K,IAGfK,EACFH,EAAK5J,OAELqJ,EAAQ,CACNC,QAASA,EACTE,MAAOA,EACP5K,KAAMA,EACN6K,MAAOA,EACPkB,KAAMtB,GAGRzK,GADA0K,EAAUxH,MAAMyH,QAAQG,IACPA,EAAOP,EAAYO,EAAK7D,OAAS,GAClD2D,GAAS,EACTC,EAAQ,GAEJE,GACFE,EAAU9J,KAAK4J,GAGjBA,EAASD,cAEMN,IAAVC,GAMT,OAJqB,IAAjBI,EAAMvL,SACR4L,EAAUL,EAAMA,EAAMvL,OAAS,GAAG,IAG7B4L,EAGT,SAASe,EAAOI,GACd,OAAOC,QAAQD,GAAuC,kBAAnBA,EAAUpF,MAwGxC,SAASmF,EAAW9B,EAASrD,EAAMkE,GACxC,IAAIoB,EAAcjC,EAAQrD,GAE1B,GAAIsF,EAAa,CACf,IAAKpB,GAAoC,oBAAhBoB,EAEvB,OAAOA,EAGT,IAAIC,EAAsBrB,EAAYoB,EAAYE,MAAQF,EAAYG,MAEtE,GAAmC,oBAAxBF,EAET,OAAOA,MAEJ,CACL,IAAIG,EAAkBxB,EAAYb,EAAQmC,MAAQnC,EAAQoC,MAE1D,GAAIC,EAAiB,CACnB,GAA+B,oBAApBA,EAET,OAAOA,EAGT,IAAIC,EAAsBD,EAAgB1F,GAE1C,GAAmC,oBAAxB2F,EAET,OAAOA,M,iCCjaA,SAASC,EAAuBC,EAASC,GAKtD,OAJKA,IACHA,EAAMD,EAAQzB,MAAM,IAGfxM,OAAOsL,OAAOtL,OAAOmO,iBAAiBF,EAAS,CACpDC,IAAK,CACHrM,MAAO7B,OAAOsL,OAAO4C,OAP3B,mC,oBCAA,IAEIE,EAFSC,EAAQ,KAEFD,MAInB,SAASE,EAAUC,GACjB,OAAOA,EAAOC,QAAQ,UAAW,KAAKC,OAIxC,IAAIC,EAAW,GAGXC,EAAoB,GAexB,IAAIC,GAAwB,EA2F5B,IAAIC,GAAgC,EACpC,SAASC,EAAcC,GACrB,IAAIC,EAAWV,EAAUS,GAEzB,GAAIL,EAASM,GACX,OAAON,EAASM,GAGlB,IAAIC,EAASb,EAAMW,EAAK,CAAEF,8BAA+BA,IACzD,IAAKI,GAA0B,aAAhBA,EAAO7G,KACpB,MAAM,IAAIpJ,MAAM,iCASlB,OAHAiQ,EA5DF,SAASC,EAASH,EAAKI,GACrB,IAAIC,EAAUpP,OAAOjB,UAAUkB,SAASc,KAAKgO,GAE7C,GAAgB,mBAAZK,EACF,OAAOL,EAAIM,KAAI,SAAUzJ,GACvB,OAAOsJ,EAAStJ,EAAGuJ,MAIvB,GAAgB,oBAAZC,EACF,MAAM,IAAIpQ,MAAM,qBAKdmQ,GAAwBJ,EAAIO,YACvBP,EAAIO,IAITP,EAAIO,aACCP,EAAIO,IAAIC,kBACRR,EAAIO,IAAIE,UAGjB,IACIlO,EACAO,EACA4N,EAHAtO,EAAOnB,OAAOmB,KAAK4N,GAKvB,IAAKzN,KAAOH,EACNA,EAAKjB,eAAeoB,KACtBO,EAAQkN,EAAI5N,EAAKG,IAGC,qBAFlBmO,EAAYzP,OAAOjB,UAAUkB,SAASc,KAAKc,KAEU,mBAAd4N,IACrCV,EAAI5N,EAAKG,IAAQ4N,EAASrN,GAAO,KAKvC,OAAOkN,EAmBEG,CADTD,EAzGF,SAA0BS,GAIxB,IAHA,IAfuBJ,EAenBK,EAAiB,GACjB1H,EAAc,GAET3D,EAAI,EAAGA,EAAIoL,EAAIzH,YAAYxH,OAAQ6D,IAAK,CAC/C,IAAIsL,EAAqBF,EAAIzH,YAAY3D,GAEzC,GAAgC,uBAA5BsL,EAAmBxH,KAA+B,CACpD,IAAIyH,EAAeD,EAAmB/Q,KAAKgD,MACvCiO,EAtBDxB,GADgBgB,EAuBaM,EAAmBN,KAtBlCS,OAAOC,KAAKC,UAAUX,EAAIY,MAAOZ,EAAIa,MAyBlDxB,EAAkBzO,eAAe2P,KAAkBlB,EAAkBkB,GAAcC,IAIjFlB,GACFvP,QAAQG,KAAK,+BAAiCqQ,EAAe,iMAK/DlB,EAAkBkB,GAAcC,IAAa,GAEnCnB,EAAkBzO,eAAe2P,KAC3ClB,EAAkBkB,GAAgB,GAClClB,EAAkBkB,GAAcC,IAAa,GAG1CH,EAAeG,KAClBH,EAAeG,IAAa,EAC5B7H,EAAY3F,KAAKsN,SAGnB3H,EAAY3F,KAAKsN,GAKrB,OADAF,EAAIzH,YAAcA,EACXyH,EAkEEU,CAAiBnB,IACA,GAC1BP,EAASM,GAAYC,EAEdA,EAYT,SAASoB,IAQP,IAPA,IAAIjM,EAAOC,MAAMtF,UAAUyN,MAAMzL,KAAKxB,WAElC+Q,EAAWlM,EAAK,GAGhB+I,EAA+B,kBAAdmD,EAA0BA,EAAWA,EAAS,GAE1DhM,EAAI,EAAGA,EAAIF,EAAK3D,OAAQ6D,IAC3BF,EAAKE,IAAMF,EAAKE,GAAG8D,MAAyB,aAAjBhE,EAAKE,GAAG8D,KACrC+E,GAAU/I,EAAKE,GAAGgL,IAAIS,OAAOC,KAE7B7C,GAAU/I,EAAKE,GAGjB6I,GAAUmD,EAAShM,GAGrB,OAAOwK,EAAc3B,GAIvBkD,EAAIE,QAAUF,EACdA,EAAIG,YAzJJ,WACE9B,EAAW,GACXC,EAAoB,IAwJtB0B,EAAII,wBAvGJ,WACE7B,GAAwB,GAuG1ByB,EAAIK,oCAlCJ,WACE7B,GAAgC,GAkClCwB,EAAIM,qCA/BJ,WACE9B,GAAgC,GAgClClM,EAAOC,QAAUyN,G,8CCnKb1K,EAAgB,SAASC,EAAGhF,GAI5B,OAHA+E,EAAgB3F,OAAOvB,gBAClB,CAAEoH,UAAW,cAAgBxB,OAAS,SAAUuB,EAAGhF,GAAKgF,EAAEC,UAAYjF,IACvE,SAAUgF,EAAGhF,GAAK,IAAK,IAAIkF,KAAKlF,EAAOA,EAAEV,eAAe4F,KAAIF,EAAEE,GAAKlF,EAAEkF,MACpDF,EAAGhF,IAGrB,SAASmF,EAAUH,EAAGhF,GAEzB,SAASoF,IAAO3F,KAAK4F,YAAcL,EADnCD,EAAcC,EAAGhF,GAEjBgF,EAAE7G,UAAkB,OAAN6B,EAAaZ,OAAOkG,OAAOtF,IAAMoF,EAAGjH,UAAY6B,EAAE7B,UAAW,IAAIiH,GAG5E,IAAIG,EAAW,WAQlB,OAPAA,EAAWnG,OAAOoG,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGhC,EAAI,EAAGiC,EAAIhH,UAAUkB,OAAQ6D,EAAIiC,EAAGjC,IAE5C,IAAK,IAAIwB,KADTQ,EAAI/G,UAAU+E,GACOtE,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,KAAIO,EAAEP,GAAKQ,EAAER,IAE9E,OAAOO,IAEK/G,MAAMe,KAAMd,Y,oBCrC1B,mBAAE,IAAAU,SAAU,IAAAC,eACZ0Q,EAAsB,IAAItJ,IAKhC,SAAgB9E,EAAM7B,EAAQC,GAC5B,IACE,OASJ,SAASF,EAAMC,EAAQC,GAErB,GAAID,IAAMC,EACR,OAAO,EAKT,IAAME,EAAO,EAASC,KAAKJ,GACrBK,EAAO,EAASD,KAAKH,GAK3B,GAAIE,IAASE,EACX,OAAO,EAGT,OAAQF,GACN,IAAK,iBAGH,GAAIH,EAAEF,SAAWG,EAAEH,OAAQ,OAAO,EAEpC,IAAK,kBACH,GAAIoQ,EAAmBlQ,EAAGC,GAAI,OAAO,EAErC,IAAMM,EAAQlB,OAAOmB,KAAKR,GACpBS,EAAQpB,OAAOmB,KAAKP,GAIpBkQ,EAAW5P,EAAMT,OACvB,GAAIqQ,IAAa1P,EAAMX,OAAQ,OAAO,EAGtC,IAAK,IAAImM,EAAI,EAAGA,EAAIkE,IAAYlE,EAC9B,IAAK,EAAe7L,KAAKH,EAAGM,EAAM0L,IAChC,OAAO,EAKX,IAASA,EAAI,EAAGA,EAAIkE,IAAYlE,EAAG,CACjC,IAAMtL,EAAMJ,EAAM0L,GAClB,IAAKlM,EAAMC,EAAEW,GAAMV,EAAEU,IACnB,OAAO,EAIX,OAAO,EAGT,IAAK,iBACH,OAAOX,EAAE9B,OAAS+B,EAAE/B,MAAQ8B,EAAEjC,UAAYkC,EAAElC,QAE9C,IAAK,kBAEH,GAAIiC,IAAMA,EAAG,OAAOC,IAAMA,EAE5B,IAAK,mBACL,IAAK,gBACH,OAAQD,KAAOC,EAEjB,IAAK,kBACL,IAAK,kBACH,OAAOD,GAAK,GAAGC,EAEjB,IAAK,eACL,IAAK,eACH,GAAID,EAAEY,OAASX,EAAEW,KAAM,OAAO,EAC9B,GAAIsP,EAAmBlQ,EAAGC,GAAI,OAAO,EAKrC,IAHA,IAAMY,EAAYb,EAAEc,UACdsP,EAAiB,iBAATjQ,IAED,CACX,IAAMY,EAAOF,EAAUG,OACvB,GAAID,EAAKE,KAAM,MAGT,cAACE,EAAA,KAAMC,EAAA,KAGb,IAAKnB,EAAEoB,IAAIF,GACT,OAAO,EAKT,GAAIiP,IAAUrQ,EAAMqB,EAAQnB,EAAEqB,IAAIH,IAChC,OAAO,EAIX,OAAO,EAKX,OAAO,EA7GEpB,CAAMC,EAAGC,GADlB,QAGEgQ,EAAoBI,SA8GxB,SAASH,EAAmBlQ,EAAWC,GASrC,IAAIqQ,EAAOL,EAAoB3O,IAAItB,GACnC,GAAIsQ,GAGF,GAAIA,EAAKjP,IAAIpB,GAAI,OAAO,OAExBgQ,EAAoBM,IAAIvQ,EAAGsQ,EAAO,IAAIE,KAGxC,OADAF,EAAKG,IAAIxQ,IACF,E,iFC7HT,iBAUE,WAAYyQ,EAAmClK,GATxC,KAAAmK,WAAqB,EACrB,KAAAC,gBAA2C,GAG3C,KAAApK,QAA8B,GAG7B,KAAAkK,QAAmC,GAGzChR,KAAKgR,QAAUA,GAAY,GAC3BhR,KAAK8G,QAAUA,GAAW,GA2D9B,OAxDS,YAAAqK,WAAP,WACE,OAAOnR,KAAKgR,SAGP,YAAAI,WAAP,SACEC,EACAC,QAAA,IAAAA,OAAA,GAEIA,IAAkBC,EAAQvR,KAAKgR,QAASK,KAC1CrR,KAAKkR,gBAAkBlR,KAAKgR,SAE9BhR,KAAKgR,QAAUK,GAOP,YAAAG,QAAV,WACExR,KAAKiR,WAAY,GAGT,YAAAQ,cAAV,WACE,IAAM9K,EACH3G,KAAKgR,SAAWhR,KAAKgR,QAAQrK,QAC7B3G,KAAK8G,SAAW9G,KAAK8G,QAAQH,OAI9B,mBAKF,IAAI+K,GAAQ,EAMZ,OALI/K,IAAW3G,KAAK2G,SAClB+K,GAAQ,EACR1R,KAAK2G,OAASA,EACd3G,KAAK2R,WAEA,CACLhL,OAAQ3G,KAAK2G,OACb+K,MAAK,IAIC,YAAAE,mBAAV,SAA6BpK,EAAwBL,GACnD,IAAMc,EAAY,YAAOT,GACK,YAAcL,GAClB,YAAcc,EAAUd,MAEtC,YACG,eAInB,EAvEA,GCaA,cAQE,WAAY,G,IACV6J,EAAA,EAAAA,QACAlK,EAAA,EAAAA,QACA+K,EAAA,EAAAA,YAHF,EASE,YAAMb,EAASlK,IAAQ,K,OAhBjB,EAAAgL,aAAqD,GACrD,EAAAC,kBAA+D,GAG/D,EAAAC,SAAmB,EAyGnB,EAAAC,aAAe,SAACjB,GACtB,EAAKW,UAEL,EAAKK,SAAU,EACf,EAAKE,YAAclB,EACnB,EAAKa,eAGC,EAAAM,iBAAmB,WACzB,IAAMrF,EAAS,EAAKsF,iBAEpB,OADA,EAAKC,yBACEvF,GAoSD,EAAAwF,WAAa,SAAC7K,GACpB,SAAKsK,kBAAkBQ,MAAOC,QAAQ/K,IAEhC,EAAAgL,aAAe,SACrBC,GAEG,SAAKX,kBAAkBQ,MAAOI,UAAUD,IAErC,EAAAE,eAAiB,SACvBC,GAIG,SAAKd,kBAAkBQ,MAAOO,YAAYD,IAEvC,EAAAE,gBAAkB,SAACC,GACzB,EAAKjB,mBACH,EAAKA,kBAAkBQ,OACvB,EAAKR,kBAAkBQ,MAAOU,aAAaD,IAGvC,EAAAE,eAAiB,WACvB,EAAKnB,mBACH,EAAKA,kBAAkBQ,OACvB,EAAKR,kBAAkBQ,MAAOY,eAG1B,EAAAC,mBAAqB,SAI3BpC,GAKG,SAAKe,kBAAkBQ,MAAOc,gBAAgBrC,IA/ajD,EAAKa,YAAcA,E,EA6bvB,OA/ckD,OAqBzC,YAAAyB,QAAP,WACEtT,KAAKyR,gBAEC,wBAAE8B,EAAA,EAAAA,KAAMhB,EAAA,EAAAA,MAUd,OATIgB,GAAQhB,IAAUvS,KAAK8R,aAAaS,SACtCvS,KAAKwT,0BACLxT,KAAK8R,aAAaS,MAAQA,GAG5BvS,KAAKyT,wBAEDzT,KAAKiR,WAAWjR,KAAKqS,yBAElBrS,KAAK0T,uBAAyB1T,KAAKmS,oBAGrC,YAAAwB,YAAP,WACE,OAAQ3T,KAAKgS,QAUT,CAAChS,KAAKiS,aAAcjS,KAAKsT,WATzB,CACEtT,KAAKiS,aACL,CACE2B,SAAS,EACTC,cAAe,IAAcC,MAC7BC,QAAQ,EACRC,UAAM1I,KAOT,YAAA2I,UAAP,WACE,IAAMjD,EAAUhR,KAAKmR,aACrB,GAAIH,EAAQuC,OAAwB,IAAhBvC,EAAQkD,IAAe,OAAO,EAGlD,IAAMC,EAAMnU,KAAK+R,kBAAkBQ,MAEnC,QADsB4B,EAAIC,mBACLR,SAAUO,EAAIrH,UAG9B,YAAAuH,aAAP,SAAoB,GAApB,WAAsB,oBAAAC,YAAA,IAAO,GAAP,EAiBpB,OAhBAtU,KAAKiR,WAAY,EAEZqD,IAAQtU,KAAKgS,UAChBhS,KAAKuU,yBAML3R,YAAW,WACT,EAAKmP,kBAAkBQ,OACrB,EAAKR,kBAAkBQ,MAAMiC,4BAInCxU,KAAKkR,gBAAkBlR,KAAKmR,aACrBnR,KAAKwR,QAAQiD,KAAKzU,OAGpB,YAAA2R,QAAP,WACE3R,KAAKwT,iCACExT,KAAK+R,kBAAkBQ,aACvBvS,KAAK8R,aAAahF,QAGpB,YAAAqE,WAAP,WACE,IAAMH,EAAU,YAAMG,WAAU,WAkBhC,OAhBInR,KAAKkS,cACPlB,EAAQvJ,UAAS,OACZuJ,EAAQvJ,WACRzH,KAAKkS,YAAYzK,WAEtBuJ,EAAQlK,QAAO,OACVkK,EAAQlK,SACR9G,KAAKkS,YAAYpL,UAKpB9G,KAAKgS,gBACAhB,EAAQuC,KAGVvC,GAiBD,YAAA0C,oBAAR,WACE,IAiBI5G,EAjBE4H,EAAyB1U,KAAK8G,SAAW9G,KAAK8G,QAAQ6N,eACtDC,GAAwC,IAA1B5U,KAAKmR,aAAa+C,IAChCW,EAAgB7U,KAAKyR,gBAAgB9K,OAAOmO,sBAE5CC,EAAa,CACjBnB,SAAS,EACTC,cAAe,IAAcD,QAC7BG,QAAQ,EACRC,UAAM1I,GAKR,OAAIsJ,IAAgBF,GAA0BG,GACrCE,GAILL,IACF5H,EACE9M,KAAK8G,QAAQ6N,eAAgBK,gBAC3BhV,KACAA,KAAKmS,mBACF4C,GAGFjI,IAGD,YAAAmI,8BAAR,WACE,IAAMjE,EAAUhR,KAAKmR,aACrBnR,KAAK4R,mBAAmBZ,EAAQuB,MAAO,IAAanL,OACpD,IAAM8N,EAAclE,EAAQkE,aAAe,QAa3C,OARElV,KAAK8G,SACL9G,KAAK8G,QAAQ6N,iBACY,iBAAxB3D,EAAQmE,aACiB,sBAAxBnE,EAAQmE,eAEVnE,EAAQmE,YAAc,eAGxB,OACKnE,GAAO,CACVkE,YAAW,EACXpO,QAASkK,EAAQlK,QACjBsO,SAAU,CAAEC,eAAgB,CAAEH,YAAW,OAIrC,YAAAI,0BAAR,WAUE,GANItV,KAAK8G,SAAW9G,KAAK8G,QAAQ6N,iBAC/B3U,KAAK+R,kBAAkBQ,MAAQvS,KAAK8G,QAAQ6N,eAAeY,iBACzDvV,KAAKmR,gBAIJnR,KAAK+R,kBAAkBQ,MAAO,CACjC,IAAMiD,EAAyBxV,KAAKiV,gCAEpCjV,KAAK8R,aAAa0D,uBAAsB,OACnCA,GAAsB,CACzB5O,SAAU,OAEZ5G,KAAK+R,kBAAkBQ,MAAQvS,KAAKyR,gBAAgB9K,OAAO8O,WAAU,KAChED,IAGDxV,KAAK8G,SAAW9G,KAAK8G,QAAQ6N,gBAC/B3U,KAAK8G,QAAQ6N,eAAee,sBAC1B1V,KAAK+R,kBAAkBQ,MACvBiD,KAMA,YAAA/B,sBAAR,WAEE,GAAKzT,KAAK+R,kBAAkBQ,MAA5B,CAKA,IAAMoD,EAA4B,EAAH,KAC1B3V,KAAKiV,iCAA+B,CACvCrO,SAAU,OAIT2K,EACCoE,EACA3V,KAAK8R,aAAa0D,0BAGpBxV,KAAK8R,aAAa0D,uBAAyBG,EAC3C3V,KAAK+R,kBACFQ,MAAOnB,WAAWuE,GAKlBC,OAAM,qBAtBT5V,KAAKsV,6BA0BD,YAAAjD,uBAAR,sBACE,IAAIrS,KAAK+R,kBAAkB8D,eAAgB7V,KAAKmR,aAAaoC,KAA7D,CAEA,IAAMuC,EAAW9V,KAAK+R,kBAAkBQ,MACxCvS,KAAK+R,kBAAkB8D,aAAeC,EAASC,UAAU,CACvDzU,KAAM,SAAC,G,IAAEsS,EAAA,EAAAA,QAASC,EAAA,EAAAA,cAAeG,EAAA,EAAAA,KACzBgC,EAAiB,EAAKlE,aAAahF,OAIvCkJ,GACAA,EAAepC,UAAYA,GAC3BoC,EAAenC,gBAAkBA,GACjCtC,EAAQyE,EAAehC,KAAMA,IAK/B,EAAKnC,eAEPzS,MAAO,YAEL,GADA,EAAK6W,sBACA,EAAMpW,eAAe,iBAAkB,MAAM,EAElD,IAAMmW,EAAiB,EAAKlE,aAAahF,QAEtCkJ,GAAkBA,EAAepC,UACjCrC,EAAQ,EAAO,EAAKO,aAAa1S,UAElC,EAAK0S,aAAa1S,MAAQ,EAC1B,EAAKyS,oBAML,YAAAoE,mBAAR,WACEjW,KAAKwT,0BASL,IAAM0C,EAAYlW,KAAK+R,kBAAkBQ,MAAO4D,eAC1CC,EAAapW,KAAK+R,kBAAkBQ,MAAO8D,gBACjDrW,KAAK+R,kBAAkBQ,MAAO+D,mBAC9BtW,KAAKqS,yBACL1S,OAAOoG,OAAO/F,KAAK+R,kBAAkBQ,MAAQ,CAC3C2D,UAAS,EACTE,WAAU,KAIN,YAAAhE,eAAR,WACE,IAAItF,EAAc9M,KAAKuW,wBACjBvF,EAAUhR,KAAKmR,aAKrB,GAAIH,EAAQuC,KACVzG,EAAS,EAAH,KACDA,GAAM,CACTkH,UAAM1I,EACNlM,WAAOkM,EACPsI,SAAS,EACTG,QAAQ,QAEL,CAEL,IAAMyC,EAAgBxW,KAAK+R,kBAAkBQ,MAAO6B,mBAC5CR,EAAA,EAAAA,QAAS6C,EAAA,EAAAA,QAAS5C,EAAA,EAAAA,cAAe6C,EAAA,EAAAA,OACnCtX,EAAA,EAAAA,MAAO4U,EAAA,EAAAA,KAgBb,GAZI0C,GAAUA,EAAOtW,OAAS,IAC5BhB,EAAQ,IAAI,IAAY,CAAEuX,cAAeD,KAG3C5J,EAAS,EAAH,KACDA,GAAM,CACT8G,QAAO,EACPC,cAAa,EACbzU,MAAK,EACL2U,QAAQ,IAGNH,EAAS,CACX,IAAM9B,EACJ9R,KAAK8R,aAAahF,QAAU9M,KAAK8R,aAAahF,OAAOkH,KACvDlH,EAAOkH,KACLlC,GAAgBkC,E,OAEPlC,GACAkC,GAELlC,GAAgBkC,OACjB,GAAI5U,EACTO,OAAOoG,OAAO+G,EAAQ,CACpBkH,MAAOhU,KAAK+R,kBAAkBQ,MAAO8D,iBAAoB,IACtDrC,WAEA,CACG,IAAAmB,EAAA,qCAAAA,YAER,GADQ,EAAAyB,iBAGL5C,GACDyC,GACgB,eAAhBtB,EAeA,OALAxV,OAAOoG,OAAO+G,EAAQ,CACpB8G,SAAS,EACTC,cAAe,IAAcD,UAE/B9G,EAAO0F,UACA1F,EAGTA,EAAOkH,KAAOA,GAQlB,OAJAlH,EAAOnG,OAAS3G,KAAK2G,OACrB3G,KAAK8R,aAAa8B,QACf5T,KAAK8R,aAAahF,QAAU9M,KAAK8R,aAAahF,OAAO8G,UAAY,EACpE5T,KAAK8R,aAAahF,OAASA,EACpBA,GAGD,YAAAyH,uBAAR,WACE,IAAMuB,EAAW9V,KAAK+R,kBAAkBQ,MACxC,GAAKuD,EAAL,CAEM,2BAAE9B,EAAA,EAAAA,KAAMJ,EAAA,EAAAA,QAASxU,EAAA,EAAAA,MAEvB,IAAKwU,EAAS,CACN,wBAAErB,EAAA,EAAAA,MAAO9K,EAAA,EAAAA,UAAWoP,EAAA,EAAAA,YAAaC,EAAA,EAAAA,QAGvC,GACE9W,KAAKkR,kBACJlR,KAAK8R,aAAa8B,SACnBrC,EAAQvR,KAAKkR,gBAAgBqB,MAAOA,IACpChB,EAAQvR,KAAKkR,gBAAgBzJ,UAAWA,GAExC,OAGEoP,IAAgBzX,EAClByX,EAAY7C,GACH8C,GAAW1X,GACpB0X,EAAQ1X,MAKN,YAAAoU,wBAAR,WACMxT,KAAK+R,kBAAkB8D,eACzB7V,KAAK+R,kBAAkB8D,aAAakB,qBAC7B/W,KAAK+R,kBAAkB8D,eA0C1B,YAAAU,sBAAR,WAEE,MAAO,CACL9O,UAFiBzH,KAAK+R,kBAAkBQ,MAElB9K,UACtB+K,QAASxS,KAAKsS,WACdK,UAAW3S,KAAKyS,aAChBK,YAAa9S,KAAK4S,eAClBK,aAAcjT,KAAK+S,gBACnBI,YAAanT,KAAKkT,eAClBG,gBAAiBrT,KAAKoT,qBAG5B,EA/cA,CAAkD,G,SCdlC4D,EACdzE,EACAvB,EACAsD,QAAA,IAAAA,OAAA,GAEA,IAAMxN,EAAU,qBAAW,eACrB,oDAACmQ,EAAA,KAAMpF,EAAA,KACPqF,EAAiBlG,EAAU,EAAH,KAAQA,GAAO,CAAEuB,MAAK,IAAK,CAAEA,MAAK,GAE1D4E,EAAe,mBAEhBA,EAAaC,UAChBD,EAAaC,QAAU,IAAI,EAA6B,CACtDpG,QAASkG,EACTpQ,QAAO,EACP+K,YAAW,KAIf,IAAMwF,EAAYF,EAAaC,QAC/BC,EAAUjG,WAAW8F,GACrBG,EAAUvQ,QAAUA,EAKpB,IAMMgG,E,SCjCNwK,EACArW,GAEA,IAAMsW,EAAM,mBAMZ,OAJKA,EAAIH,SAAY7F,EAAQtQ,EAAKsW,EAAIH,QAAQnW,OAC5CsW,EAAIH,QAAU,CAAEnW,IAAG,EAAEO,MAAO8V,MAGvBC,EAAIH,QAAQ5V,MDwBJgW,EACb,WAAM,OAAClD,EAAO+C,EAAU1D,cAAgB0D,EAAU/D,YAPvC,CACXtC,QAAS,EAAF,KAAOkG,GAAc,CAAEJ,aAASxL,EAAWuL,iBAAavL,IAC/DxE,QAAO,EACPmQ,KAAI,IAQAQ,EAAcnD,EACfxH,EAAyC,GACzCA,EAaL,OAXA,qBAAU,WAAM,OAAAuK,EAAUhD,aAAa,CAAEC,KAAI,MAAK,CAChDmD,EAAY7D,QACZ6D,EAAY5D,cACZ4D,EAAYrY,MACZqY,EAAYzD,OAGd,qBAAU,WACR,OAAO,WAAM,OAAAqD,EAAU1F,aACtB,IAEI7E,E,SE1DO4K,EACdnF,EACAvB,GAEA,OAAOgG,EAAgCzE,EAAOvB,GAAS,GCIzD,kBASE,WAAY,G,IACVA,EAAA,EAAAA,QACAlK,EAAA,EAAAA,QACAgG,EAAA,EAAAA,OACA6K,EAAA,EAAAA,UAJF,EAWE,YAAM3G,EAASlK,IAAQ,K,OAuBjB,EAAA8Q,YAAc,SACpBC,QAAA,IAAAA,MAGI,IAEJ,EAAKC,kBACL,IAAMC,EAAa,EAAKC,wBAExB,OAAO,EAAKC,OAAOJ,GAChBK,MAAK,SAACC,GAEL,OADA,EAAKC,oBAAoBD,EAAUJ,GAC5BI,KAERvC,OAAM,SAACxW,GAEN,GADA,EAAKiZ,gBAAgBjZ,EAAO2Y,IACvB,EAAK5G,aAAa2F,QAAS,MAAM1X,MAtC1C,EAAKwS,mBAAmBZ,EAAQsH,SAAU,IAAajR,UACvD,EAAKyF,OAASA,EACd,EAAK6K,UAAYA,EACjB,EAAKY,qBAAuB,E,EAiJhC,OAtKU,OAwBD,YAAAjF,QAAP,SAAexG,GAIb,OAHA9M,KAAKiR,WAAY,EACjBjR,KAAK4R,mBAAmB5R,KAAKmR,aAAamH,SAAU,IAAajR,UACjEyF,EAAOnG,OAAS3G,KAAKyR,gBAAgB9K,OAC9B,CAAC3G,KAAK4X,YAAa9K,IAGrB,YAAAuH,aAAP,WAEE,OADArU,KAAKiR,WAAY,EACVjR,KAAKwR,QAAQiD,KAAKzU,OAGpB,YAAA2R,QAAP,aAwBQ,YAAAsG,OAAR,SACEJ,GAEM,wBACJS,EAAA,EAAAA,SACA7Q,EAAA,EAAAA,UACA+Q,EAAA,EAAAA,mBACAC,EAAA,EAAAA,OACA,IAAA3R,QAAA,kBACA,IAAA4R,2BAAA,IAAsB,GAAtB,EACAvD,EAAA,EAAAA,YAEIwD,EAAgB,EAAH,GAAQd,GAErBe,EAAkBjZ,OAAOoG,OAC7B,GACA0B,EACAkR,EAAclR,WAIhB,cAFOkR,EAAclR,UAEdzH,KAAKyR,gBAAgB9K,OAAOsR,OAAM,GACvCK,SAAQ,EACRE,mBAAkB,EAClBK,eACEF,EAAcE,gBAAkB7Y,KAAKmR,aAAa0H,eACpDH,oBAAmB,EACnBD,OAAM,EACN3R,QAASgS,EACT3D,YAAW,EACX1N,UAAWmR,GACRD,KAIC,YAAAb,gBAAR,WACO9X,KAAK8M,OAAO8G,SAAY5T,KAAKmR,aAAa4H,eAC7C/Y,KAAKgZ,aAAa,CAChBpF,SAAS,EACTxU,WAAOkM,EACP0I,UAAM1I,EACNyI,QAAQ,KAKN,YAAAqE,oBAAR,SACED,EACAJ,GAEM,wBAAElB,EAAA,EAAAA,YAAakC,EAAA,EAAAA,cAEb/E,EAAA,EAAAA,KAAM0C,EAAA,EAAAA,OACRtX,EACJsX,GAAUA,EAAOtW,OAAS,EACtB,IAAI,IAAY,CAAEuW,cAAeD,SACjCpL,EAKFtL,KAAKiZ,qBAAqBlB,KAAgBgB,GAC5C/Y,KAAKgZ,aAAa,CAChBjF,QAAQ,EACRH,SAAS,EACTI,KAAI,EACJ5U,MAAK,IAPPyX,GAAcA,EAAY7C,IAatB,YAAAqE,gBAAR,SAAwBjZ,EAAoB2Y,GAClC,IAAAjB,EAAA,kBAAAA,QAEJ9W,KAAKiZ,qBAAqBlB,IAC5B/X,KAAKgZ,aAAa,CAChBpF,SAAS,EACTxU,MAAK,EACL4U,UAAM1I,EACNyI,QAAQ,IAIR+C,GACFA,EAAQ1X,IAIJ,YAAA4Y,sBAAR,WACE,QAAShY,KAAKuY,sBAGR,YAAAU,qBAAR,SAA6BlB,GAC3B,OAAO/X,KAAKuY,uBAAyBR,GAG/B,YAAAiB,aAAR,SAAqBlM,IAEjB9M,KAAKiR,WACHjR,KAAKgW,gBAAmBzE,EAAQvR,KAAKgW,eAAgBlJ,KAEvD9M,KAAK2X,UAAU7K,GACf9M,KAAKgW,eAAiBlJ,IAG5B,EAzKA,CAGU,G,SCVMoM,EACdZ,EACAtH,GAEA,IAAMlK,EAAU,qBAAW,eACrB,6CAACgG,EAAA,KAAQ6K,EAAA,KACTT,EAAiBlG,EAAU,EAAH,KAAQA,GAAO,CAAEsH,SAAQ,IAAK,CAAEA,SAAQ,GAEhEa,EAAkB,mBAaxB,IAAMC,GAXCD,EAAgB/B,UACnB+B,EAAgB/B,QAAU,IAAI,EAAgC,CAC5DpG,QAASkG,EACTpQ,QAAO,EACPgG,OAAM,EACN6K,UAAS,KAGNwB,EAAgB/B,SASzB,OALAgC,EAAahI,WAAW8F,GACxBkC,EAAatS,QAAUA,EAEvB,qBAAU,WAAM,OAAAsS,EAAa/E,kBAEtB+E,EAAa9F,QAAQxG,IC5B9B,YAOE,WAAY,G,IACVkE,EAAA,EAAAA,QACAlK,EAAA,EAAAA,QACA6Q,EAAA,EAAAA,UAHF,EASE,YAAM3G,EAASlK,IAAQ,K,OAXjB,EAAAiL,kBAAmD,GAYzD,EAAK4F,UAAYA,EACjB,EAAK0B,WAAWrI,G,EAfV,OAkBD,YAAAsC,QAAP,SAAexG,GACb,IAA+B,IAA3B9M,KAAKmR,aAAaoC,KAEpB,OADAvT,KAAK2R,UACE,CACLiC,SAAS,EACTxU,WAAOkM,EACP0I,UAAM1I,EACN7D,UAAWzH,KAAKmR,aAAa1J,WAIjC,IAAI+O,EAAgB1J,EAChB9M,KAAKyR,gBAAgBC,QACvB8E,EAAgBxW,KAAKsZ,oBAGjB,IAAAC,EAAA,kBAAAA,kBAqBN,MApBiC,oBAAtBA,IACTA,IAAsBA,EAAkBvZ,KAAKmR,gBAIvB,IAAtBoI,GACAvZ,KAAKkR,iBACLvR,OAAOmB,KAAKd,KAAKkR,iBAAiB9Q,OAAS,IAC1CJ,KAAKkR,gBAAgB2E,eAAiB7V,KAAKmR,aAAa0E,eACtDtE,EAAQvR,KAAKkR,gBAAgBzJ,UAAWzH,KAAKmR,aAAa1J,YAC3DzH,KAAKkR,gBAAgBqC,OAASvT,KAAKmR,aAAaoC,QAElDvT,KAAK2R,UACL6E,EAAgBxW,KAAKsZ,oBAGvBtZ,KAAKqZ,WAAWrZ,KAAKmR,cACrBnR,KAAKwZ,oBAELxZ,KAAKkR,gBAAkBlR,KAAKmR,aAC5B,OAAYqF,GAAa,CAAE/O,UAAWzH,KAAKmR,aAAa1J,aAGnD,YAAA4M,aAAP,WACErU,KAAKiR,WAAY,GAGZ,YAAAU,QAAP,WACE3R,KAAKyZ,yBACEzZ,KAAK+R,kBAAkBQ,OAGxB,YAAA8G,WAAR,SAAmBrI,GACbhR,KAAK+R,kBAAkBQ,QAAoC,IAA3BvS,KAAKmR,aAAaoC,OACtDvT,KAAK+R,kBAAkBQ,MAAQvS,KAAKyR,gBAAgB9K,OAAOoP,UAAU,CACnExD,MAAOvB,EAAQ6E,aACfpO,UAAWuJ,EAAQvJ,UACnB0N,YAAanE,EAAQmE,gBAIjB,YAAAqE,kBAAR,WACMxZ,KAAK+R,kBAAkB8D,eAC3B7V,KAAK+R,kBAAkB8D,aAAe7V,KAAK+R,kBAAkBQ,MAAOwD,UAClE,CACEzU,KAAMtB,KAAK0Z,kBAAkBjF,KAAKzU,MAClCZ,MAAOY,KAAK2Z,YAAYlF,KAAKzU,MAC7B4Z,SAAU5Z,KAAK6Z,qBAAqBpF,KAAKzU,UAKvC,YAAAsZ,iBAAR,WACE,MAAO,CACL1F,SAAS,EACTxU,WAAOkM,EACP0I,UAAM1I,IAIF,YAAA0N,aAAR,SAAqBlM,GACf9M,KAAKiR,WACPjR,KAAK2X,UAAU7K,IAIX,YAAA4M,kBAAR,SAA0B5M,GAChB,IAAAgN,EAAA,kBAAAA,mBAER9Z,KAAKgZ,aAAa,CAChBhF,KAAMlH,EAAOkH,KACbJ,SAAS,EACTxU,WAAOkM,IAGLwO,GACFA,EAAmB,CACjBnT,OAAQ3G,KAAKyR,gBAAgB9K,OAC7BoT,iBAAkBjN,KAKhB,YAAA6M,YAAR,SAAoBva,GAClBY,KAAKgZ,aAAa,CAChB5Z,MAAK,EACLwU,SAAS,KAIL,YAAAiG,qBAAR,WACU,IAAAG,EAAA,kBAAAA,uBACJA,GAAwBA,IAC5Bha,KAAKyZ,mBAGC,YAAAA,gBAAR,WACMzZ,KAAK+R,kBAAkB8D,eACzB7V,KAAK+R,kBAAkB8D,aAAakB,qBAC7B/W,KAAK+R,kBAAkB8D,eAzIpC,CAGU,ICQV,wBAEU,KAAAoE,cAAgB,IAAIhT,IAMpB,KAAAiT,cAAgB,IAAIjT,IAGrB,YAAAyO,sBAAP,SACEyE,EACAC,GAEApa,KAAKqa,gBAAgBD,GAAOD,WAAaA,GAIpC,YAAA5E,iBAAP,SACE6E,GAEA,OAAOpa,KAAKqa,gBAAgBD,GAAOD,YAG9B,YAAAnF,gBAAP,SACEsF,EACAC,GAGA,OADava,KAAKqa,gBAAgBC,EAAcnJ,cACtCqJ,KAWHD,KAVLva,KAAKia,cAAcpJ,IACjByJ,EAAcnJ,aACd,IAAIsJ,SAAQ,SAAAC,GACVA,EAAQJ,EAAcrG,iBAKnB,OAKJ,YAAA0G,YAAP,WACE,OAAO3a,KAAKia,cAAc/Y,KAAO,GAG5B,YAAA0Z,wBAAP,sBACQC,EAA2B,GAejC,OAdA7a,KAAKia,cAAca,SAAQ,SAACC,EAAST,GAUnC,EAAKD,gBAAgBC,GAAeE,MAAO,EAC3CK,EAAS5Y,KAAK8Y,MAEhB/a,KAAKia,cAActJ,QACZ8J,QAAQO,IAAIH,IAGb,YAAAR,gBAAR,SACED,GAEQ,IAAAF,EAAA,KAAAA,cACA3H,EAAA,EAAAA,MAAO9K,EAAA,EAAAA,UACTwT,EAASf,EAActY,IAAI2Q,IAAU,IAAItL,IAC1CiT,EAAcvY,IAAI4Q,IAAQ2H,EAAcrJ,IAAI0B,EAAO0I,GACxD,IAAMC,EAAkBC,KAAKC,UAAU3T,GACjCpG,EAAO4Z,EAAOrZ,IAAIsZ,IAjFnB,CACLV,MAAM,EACNL,WAAY,MAiFZ,OADKc,EAAOtZ,IAAIuZ,IAAkBD,EAAOpK,IAAIqK,EAAiB7Z,GACvDA,GA7EX,I,iCCfAiB,EAAOC,QAAU,SAAUyR,EAAMqH,GACxBA,IAAMA,EAAO,IACE,oBAATA,IAAqBA,EAAO,CAAEC,IAAKD,IAC9C,IAEiCE,EAF7BC,EAAiC,mBAAhBH,EAAKG,QAAwBH,EAAKG,OAEnDF,EAAMD,EAAKC,MAAkBC,EAQ9BF,EAAKC,IAPG,SAAU1P,GACb,OAAO,SAAUtL,EAAGC,GAChB,IAAIkb,EAAO,CAAExa,IAAKX,EAAGkB,MAAOoK,EAAKtL,IAC7Bob,EAAO,CAAEza,IAAKV,EAAGiB,MAAOoK,EAAKrL,IACjC,OAAOgb,EAAEE,EAAMC,MAKvBlB,EAAO,GACX,OAAQ,SAASY,EAAWxP,GAKxB,GAJIA,GAAQA,EAAK+P,QAAiC,oBAAhB/P,EAAK+P,SACnC/P,EAAOA,EAAK+P,eAGHrQ,IAATM,EAAJ,CACA,GAAmB,iBAARA,EAAkB,OAAOgQ,SAAShQ,GAAQ,GAAKA,EAAO,OACjE,GAAoB,kBAATA,EAAmB,OAAOuP,KAAKC,UAAUxP,GAEpD,IAAI3H,EAAG4X,EACP,GAAI7X,MAAMyH,QAAQG,GAAO,CAErB,IADAiQ,EAAM,IACD5X,EAAI,EAAGA,EAAI2H,EAAKxL,OAAQ6D,IACrBA,IAAG4X,GAAO,KACdA,GAAOT,EAAUxP,EAAK3H,KAAO,OAEjC,OAAO4X,EAAM,IAGjB,GAAa,OAATjQ,EAAe,MAAO,OAE1B,IAA4B,IAAxB4O,EAAKpU,QAAQwF,GAAc,CAC3B,GAAI4P,EAAQ,OAAOL,KAAKC,UAAU,aAClC,MAAM,IAAIU,UAAU,yCAGxB,IAAIC,EAAYvB,EAAKvY,KAAK2J,GAAQ,EAC9B9K,EAAOnB,OAAOmB,KAAK8K,GAAMoQ,KAAKV,GAAOA,EAAI1P,IAE7C,IADAiQ,EAAM,GACD5X,EAAI,EAAGA,EAAInD,EAAKV,OAAQ6D,IAAK,CAC9B,IAAIhD,EAAMH,EAAKmD,GACXzC,EAAQ4Z,EAAUxP,EAAK3K,IAEtBO,IACDqa,IAAKA,GAAO,KAChBA,GAAOV,KAAKC,UAAUna,GAAO,IAAMO,GAGvC,OADAgZ,EAAK5N,OAAOmP,EAAW,GAChB,IAAMF,EAAM,KAtCf,CAuCL7H,K,gLC/BP,YAEE,WAAY3V,EAAkB4d,GAA9B,MACE,YAAM5d,IAAQ,K,OACd,EAAK4d,KAAOA,E,EAJe,iBAA/B,CAA+Btd,O,SAQfud,EAAcD,GAC5B,OAAOA,EAAKE,QAAQ/b,QAAU,EAoChC,SAAgBgc,EAAaC,GAC3B,OAAO,IAAI,KAAc,SAAAC,GACvBA,EAASld,MAAMid,MAuBnB,SAAgBE,EACdC,EACAvU,GAEA,IAAInB,EAAU,OAAH,IAAG,CAAH,GAAQ0V,GAyBnB,OAfA7c,OAAO8c,eAAexU,EAAW,aAAc,CAC7CyU,YAAY,EACZlb,MAXiB,SAAAF,GAEfwF,EADkB,oBAATxF,EACC,OAAH,IAAG,CAAH,GAAQwF,EAAYxF,EAAKwF,IAEtB,OAAH,IAAG,CAAH,GAAQA,EAAYxF,MAU/B3B,OAAO8c,eAAexU,EAAW,aAAc,CAC7CyU,YAAY,EACZlb,MATiB,WAAM,sBAAMsF,MAY/BnH,OAAO8c,eAAexU,EAAW,QAAS,CACxCyU,YAAY,EACZlb,MAAO,WAAM,OAMjB,SAAuByG,GAGb,IAAAsK,EAAA,EAAAA,MAAO9K,EAAA,EAAAA,UAAWP,EAAAe,EAAAf,cAC1B,OAAOiU,KAAKC,UAAU,CAAClU,EAAeqL,EAAO9K,IAV9BkV,CAAO1U,MAGfA,EC1GT,SAAS2U,EAAYC,EAAIC,GACvB,OAAOA,EAAUA,EAAQD,GAAM,IAAWE,KAG5C,SAASC,EAAOC,GACd,MAA0B,oBAAZA,EAAyB,IAAIC,EAAWD,GAAWA,EAGnE,SAAgBE,IACd,OAAO,IAAID,GAAW,WAAM,WAAWH,QAGzC,SAAgBK,EAAKC,GACnB,OAAqB,IAAjBA,EAAMjd,OAAqB+c,IACxBE,EAAMrO,IAAIgO,GAAQM,QAAO,SAACxV,EAAGyV,GAAM,OAAAzV,EAAE1E,OAAOma,MAGrD,SAAgBC,EACdC,EACAC,EACAC,GAEA,IAAMC,EAAWZ,EAAOU,GAClBG,EAAYb,EAAOW,GAAS,IAAIT,EAAWN,IAEjD,OAAIV,EAAc0B,IAAa1B,EAAc2B,GACpC,IAAIX,GAAW,SAAAjV,GACpB,OAAOwV,EAAKxV,GACR2V,EAASzB,QAAQlU,IAAc,IAAW8U,KAC1Cc,EAAU1B,QAAQlU,IAAc,IAAW8U,QAG1C,IAAIG,GAAW,SAACjV,EAAW6U,GAChC,OAAOW,EAAKxV,GACR2V,EAASzB,QAAQlU,EAAW6U,IAAY,IAAWC,KACnDc,EAAU1B,QAAQlU,EAAW6U,IAAY,IAAWC,QAM9D,IAAa3Z,EAAS,SACpB0a,EACAC,GAEA,IAAMC,EAAYhB,EAAOc,GACzB,GAAI5B,EAAc8B,GAOhB,OAAOA,EAET,IAAMC,EAAWjB,EAAOe,GAExB,OAAI7B,EAAc+B,GACT,IAAIf,GACT,SAAAjV,GACE,OAAA+V,EAAU7B,QACRlU,GACA,SAAA4U,GAAM,OAAAoB,EAAS9B,QAAQU,IAAO,IAAWE,SACtC,IAAWA,QAGb,IAAIG,GAAW,SAACjV,EAAW6U,GAChC,OACEkB,EAAU7B,QAAQlU,GAAW,SAAA4U,GAC3B,OAAOoB,EAAS9B,QAAQU,EAAIC,IAAY,IAAWC,SAC/C,IAAWA,SAMzB,aAME,WAAYZ,GACNA,IAASnc,KAAKmc,QAAUA,GAqBhC,OAlBS,YAAAqB,MAAP,SACEC,EACAC,EACAC,GAEA,OAAO3d,KAAKoD,OAAOoa,EAAMC,EAAMC,EAAMC,GAAS,IAAIT,EAAWN,MAGxD,YAAAxZ,OAAP,SAAc9B,GACZ,OAAO8B,EAAOpD,KAAMsB,IAGf,YAAA6a,QAAP,SACElU,EACA6U,GAEA,MAAM,YAzBM,EAAAK,MAAQA,EACR,EAAAC,KAAOA,EACP,EAAAI,MAAQA,EACR,EAAAlK,QAAUA,EAwB1B,EA5BA,G,SA8BgBA,EACd2I,EACAhU,GAEA,OACEgU,EAAKE,QACHI,EACEtU,EAAUnB,QDvDlB,SAAmCmB,GACjC,IAAMiW,EAAuC,CAC3CzW,UAAWQ,EAAUR,WAAa,GAClC0W,WAAYlW,EAAUkW,YAAc,GACpCjX,cAAee,EAAUf,cACzBqL,MAAOtK,EAAUsK,OAWnB,OAPK2L,EAAqBhX,gBACxBgX,EAAqBhX,cACmB,kBAA/BgX,EAAqB3L,MACxB,YAAiB2L,EAAqB3L,OACtC,IAGD2L,ECwCDE,C,SD5H0BnW,GAQhC,IAPA,IAAMoW,EAAmB,CACvB,QACA,gBACA,YACA,aACA,WAEc,MAAA1e,OAAOmB,KAAKmH,GAAZ,eAAwB,CAAnC,IAAIhH,EAAG,KACV,GAAIod,EAAiBjY,QAAQnF,GAAO,EAClC,MAAM,WAIV,OAAOgH,EC8GkBqW,CAAkBrW,OAEpC,IAAW8U,O,8CCvHPwB,E,OAMJ,E,0HCqDT,SAAgBC,EAAiB9P,GAC/B,OACEA,EAAI9G,YACDC,QACC,SAAA4W,GACE,MAAoB,wBAApBA,EAAW1W,MAAkC0W,EAAWjgB,QAE3DwQ,KAAI,SAAClH,GAA+B,OAAAA,EAAEtJ,KAAKgD,SAAO,IAAM,KClFf,oBAAZkd,SACb,kBAAdC,WACPA,UAAUC,QCFJ,iBAAAhf,SCAA,iBAAAC,eCEWF,OAAOkG,OAAO,M,oDCDlB,SAASgZ,EAAyBnP,EAAQoP,GACvD,GAAc,MAAVpP,EAAgB,MAAO,GAC3B,IACIzO,EAAKgD,EADL8a,ECHS,SAAuCrP,EAAQoP,GAC5D,GAAc,MAAVpP,EAAgB,MAAO,GAC3B,IAEIzO,EAAKgD,EAFL8a,EAAS,GACTC,EAAarf,OAAOmB,KAAK4O,GAG7B,IAAKzL,EAAI,EAAGA,EAAI+a,EAAW5e,OAAQ6D,IACjChD,EAAM+d,EAAW/a,GACb6a,EAAS1Y,QAAQnF,IAAQ,IAC7B8d,EAAO9d,GAAOyO,EAAOzO,IAGvB,OAAO8d,EDTM,CAA6BrP,EAAQoP,GAGlD,GAAInf,OAAO0G,sBAAuB,CAChC,IAAI4Y,EAAmBtf,OAAO0G,sBAAsBqJ,GAEpD,IAAKzL,EAAI,EAAGA,EAAIgb,EAAiB7e,OAAQ6D,IACvChD,EAAMge,EAAiBhb,GACnB6a,EAAS1Y,QAAQnF,IAAQ,GACxBtB,OAAOjB,UAAUwgB,qBAAqBxe,KAAKgP,EAAQzO,KACxD8d,EAAO9d,GAAOyO,EAAOzO,IAIzB,OAAO8d,EAjBT,mC,iCEAA,wDAASI,EAAQC,GAAwT,OAAtOD,EAArD,oBAAXE,QAAoD,kBAApBA,OAAOC,SAAmC,SAAiBF,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,oBAAXC,QAAyBD,EAAIxZ,cAAgByZ,QAAUD,IAAQC,OAAO3gB,UAAY,gBAAkB0gB,IAAyBA,GASzU,SAASpS,EAAQxL,GAC9B,OAAO+d,EAAY/d,EAAO,IAG5B,SAAS+d,EAAY/d,EAAOge,GAC1B,OAAQL,EAAQ3d,IACd,IAAK,SACH,OAAO2Z,KAAKC,UAAU5Z,GAExB,IAAK,WACH,OAAOA,EAAMhD,KAAO,aAAa4E,OAAO5B,EAAMhD,KAAM,KAAO,aAE7D,IAAK,SACH,OAAc,OAAVgD,EACK,OAUf,SAA2BA,EAAOie,GAChC,IAA6C,IAAzCA,EAAqBrZ,QAAQ5E,GAC/B,MAAO,aAGT,IAAIge,EAAa,GAAGpc,OAAOqc,EAAsB,CAACje,IAC9Cke,EA4DN,SAAqBC,GACnB,IAAID,EAAkBC,EAAOC,OAAOC,MAEpC,GAA+B,oBAApBH,EACT,OAAOA,EAGT,GAA8B,oBAAnBC,EAAO3S,QAChB,OAAO2S,EAAO3S,QApEM8S,CAAYte,GAElC,QAAwB8J,IAApBoU,EAA+B,CAEjC,IAAIK,EAAcL,EAAgBhf,KAAKc,GAEvC,GAAIue,IAAgBve,EAClB,MAA8B,kBAAhBue,EAA2BA,EAAcR,EAAYQ,EAAaP,QAE7E,GAAIxb,MAAMyH,QAAQjK,GACvB,OAwBJ,SAAqBoC,EAAO4b,GAC1B,GAAqB,IAAjB5b,EAAMxD,OACR,MAAO,KAGT,GAAIof,EAAWpf,OA1ES,EA2EtB,MAAO,UAOT,IAJA,IAAImD,EAAMyc,KAAKC,IA/EM,GA+EgBrc,EAAMxD,QACvC8f,EAAYtc,EAAMxD,OAASmD,EAC3B4c,EAAQ,GAEHlc,EAAI,EAAGA,EAAIV,IAAOU,EACzBkc,EAAMle,KAAKsd,EAAY3b,EAAMK,GAAIub,IAGjB,IAAdU,EACFC,EAAMle,KAAK,mBACFie,EAAY,GACrBC,EAAMle,KAAK,OAAOmB,OAAO8c,EAAW,gBAGtC,MAAO,IAAMC,EAAMC,KAAK,MAAQ,IA/CvBC,CAAY7e,EAAOge,GAG5B,OAGF,SAAsBG,EAAQH,GAC5B,IAAI1e,EAAOnB,OAAOmB,KAAK6e,GAEvB,GAAoB,IAAhB7e,EAAKV,OACP,MAAO,KAGT,GAAIof,EAAWpf,OA1DS,EA2DtB,MAAO,IAgDX,SAAsBuf,GACpB,IAAIW,EAAM3gB,OAAOjB,UAAUkB,SAASc,KAAKif,GAAQxR,QAAQ,aAAc,IAAIA,QAAQ,KAAM,IAEzF,GAAY,WAARmS,GAAkD,oBAAvBX,EAAO/Z,YAA4B,CAChE,IAAIpH,EAAOmhB,EAAO/Z,YAAYpH,KAE9B,GAAoB,kBAATA,GAA8B,KAATA,EAC9B,OAAOA,EAIX,OAAO8hB,EA3DQC,CAAaZ,GAAU,IAOtC,MAAO,KAJU7e,EAAKkO,KAAI,SAAU/N,GAElC,OAAOA,EAAM,KADDse,EAAYI,EAAO1e,GAAMue,MAGdY,KAAK,MAAQ,KAlB/BI,CAAahf,EAAOge,GA1BhBiB,CAAkBjf,EAAOge,GAElC,QACE,OAAOI,OAAOpe,M,iCC7BpB,IAAIqe,EAA8C,oBAAXR,QAA+C,oBAAfA,OAAOqB,IAAqBrB,OAAOqB,IAAI,mCAAgCpV,EAC/HuU,O,iCCKR,SAASc,EAAuBC,GAErC,IAAIC,EAAQD,EAAUpD,MAAM,gBAExBsD,EAqBC,SAAmCD,GAGxC,IAFA,IAAIC,EAAe,KAEV7c,EAAI,EAAGA,EAAI4c,EAAMzgB,OAAQ6D,IAAK,CACrC,IAAI8c,EAAOF,EAAM5c,GACb+c,EAASC,EAAkBF,GAE/B,GAAIC,IAAWD,EAAK3gB,UAIC,OAAjB0gB,GAAyBE,EAASF,IAGf,KAFrBA,EAAeE,IAGb,MAKN,OAAwB,OAAjBF,EAAwB,EAAIA,EAzChBI,CAA0BL,GAE7C,GAAqB,IAAjBC,EACF,IAAK,IAAI7c,EAAI,EAAGA,EAAI4c,EAAMzgB,OAAQ6D,IAChC4c,EAAM5c,GAAK4c,EAAM5c,GAAGkI,MAAM2U,GAK9B,KAAOD,EAAMzgB,OAAS,GAAK+gB,EAAQN,EAAM,KACvCA,EAAMO,QAGR,KAAOP,EAAMzgB,OAAS,GAAK+gB,EAAQN,EAAMA,EAAMzgB,OAAS,KACtDygB,EAAM3e,MAIR,OAAO2e,EAAMT,KAAK,MA0BpB,SAASa,EAAkBI,GAGzB,IAFA,IAAIpd,EAAI,EAEDA,EAAIod,EAAIjhB,SAAsB,MAAXihB,EAAIpd,IAAyB,OAAXod,EAAIpd,KAC9CA,IAGF,OAAOA,EAGT,SAASkd,EAAQE,GACf,OAAOJ,EAAkBI,KAASA,EAAIjhB,OASjC,SAASkhB,EAAiB9f,GAC/B,IAAI+f,EAAcriB,UAAUkB,OAAS,QAAsBkL,IAAjBpM,UAAU,GAAmBA,UAAU,GAAK,GAClFsiB,EAAsBtiB,UAAUkB,OAAS,QAAsBkL,IAAjBpM,UAAU,IAAmBA,UAAU,GACrFuiB,GAAwC,IAAzBjgB,EAAM4E,QAAQ,MAC7Bsb,EAA+B,MAAblgB,EAAM,IAA2B,OAAbA,EAAM,GAC5CmgB,EAA+C,MAA5BngB,EAAMA,EAAMpB,OAAS,GACxCwhB,GAAwBH,GAAgBE,GAAoBH,EAC5D1U,EAAS,GAYb,OAVI8U,GAA0BH,GAAgBC,IAC5C5U,GAAU,KAAOyU,GAGnBzU,GAAUyU,EAAc/f,EAAM2M,QAAQ,MAAO,KAAOoT,GAAe/f,EAE/DogB,IACF9U,GAAU,MAGL,MAAQA,EAAOqB,QAAQ,OAAQ,SAAW,MA7FnD,qE,2ICGY0T,E,uEAgDZ,SAAgBC,EACdjO,GAEA,OAAOA,EAAgB,GAnDzB,SAAYgO,GAMV,yBAMA,mCAMA,6BAMA,yBAOA,mBAKA,qBAKA,qBAzCF,CAAYA,MAAa,KCOzB,+B,+CAQA,OARmCE,iBAC1B,YAAC,KAAR,WACE,OAAO/hB,MAGF,YAAC,gBAAR,WACE,OAAOA,MAEX,EARA,CAAmC+hB,K,SCVnBC,EAAmBxgB,GACjC,OAAOwC,MAAMyH,QAAQjK,IAAUA,EAAMpB,OAAS,ECUhD,ICkBY6hB,EDGZ,cAaE,WAAY,G,IACVtL,EAAA,EAAAA,cACAuL,EAAA,EAAAA,aACAC,EAAA,EAAAA,aACAC,EAAA,EAAAA,UAJF,EAWE,YAAMD,IAAa,K,OACnB,EAAKxL,cAAgBA,GAAiB,GACtC,EAAKuL,aAAeA,GAAgB,KAKlC,EAAK7jB,QAHF8jB,GAjDoB,SAACE,GAC5B,IAAIhkB,EAAU,GAiBd,OAfI2jB,EAAgBK,EAAI1L,gBACtB0L,EAAI1L,cAAcmE,SAAQ,SAACwH,GACzB,IAAMH,EAAeG,EACjBA,EAAajkB,QACb,2BACJA,GAAW,kBAAkB8jB,EAAY,QAIzCE,EAAIH,eACN7jB,GAAW,kBAAoBgkB,EAAIH,aAAa7jB,QAAU,MAI5DA,EAAUA,EAAQ8P,QAAQ,MAAO,IAiCdoU,CAAqB,GAKtC,EAAKH,UAAYA,EAIhB,EAAa5c,UAAYgd,EAAY9jB,U,EAE1C,OAxCiC,iBAwCjC,EAxCA,CAAiCC,QCHjC,SAAYsjB,GACV,uBACA,yBACA,mBAHF,CAAYA,MAAS,KCiCd,IAQP,cAuBE,WAAY,G,IACVQ,EAAA,EAAAA,aACAzR,EAAA,EAAAA,QACA,IAAA0R,uBAAA,IAAkB,GAAlB,EAHF,EASE,aAAM,SAACpG,GACL,SAAKqG,YAAYrG,OAClB,KAlBK,EAAAsG,UAAY,IAAI9R,IAChB,EAAA3I,cAAgB,IAAI2I,IAoB1B,EAAK+R,YAAa,EAGlB,EAAK7R,QAAUA,EACf,EAAKvJ,UAAYuJ,EAAQvJ,WAAc,GACvC,EAAKqb,QAAUL,EAAaM,kBAC5B,EAAKL,gBAAkBA,EAEvB,IAAMM,EAAQ,YAAuBhS,EAAQuB,O,OAC7C,EAAK0Q,UAAYD,GAASA,EAAMxkB,MAAQwkB,EAAMxkB,KAAKgD,MAGnD,EAAKihB,aAAeA,E,EAqjBxB,OAnmBU,iBAiDD,YAAA3V,OAAP,sBACE,OAAO,IAAI2N,SAAQ,SAACC,EAASwI,GAC3B,IAAM5G,EAA+C,CACnDhb,KAAM,SAACwL,GACL4N,EAAQ5N,GAYR,EAAK8V,UAAUO,OAAO7G,GACjB,EAAKsG,UAAU1hB,MAClB,EAAKuhB,aAAaW,YAAY,EAAKN,SAGrClgB,YAAW,WACTiT,EAAakB,gBACZ,IAEL3X,MAAO8jB,GAEHrN,EAAe,EAAKE,UAAUuG,OAMjC,YAAA9F,cAAP,WACE,IAAM1J,EAAS9M,KAAKoU,mBAIpB,YAHoB9I,IAAhBwB,EAAOkH,OACTlH,EAAOkH,KAAO,IAETlH,GASF,YAAAsH,iBAAP,WACE,GAAIpU,KAAK6iB,WAAY,CACX,IAAAzM,EAAA,KAAAA,WACR,MAAO,CACLpC,MAAOhU,KAAKkW,WAAaE,GAAcA,EAAWpC,WAAQ,EAC1D5U,MAAOY,KAAKkW,UACZtC,SAAS,EACTC,cAAegO,EAAcziB,OAI3B,IAEF0N,EAvHNuW,EACAC,EAoHQ,gDAAEtP,EAAA,EAAAA,KAAMyC,EAAA,EAAAA,QACR8M,EAAkBvjB,KAAKyiB,aAAae,WAAW5hB,IAAI5B,KAAK8iB,SAGtD3N,EAAA,aAAAA,YAEFsO,EACY,iBAAhBtO,GACgB,aAAhBA,EAEF,GAAIoO,EAAiB,CACX,IAAA1P,EAAA,EAAAA,cAER,GAlIJwP,EAkIiBE,OAjIjB,KAAAD,EAiIkCtjB,KAAKgR,QAAQ0S,eAjI/CJ,EAAA,QACGD,IACHA,EAAWnB,cACC,SAAXoB,GAAqBtB,EAAgBqB,EAAW1M,gBA+H3C,MAAO,CACL3C,UAAM,EACNJ,SAAS,EACTC,cAAa,EACbzU,MAAO,IAAIojB,EAAY,CACrB7L,cAAe4M,EAAgB5M,cAC/BuL,aAAcqB,EAAgBrB,gBAUhCqB,EAAgB9b,YAClBzH,KAAKgR,QAAQvJ,UAAS,2BACjBzH,KAAKgR,QAAQvJ,WACZ8b,EAAgB9b,WAEtBzH,KAAKyH,UAAYzH,KAAKgR,QAAQvJ,WAGhCqF,EAAS,CACPkH,KAAI,EACJJ,QAASkO,EAAyBjO,GAClCA,cAAa,GAGX0P,EAAgB5M,eAA8C,QAA7B3W,KAAKgR,QAAQ0S,cAChD5W,EAAO4J,OAAS6M,EAAgB5M,mBAG7B,CAOL,IAAM/C,EAAU6P,GACbhN,GAA2B,eAAhBtB,EAEdrI,EAAS,CACPkH,KAAI,EACJJ,QAAO,EACPC,cAAeD,EAAUiO,EAAcjO,QAAUiO,EAAc/N,OAQnE,OAJK2C,GACHzW,KAAK2jB,iBAAgB,2BAAM7W,GAAM,CAAE8W,OAAO,KAG5C,2BAAY9W,GAAM,CAAE2J,QAAO,KAKtB,YAAAoN,0BAAP,SAAiCC,GACvB,WAAAC,mBACR,QACEC,GACAF,GACAE,EAASnQ,gBAAkBiQ,EAAUjQ,eACrCmQ,EAASJ,QAAUE,EAAUF,OAC7B,YAAQI,EAAShQ,KAAM8P,EAAU9P,QAM9B,YAAAqC,cAAP,WACE,OAAOrW,KAAKoW,YAGP,YAAAD,aAAP,WACE,OAAOnW,KAAKkW,WAGP,YAAAI,iBAAP,kBACStW,KAAKoW,kBACLpW,KAAK+jB,0BACL/jB,KAAKkW,UACZlW,KAAK6iB,YAAa,GAGb,YAAArO,sBAAP,WACE,IAAMgP,EAAaxjB,KAAKyiB,aAAae,WAAW5hB,IAAI5B,KAAK8iB,SACrDU,IACFA,EAAWtB,aAAe,KAC1BsB,EAAW7M,cAAgB,KAWxB,YAAAnE,QAAP,SAAe/K,GACP,IAAA0N,EAAA,aAAAA,YAEN,MAAoB,eAAhBA,EACKsF,QAAQyI,OAAO,aAQJ,aAAhB/N,GACgB,sBAAhBA,IACFA,EAAc,gBAGX,YAAQnV,KAAKyH,UAAWA,KAE3BzH,KAAKyH,UAAS,2BACTzH,KAAKyH,WACLA,IAIF,YAAQzH,KAAKgR,QAAQvJ,UAAWzH,KAAKyH,aAExCzH,KAAKgR,QAAQvJ,UAAS,2BACjBzH,KAAKgR,QAAQvJ,WACbzH,KAAKyH,YAILzH,KAAKyiB,aAAawB,WACvBjkB,KAAK8iB,QAAO,2BACP9iB,KAAKgR,SAAO,CAAEmE,YAAW,IAC9B8M,EAAUzP,WAIP,YAAAG,UAAP,SACED,GADF,WAOI,6BAGF,IAAMwR,EAAkB,2BAClBxR,EAAiBH,MAAQG,EAAgB,uCACxC1S,KAAKgR,SACL0B,GAAgB,CACnBjL,UAAW,OAAF,IAAE,CAAF,eACJzH,KAAKyH,WACLiL,EAAiBjL,cAEvB,CACD0N,YAAa,iBAGTgP,EAAMnkB,KAAKyiB,aAAaM,kBAE9B,OAAO/iB,KAAKyiB,aACTwB,WACCE,EACAD,EACAjC,EAAUmC,OACVpkB,KAAK8iB,SAEN5K,MACC,SAAAmM,GAQE,OAPA,EAAKvR,aAAY,SAACkD,GAChB,OAAAtD,EAAiBI,YAAYkD,EAAgB,CAC3CqO,gBAAiBA,EAAgBrQ,KACjCvM,UAAWyc,EAAgBzc,eAG/B,EAAKgb,aAAa6B,UAAUH,GACrBE,KAET,SAAAjlB,GAEE,MADA,EAAKqjB,aAAa6B,UAAUH,GACtB/kB,MAQP,YAAAiU,gBAAP,SAIErC,GAJF,WAUQ6E,EAAe7V,KAAKyiB,aACvB8B,yBAAyB,CACxBhS,MAAOvB,EAAQxJ,SACfC,UAAWuJ,EAAQvJ,YAEpBsO,UAAU,CACTzU,KAAM,SAACyY,GACG,IAAAjH,EAAA,EAAAA,YACJA,GACF,EAAKA,aACH,SAAC0R,EAAU,G,IAAE/c,EAAA,EAAAA,UACX,OAAAqL,EAAY0R,EAAU,CACpBzK,iBAAgB,EAChBtS,UAAS,QAKnBrI,MAAO,SAACijB,GACFrR,EAAQ8F,SACV9F,EAAQ8F,QAAQuL,MASxB,OAFAriB,KAAKmI,cAAc4I,IAAI8E,GAEhB,WACD,EAAK1N,cAAcgb,OAAOtN,IAC5BA,EAAakB,gBAOZ,YAAA3F,WAAP,SACEiK,GAEQ,mBAAAlG,YACRnV,KAAKgR,QAAU,2BACVhR,KAAKgR,SACLqK,GAGDA,EAAKrI,aACPhT,KAAKiT,aAAaoI,EAAKrI,cACQ,IAAtBqI,EAAKrI,cACdhT,KAAKmT,cAGC,IAAAgC,EAAA,EAAAA,YAER,OAAOnV,KAAKykB,aACVzkB,KAAKgR,QAAQvJ,UAGbid,IAAmBvP,IACE,eAAnBuP,GACmB,YAAnBA,GACgB,iBAAhBvP,GAEFkG,EAAKsJ,eA+BF,YAAAF,aAAP,SACEhd,EACAmd,EACAD,GAOA,YARA,IAAAC,OAAA,QACA,IAAAD,OAAA,GAGA3kB,KAAK6iB,YAAa,EAElBpb,EAAYA,GAAazH,KAAKyH,WAEzBmd,GAAY,YAAQnd,EAAWzH,KAAKyH,WAIhCzH,KAAK4iB,UAAU1hB,MAAQyjB,EAC1B3kB,KAAK8M,SACL2N,QAAQC,WAGd1a,KAAKyH,UAAYzH,KAAKgR,QAAQvJ,UAAYA,EAGrCzH,KAAK4iB,UAAU1hB,KAKblB,KAAKyiB,aAAawB,WACvBjkB,KAAK8iB,QACL9iB,KAAKgR,SANEyJ,QAAQC,YAUZ,YAAA5H,YAAP,SACED,GAKQ,IAAA4P,EAAA,KAAAA,aACF,6CACJzM,EAAA,EAAAA,eACAvO,EAAA,EAAAA,UACAD,EAAA,EAAAA,SAKIsc,EAAY,aAAsB,WACtC,OAAAjR,EAAMmD,EAAgB,CAAEvO,UAAS,OAG/Bqc,IACFrB,EAAaoC,UAAUC,sBACrBtd,EACAC,EACAqc,GAEFrB,EAAasC,qBAIV,YAAA5R,YAAP,WACEnT,KAAKyiB,aAAauC,iBAAiBhlB,KAAK8iB,SACxC9iB,KAAKgR,QAAQgC,kBAAe1H,GAGvB,YAAA2H,aAAP,SAAoBD,GAClBiS,EAA0BjlB,MAC1BA,KAAKgR,QAAQgC,aAAeA,EAC5BhT,KAAKyiB,aAAayC,kBAAkBllB,KAAKgR,QAAShR,KAAK8iB,UAGjD,YAAAa,iBAAR,SAAyBG,GACvB,IAAM9N,EAAiBhW,KAAKoW,WAK5B,OAJApW,KAAKoW,WAAa0N,EAClB9jB,KAAK+jB,mBAAqB/jB,KAAKyiB,aAAa0C,uBACxCrB,EACA,YAAUA,GACP9N,GAGD,YAAA2M,YAAR,SAAoBrG,GAApB,WAGE,IACE,IAAI8I,EAAe9I,EAAiB+I,cAAcC,UAC9CF,IAAgBA,EAAYhmB,QAC9BgmB,EAAYhmB,MAAQmmB,GAEtB,UAEF,IAAMzH,GAAS9d,KAAK4iB,UAAU1hB,KAY9B,OAXAlB,KAAK4iB,UAAU7R,IAAIuL,GAGfA,EAAShb,MAAQtB,KAAKoW,YAAYkG,EAAShb,KAAKtB,KAAKoW,YACrDkG,EAASld,OAASY,KAAKkW,WAAWoG,EAASld,MAAMY,KAAKkW,WAGtD4H,GACF9d,KAAKwlB,aAGA,WACD,EAAK5C,UAAUO,OAAO7G,KAAc,EAAKsG,UAAU1hB,MACrD,EAAKukB,kBAKH,YAAAD,WAAR,sBACU/C,EAAF,KAAEA,aAAcK,EAAhB,KAAgBA,QAElB9iB,KAAK0iB,iBACPD,EAAaiD,mBAA0B5C,EAAS9iB,MAG9CA,KAAKgR,QAAQgC,eACfiS,EAA0BjlB,MAC1ByiB,EAAayC,kBAAkBllB,KAAKgR,QAAS8R,IAG/C,IAAMhM,EAAU,SAAC1X,GAGf,EAAKukB,iBAAgB,2BAChB,EAAKvN,YAAU,CAClBM,OAAQtX,EAAMuX,cACd9C,cAAegO,EAAcziB,MAC7BwU,SAAS,KAEX+R,EAAuB,EAAK/C,UAAW,QAAS,EAAK1M,UAAY9W,IAGnEqjB,EAAamD,aAAoB9C,EAAS9iB,KAAKgR,QAAS,CACtD1P,KAAM,SAACwL,GACL,GAAI,EAAKoJ,WAAa,EAAK2N,0BAA0B/W,GAAS,CAC5D,IAAM,EAAiB,EAAK6W,iBAAiB7W,GACvC,YAAE,IAAAyF,MAAO9K,EAAA,EAAAA,UAAW,IAAA0N,YAQtBsN,EAAaoD,UAAU,GAAOC,iBAChCrD,EAAasD,gBAAgBC,qBAC3B,EACAve,GACAyQ,MAAK,SAACzQ,GACN,IAAMwe,EAAoB,EAAKxe,UAC/B,EAAKA,UAAY,EAAKuJ,QAAQvJ,UAAYA,GAEvCqF,EAAO8G,SACR,GACgB,eAAhB,GACA6O,EAAaoD,UAAU,GAAOK,cAC7B,YAAQD,EAAmBxe,GAE5B,EAAK+K,UAELmT,EAAuB,EAAK/C,UAAW,OAAQ9V,MAInD6Y,EAAuB,EAAK/C,UAAW,OAAQ9V,KAIrD1N,MAAO0X,IACNlB,MAAMkB,IAGH,YAAA2O,cAAR,WACU,IAAAhD,EAAA,KAAAA,aAERziB,KAAK6iB,YAAa,EAClBJ,EAAauC,iBAAiBhlB,KAAK8iB,SAGnC9iB,KAAKmI,cAAc2S,SAAQ,SAAAqL,GAAO,OAAAA,EAAIpP,iBACtC/W,KAAKmI,cAAcwI,QAEnB8R,EAAa2D,sBAAsBpmB,KAAK8iB,SACxCL,EAAa6B,UAAUtkB,KAAK8iB,SAE5B9iB,KAAK4iB,UAAUjS,SAEnB,EAtmBA,CAGU4N,GAqmBV,SAASgH,EAAyCnmB,IAIlD,SAASumB,EACP/C,EACA7jB,EACAsnB,GAKA,IAAMC,EAAqC,GAC3C1D,EAAU9H,SAAQ,SAAA3G,GAAO,OAAAA,EAAIpV,IAAWunB,EAAoBrkB,KAAKkS,MACjEmS,EAAoBxL,SAAQ,SAAA3G,GAAO,OAACA,EAAYpV,GAAQsnB,MAG1D,SAASpB,EACPnP,GAEQ,IAAAX,EAAA,UAAAA,YACR,mDCjsBF,8BACU,KAAAoR,MAAsD,GA0ChE,OAxCS,YAAAC,SAAP,WACE,OAAOxmB,KAAKumB,OAGP,YAAA3kB,IAAP,SAAWmW,GACT,OAAO/X,KAAKumB,MAAMxO,IAGb,YAAA0O,aAAP,SACE1O,EACAO,EACA7Q,GAEAzH,KAAKumB,MAAMxO,GAAc,CACvBO,SAAQ,EACR7Q,UAAWA,GAAa,GACxBmM,SAAS,EACTxU,MAAO,OAIJ,YAAAsnB,kBAAP,SAAyB3O,EAAoB3Y,GAC3C,IAAMkZ,EAAWtY,KAAKumB,MAAMxO,GACxBO,IACFA,EAAS1E,SAAU,EACnB0E,EAASlZ,MAAQA,IAId,YAAAunB,mBAAP,SAA0B5O,GACxB,IAAMO,EAAWtY,KAAKumB,MAAMxO,GACxBO,IACFA,EAAS1E,SAAU,EACnB0E,EAASlZ,MAAQ,OAId,YAAAe,MAAP,WACEH,KAAKumB,MAAQ,IAEjB,EA3CA,GCcA,0BACU,KAAAA,MAAgD,G,OAEjD,YAAAC,SAAP,WACE,OAAOxmB,KAAKumB,OAGP,YAAA3kB,IAAP,SAAWkhB,GACT,OAAO9iB,KAAKumB,MAAMzD,IAGb,YAAA8D,UAAP,SAAiBrU,GAUf,IAAMsU,EAAgB7mB,KAAKumB,MAAMhU,EAAMuQ,SAMpC,aAAA+D,GACDA,EAAcrf,WAAa+K,EAAM/K,UACjC,YAAQqf,EAAcrf,SAAU+K,EAAM/K,UACtC,IAMF,IAeEqM,EAdA,KACA,OACA,0BAGA,G,8BAEE,wBAAkC,EAAApM,a,8EAiBW,U,IAE/CkP,EAAgB,G,qBAMd,EAAa,iBAEf,uBACA,oBACA,sBACA,oBACA,kBACA,cAAe,E,gBAWf,qBAGqC,kBAArC,uBACE,aAAa,uB,0GAWZ,KAAK,OAAU,gBAEpB3W,KAAKumB,MAAMzD,GAAS,kBACpB9iB,KAAKumB,MAAMzD,GAAS,cAAgB,wBAKpC,KACE,MAAO,0BACP9iB,KAAA,+BAE+B,kBAA/B,G,kGAWG,KAAK,OAAU,gBAMpB,KAAI,MAAO,gBAAwB,EACjCA,KAAA,yBAA8C,M,0DAMhC,8C,IACdqjB,EAAU,YAAa,KAAQ,SAC/BA,IACA,oB,EAC0B,kBAAG,K,+BAOjC,yC,WAEA,I,EACS,UAAU,MAAK,Y,IACpB,O,iBACgB,OAAC,SAAQ,Y,uEA1J/B,GCwDA,iBAME,WAAY,G,IACVrc,EAAA,EAAAA,MACAL,EAAA,EAAAA,OACAmgB,EAAA,EAAAA,UACAC,EAAA,EAAAA,gBAEA/mB,KAAKgH,MAAQA,EAETL,IACF3G,KAAK2G,OAASA,GAGZmgB,GACF9mB,KAAKgnB,aAAaF,GAGhBC,GACF/mB,KAAKinB,mBAAmBF,GAkX9B,OA9WS,YAAAC,aAAP,SAAoBF,GAApB,WACE9mB,KAAK8mB,UAAY9mB,KAAK8mB,WAAa,GAC/B9iB,MAAMyH,QAAQqb,GAChBA,EAAUhM,SAAQ,SAAAoM,GAChB,EAAKJ,UAAY,YAAU,EAAKA,UAAWI,MAG7ClnB,KAAK8mB,UAAY,YAAU9mB,KAAK8mB,UAAWA,IAIxC,YAAAK,aAAP,SAAoBL,GAClB9mB,KAAK8mB,UAAY,GACjB9mB,KAAKgnB,aAAaF,IAGb,YAAAM,aAAP,WACE,OAAOpnB,KAAK8mB,WAAa,IAOd,YAAAO,aAAb,SAAiC,G,IAC/B7f,EAAA,EAAAA,SACA8f,EAAA,EAAAA,aACAxgB,EAAA,EAAAA,QACAW,EAAA,EAAAA,UACA,IAAA8f,8BAAA,IAAyB,GAAzB,E,uFAQA,OAAI/f,EACF,GAAOxH,KAAKwnB,gBACVhgB,EACA8f,EAAatT,KACblN,EACAW,EACAzH,KAAK+mB,gBACLQ,GACArP,MAAK,SAAAuP,GAAe,kCACjBH,GAAY,CACftT,KAAMyT,EAAY3a,aAItB,GAAOwa,UAGF,YAAAL,mBAAP,SAA0BF,GACxB/mB,KAAK+mB,gBAAkBA,GAGlB,YAAAW,mBAAP,WACE,OAAO1nB,KAAK+mB,iBAKP,YAAAY,YAAP,SAAmBngB,GACjB,OAAI,YAAc,CAAC,UAAWA,IACxBxH,KAAK8mB,UACAtf,EASJ,MAIF,YAAA0e,YAAP,SAAmB1e,GACjB,OAAOxH,KAAK8mB,UAAY,YAA6Btf,GAAYA,GAG5D,YAAAogB,eAAP,SAAsB9gB,QAAA,IAAAA,MAAA,IACZ,IAAAE,EAAA,KAAAA,MAkBR,OAhBmB,OAAH,IAAG,CAAH,eACXF,GAAO,CACVE,MAAK,EAEL6gB,YAAa,SAACzI,GACZ,GAAKpY,EAAc8gB,OACjB,OAAQ9gB,EAAc8gB,OAAOC,iBAAiB3I,GAE9C,sBAcK,YAAA4G,qBAAb,SACExe,EACAC,EACAX,G,YADA,IAAAW,MAAA,SACA,IAAAX,MAAA,I,gFAEA,OAAIU,EACF,GAAOxH,KAAKwnB,gBACVhgB,EACAxH,KAAKgoB,wBAAwBxgB,EAAUC,IAAc,GACrDzH,KAAK4nB,eAAe9gB,GACpBW,GACAyQ,MAAK,SAAAlE,GAAQ,kCACVvM,GACAuM,EAAKiU,uBAIZ,kBACKxgB,WAIA,YAAAygB,qBAAP,SAA4B1gB,GAC1B,IAAI2gB,GAAiB,EAkBrB,OAjBA,YAAM3gB,EAAU,CACdiC,UAAW,CACT+D,MAAK,SAAC5B,GACJ,GAAwB,WAApBA,EAAKpN,KAAKgD,OAAsBoK,EAAK1M,YACvCipB,EAAiBvc,EAAK1M,UAAUkpB,MAC9B,SAAAC,GACE,MAAmB,WAAnBA,EAAI7pB,KAAKgD,OACU,iBAAnB6mB,EAAI7mB,MAAMuG,OACU,IAApBsgB,EAAI7mB,MAAMA,UAGZ,OAAO,QAMV2mB,GAID,YAAAH,wBAAR,SACExgB,EACAC,GAEA,OAAOzH,KAAKgH,MAAMshB,KAAK,CACrB/V,MAAO,YAA2B/K,GAClCC,UAAS,EACT8gB,mBAAmB,EACnBC,YAAY,IACX1b,QAGS,YAAA0a,gBAAd,SACEhgB,EACAihB,EACA3hB,EACAW,EACAsf,EACAQ,G,YAHA,IAAAzgB,MAAA,SACA,IAAAW,MAAA,SACA,IAAAsf,MAAA,WAAyC,gBACzC,IAAAQ,OAAA,G,0GC/QkClG,ED2SlC,OA1BMqH,EAAiB,YAAkBlhB,GACnCG,EAAY,YAAuBH,GACnCmhB,EAAc,YAAkBhhB,GAEhCihB,EAAuBF,EAC1BzgB,UAEG4gB,EAAuBD,GCxRKvH,EDyRRuH,GCxRjBE,OAAO,GAAGC,cAAgB1H,EAAIlV,MAAM,GDyRzC,QAEInF,GAAF,EAAoBhH,MAAb,MAAE2G,EAAM,SACfqiB,EAA2B,CAC/BL,YAAW,EACX7hB,QAAS,OAAF,IAAE,CAAF,eACFA,GAAO,CACVE,MAAK,EACLL,OAAM,IAERc,UAAS,EACTsf,gBAAe,EACf8B,qBAAoB,EACpBZ,kBAAmB,GACnBV,uBAAsB,GAGxB,GAAOvnB,KAAKipB,oBACVP,EAAeQ,aACfT,EACAO,GACA9Q,MAAK,SAAApL,GAAU,MAAC,CAChBA,OAAM,EACNmb,kBAAmBe,EAAYf,8BAIrB,YAAAgB,oBAAd,SACEC,EACAT,EACAO,G,4GA+CA,OA7CQL,EAAoCK,EAAzB,YAAEliB,EAAuBkiB,EAAhB,QAAEvhB,EAAcuhB,EAAL,UACjCG,EAA0B,CAACV,GAE3BnV,EAAU,SAAO8V,GAAwB,+C,6CAC7C,OAAK,YAAcA,EAAW3hB,GAK1B,YAAQ2hB,GACV,GAAOppB,KAAKqpB,aAAaD,EAAWX,EAAWO,GAAa9Q,MAC1D,SAAAoR,G,MAC6B,qBAAhBA,GACTH,EAAelnB,OAAK,MACjB,YAAuBmnB,IAAaE,EAC7B,SAQd,YAAiBF,GACnBG,EAAWH,GAGXG,EAAWZ,EAAYS,EAAU5qB,KAAKgD,OAClB,cAAoC,IAGtD+nB,GAAYA,EAASC,gBACjBA,EAAgBD,EAASC,cAAchrB,KAAKgD,MAC9CwnB,EAAYjC,gBAAgB0B,EAAWe,EAAe1iB,IACxD,GAAO9G,KAAKipB,oBACVM,EAASL,aACTT,EACAO,GACA9Q,MAAK,SAAAuR,GACLN,EAAelnB,KAAKwnB,O,KAjCxB,WAuCJ,GAAOhP,QAAQO,IAAIkO,EAAaQ,WAAW1a,IAAIsE,IAAU4E,MAAK,WAC5D,OAAO,YAAeiR,cAIZ,YAAAE,aAAd,SACEM,EACAlB,EACAO,G,oHAiCA,OA/BQvhB,EAAcuhB,EAAL,UACXY,EAAYD,EAAMnrB,KAAKgD,MACvBqoB,EAAmB,YAAuBF,GAC1CG,EAAYF,IAAcC,EAC1BE,EAAgBtB,EAAUoB,IAAqBpB,EAAUmB,GAC3DI,EAAgBvP,QAAQC,QAAQqP,GAOjCf,EAAYzB,yBACbvnB,KAAKkoB,qBAAqByB,KAEpBM,EACJxB,EAAUyB,YAAclB,EAAYH,sBAChCsB,EAAcnqB,KAAK8mB,WAAa9mB,KAAK8mB,UAAUmD,MAE7CvP,EAAUyP,EAAYL,EAAYF,EAAYC,MAElDG,EAAgBvP,QAAQC,QAAQA,EAC9B+N,EACA,YAAyBkB,EAAOliB,GAChCuhB,EAAYliB,QACZ,CAAE6iB,MAAK,EAAEhB,YAAaK,EAAYL,iBAM1C,GAAOqB,EAAc9R,MAAK,SAACpL,GAgBzB,YAhByB,IAAAA,MAAA,GAGrB6c,EAAMS,YACRT,EAAMS,WAAWtP,SAAQ,SAAAuP,GACM,WAAzBA,EAAU7rB,KAAKgD,OAAsB6oB,EAAUnrB,WACjDmrB,EAAUnrB,UAAU4b,SAAQ,SAAAuN,GACH,OAAnBA,EAAI7pB,KAAKgD,OAAqC,gBAAnB6mB,EAAI7mB,MAAMuG,OACvCihB,EAAYf,kBAAkBI,EAAI7mB,MAAMA,OAASsL,SAQtD6c,EAAMT,aAMG,MAAVpc,EAEKA,EAGL9I,MAAMyH,QAAQqB,GACT,EAAKwd,wBAAwBX,EAAO7c,EAAQkc,GAIjDW,EAAMT,aACD,EAAKD,oBACVU,EAAMT,aACNpc,EACAkc,QAJJ,EAfSlc,aAyBL,YAAAwd,wBAAR,SACEX,EACA7c,EACAkc,GAHF,WAKE,OAAOvO,QAAQO,IACblO,EAAOkC,KAAI,SAAAub,GACT,OAAa,OAATA,EACK,KAILvmB,MAAMyH,QAAQ8e,GACT,EAAKD,wBAAwBX,EAAOY,EAAMvB,GAI/CW,EAAMT,aACD,EAAKD,oBAAoBU,EAAMT,aAAcqB,EAAMvB,QAD5D,OAMR,EAzYA,G,SEpEgBwB,EAAaC,GAC3B,IAAM7H,EAAY,IAAI9R,IAClBqV,EAA2B,KAC/B,OAAO,IAAI5H,GAAc,SAAAjC,GAavB,OAZAsG,EAAU7R,IAAIuL,GACd6J,EAAMA,GAAOsE,EAAM1U,UAAU,CAC3BzU,KAAI,SAACE,GACHohB,EAAU9H,SAAQ,SAAA3G,GAAO,OAAAA,EAAI7S,MAAQ6S,EAAI7S,KAAKE,OAEhDpC,MAAK,SAAC,GACJwjB,EAAU9H,SAAQ,SAAA3G,GAAO,OAAAA,EAAI/U,OAAS+U,EAAI/U,MAAM,OAElDwa,SAAQ,WACNgJ,EAAU9H,SAAQ,SAAA3G,GAAO,OAAAA,EAAIyF,UAAYzF,EAAIyF,iBAG1C,WACDgJ,EAAUO,OAAO7G,KAAcsG,EAAU1hB,MAAQilB,IACnDA,EAAIpP,cACJoP,EAAM,UCkBN,IAAAtmB,EAAA,iBAAAA,eAgBR,aA6BE,WAAY,G,IACVoc,EAAA,EAAAA,KACA,IAAAyO,0BAAA,IAAqB,GAArB,EACAnE,EAAA,EAAAA,MACA,IAAAoE,mBAAA,IAAc,EAAd,eACA,IAAAC,eAAA,IAAU,GAAV,EACA,IAAAC,uBAAA,IAAkB,EAAlB,KACAC,EAAA,EAAAA,WACA3F,EAAA,EAAAA,uBAnCK,KAAA4F,cAA+B,IAAIC,EACnC,KAAAxH,WAAyB,IAAIyH,EAK5B,KAAAJ,gBAA0C,GAQ1C,KAAAK,UAAY,EAIZ,KAAAljB,QAAkC,IAAIf,IAOtC,KAAAkkB,oBAAsB,IAAIlkB,IAujB1B,KAAAmkB,eAAiB,IAAK,IAAgB1M,QAAUzX,KAkchD,KAAAokB,wBAA0B,IAAIpkB,IAgP9B,KAAAqkB,qBAAuB,IAAIrkB,IAptCjCjH,KAAKic,KAAOA,EACZjc,KAAK0qB,mBAAqBA,EAC1B1qB,KAAK6kB,UAAY0B,EACjBvmB,KAAK2qB,YAAcA,EACnB3qB,KAAK6qB,gBAAkBA,EACvB7qB,KAAK8qB,WAAaA,GAAc,IAAIS,EAAW,CAAEvkB,MAAOuf,EAAMiF,aAC9DxrB,KAAK4qB,QAAUA,EACf5qB,KAAKmlB,yBAA2BA,EA+wCpC,OAxwCS,YAAAsG,KAAP,sBACEzrB,KAAKgI,QAAQ8S,SAAQ,SAAC4Q,EAAO5I,GAC3B,EAAK6I,qBAAqB7I,MAG5B9iB,KAAKmrB,oBAAoBrQ,SAAQ,SAAAoI,GAC/BA,EACE,gBAKO,YAAAjL,OAAb,SAAuB,G,IACrBK,EAAA,EAAAA,SACA7Q,EAAA,EAAAA,UACA+Q,EAAA,EAAAA,mBACA,IAAAoT,cACA,IAAA/S,sBAAA,IAAiB,EAAjB,KACA,IAAAH,2BAAA,IAAsB,GAAtB,EACA,IAAAD,OACA,IAAAiL,mBAAA,IAAc,EAAd,SACAvO,EAAA,EAAAA,YACA,IAAArO,eAAA,IAAU,EAAV,K,sIAIE,iBAI2B,mCAIvBiR,EAAa/X,KAAK+iB,kBACxBzK,EAAWtY,KAAK6lB,UAAUvN,GAAU9Q,SAEpCxH,KAAK6rB,SAAS9T,GAAY,WAAM,MAAC,CAAEvQ,SAAU8Q,MAE7C7Q,EAAYzH,KAAK8rB,aAAaxT,EAAU7Q,GAEpCzH,KAAK6lB,UAAUvN,GAAUwN,iBACf,GAAM9lB,KAAK8qB,WAAW9E,qBAAqB1N,EAAU7Q,EAAWX,IAD1E,M,OACFW,EAAY,S,iBAgDd,OA5CMskB,EAEF,WACF,IAAMC,EAA+C,GAmBrD,OAjBIC,GACF,EAAKjkB,QAAQ8S,SAAQ,SAAC,EAAqBgI,G,IAAnBoJ,EAAA,EAAAA,gBACtB,GAAIA,EAAiB,CACX,IAAAjJ,EAAA,EAAAA,UAENA,GACApjB,EAAea,KAAKurB,EAAqBhJ,KAEzC+I,EAAIlJ,GAAW,CACbqJ,QAASF,EAAoBhJ,GAC7B1Q,MAAO,EAAKiR,WAAW5hB,IAAIkhB,SAO9BkJ,GAGThsB,KAAK+qB,cAActE,aACjB1O,EACAO,EACA7Q,GAGFzH,KAAK6kB,UAAUuH,iBAAiB,CAC9BrU,WAAU,EACVvQ,SAAU8Q,EACV7Q,UAAS,EACTmkB,cAAeG,IACftT,OAAQ4T,EACR7T,mBAAkB,IAGpBxY,KAAK+kB,mBAECuH,EAAOtsB,KAEb,GAAO,IAAIya,SAAQ,SAACC,EAASwI,GAC3B,IAAIqJ,EACAntB,EAEJktB,EAAKE,sBACHlU,EAAQ,2BAEHxR,GAAO,CACV0R,mBAAkB,IAEpB/Q,GACA,GACAsO,UAAU,CACVzU,KAAA,SAAKwL,GACC,YAAsBA,IAA2B,SAAhB4W,EACnCtkB,EAAQ,IAAIojB,EAAY,CACtB7L,cAAe7J,EAAO4J,UAK1B4V,EAAKvB,cAAcpE,mBAAmB5O,GAElB,aAAhB5C,GACFmX,EAAKzH,UAAU8B,mBAAmB,CAChC5O,WAAU,EACVjL,OAAM,EACNtF,SAAU8Q,EACV7Q,UAAS,EACTmkB,cAAeG,IACftT,OAAQ4T,IAIZE,EAAczf,IAGhB1N,MAAA,SAAMijB,GACJiK,EAAKvB,cAAcrE,kBAAkB3O,EAAYsK,GACjDiK,EAAKzH,UAAU4H,qBAAqB,CAClC1U,WAAU,EACVS,mBAAkB,IAEpB8T,EAAKvH,mBACLuH,EAAKT,SAAS9T,GAAY,WAAM,MAAC,CAAEvQ,SAAU,SAC7C0b,EACE,IAAIV,EAAY,CACdN,aAAcG,MAKpBzI,SAAA,WAYE,GAXIxa,GACFktB,EAAKvB,cAAcrE,kBAAkB3O,EAAY3Y,GAGnDktB,EAAKzH,UAAU4H,qBAAqB,CAClC1U,WAAU,EACVS,mBAAkB,IAGpB8T,EAAKvH,mBAED3lB,EACF8jB,EAAO9jB,OADT,CAO8B,oBAAnByZ,IACTA,EAAiBA,EAAe0T,IAGlC,IAAMG,EAEA,GAEF1K,EAAgBnJ,IAClBA,EAAeiC,SAAQ,SAAA6R,GACrB,GAA4B,kBAAjBA,EACTL,EAAKtkB,QAAQ8S,SAAQ,SAAC,G,IAAEoR,EAAA,EAAAA,gBAEpBA,GACAA,EAAgBjJ,YAAc0J,GAE9BD,EAAqBzqB,KAAKiqB,EAAgB1Z,kBAGzC,CACL,IAAMoa,EAA6B,CACjCra,MAAOoa,EAAapa,MACpB9K,UAAWklB,EAAallB,UACxB0N,YAAa,gBAGXwX,EAAa7lB,UACf8lB,EAAa9lB,QAAU6lB,EAAa7lB,SAGtC4lB,EAAqBzqB,KAAKqqB,EAAK/Z,MAAMqa,QAK3CnS,QAAQO,IACNtC,EAAsBgU,EAAuB,IAC7CxU,MAAK,WACLoU,EAAKT,SAAS9T,GAAY,WAAM,MAAC,CAAEvQ,SAAU,SAG3B,WAAhBkc,GACA6I,GACA,YAAsBA,WAEfA,EAAY7V,OAGrBgE,EAAQ6R,sBAOL,YAAAtI,WAAb,SACEnB,EACA9R,EACA6b,EAIAC,G,oKAGE,EAGE9b,EAHa,SAAfoE,OAAQ,IAAG,OAAI,EACf,EAEEpE,EAFyB,YAA3BmE,OAAW,IAAG,gBAAa,EAC3B,EACEnE,EADU,QAAZlK,OAAO,IAAG,KAAE,EAGRyL,EAAQvS,KAAK6lB,UAAU7U,EAAQuB,OAAO/K,SAExCC,EAAYzH,KAAK8rB,aAAavZ,EAAOvB,EAAQvJ,WAE7CzH,KAAK6lB,UAAUtT,GAAOuT,iBACZ,GAAM9lB,KAAK8qB,WAAW9E,qBAAqBzT,EAAO9K,EAAWX,IADvE,M,OACFW,EAAY,S,iBA6Dd,GA1DAuJ,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAEvJ,UAAS,IAK7BslB,EAFEC,EACY,iBAAhB7X,GAAkD,aAAhBA,EAK/B6X,IACG,EAAuBhtB,KAAK6kB,UAAU2G,WAAWlD,KAAK,CAC1D/V,MAAK,EACL9K,UAAS,EACT8gB,mBAAmB,EACnBC,YAAY,IAJN5O,EAAQ,WAAE9M,EAAM,SAQxBigB,GAAenT,GAA4B,sBAAhBzE,EAC3BoX,EAAczf,GAGZmgB,EACFF,GAA+B,eAAhB5X,GAAgD,YAAhBA,EAG7C,YAAc,CAAC,QAAS5C,KAAQ0a,GAAc,GAE5CC,EAAYltB,KAAKkrB,YAGjBiC,EAAyB,aAAhBhY,EACXnV,KAAKotB,iBAAiBtK,EAASvQ,EAAOvB,QACtC1F,EAGJtL,KAAK6rB,SAAS/I,GAAS,WAAM,MAAC,CAC5Btb,SAAU+K,EACV8a,cAAeH,EACfI,aAAa,EACbH,OAAM,MAGRntB,KAAKutB,WAAWT,GAEhB9sB,KAAKwjB,WAAWoD,UAAU,CACxB9D,QAAO,EACPtb,SAAU+K,EACVib,uBAAwBP,EACxBxlB,UAAS,EACTgmB,OAAQZ,IAAc5K,EAAUyL,KAChCC,UAAWd,IAAc5K,EAAUzP,QACnC4C,SAAQ,EACR0X,oBAAmB,IAGrB9sB,KAAK+kB,mBAEDkI,EAAa,CAyBf,GAxBMW,EAAgB5tB,KAAK6tB,aAAgB,CACzCX,UAAS,EACTpK,QAAO,EACPtb,SAAU+K,EACVvB,QAAO,EACP8b,oBAAmB,IAClBlX,OAAM,SAAAxW,GAGP,MAAkBA,ERtabS,eAAe,iBQuaZT,GAEF8tB,GAAa,EAAKY,SAAShL,GAASuK,gBACtC,EAAK7J,WAAWuK,eAAejL,EAAS1jB,EAAO0tB,GAC/C,EAAKS,WAAWzK,GAChB,EAAKyK,WAAWT,GAChB,EAAK/H,oBAED,IAAIvC,EAAY,CAAEN,aAAc9iB,QAMtB,sBAAhB+V,EACF,SAAOyY,GAKTA,EAAchY,OAAM,eAStB,OAJA5V,KAAKwjB,WAAWwK,sBAAsBlL,GAAUmK,GAChDjtB,KAAKutB,WAAWzK,GAChB9iB,KAAKutB,WAAWT,GAEZ9sB,KAAK6lB,UAAUtT,GAAO0b,mBACxB,GAAOjuB,KAAK8qB,WAAWzD,aAAa,CAClC7f,SAAU+K,EACV+U,aAAc,CAAEtT,KAAMuY,GACtBzlB,QAAO,EACPW,UAAS,EACT8f,wBAAwB,IACvBrP,MAAK,SAACpL,GAQP,OAPA,EAAKohB,gBACHpL,EACAhW,EACAkE,EACA8b,GAEF,EAAK/H,mBACEjY,OAIX9M,KAAK+kB,mBAIL,GAAO,CAAE/Q,KAAMuY,aAGT,YAAA2B,gBAAR,SACEpL,EACAhW,EACA,EAKAggB,G,IAJE3X,EAAA,EAAAA,YACA1N,EAAA,EAAAA,UACAic,EAAA,EAAAA,YAIkB,aAAhBvO,EACFnV,KAAK6rB,SAAS/I,GAAS,WAAM,MAAC,CAC5BqL,QAAS,CAAErhB,OAAQA,EAAOkH,KAAM4F,UAAU,OAG5C5Z,KAAK6kB,UAAUqJ,gBACbphB,EACA9M,KAAK8tB,SAAShL,GAAStb,SACvBC,EACAqlB,EACgB,WAAhBpJ,GAA4C,QAAhBA,IAO3B,YAAA0K,yBAAP,SACEtL,EACA9R,EACAsL,GAHF,WAKE,SAAS+R,EAAOtvB,EAA0BsnB,GACxC,GAAI/J,EAASvd,GACX,IACEud,EAASvd,GAASsnB,GAClB,MAAOxjB,KAQb,OAAO,SACL0gB,EACA4K,GAOA,GAJA,EAAKZ,WAAWzK,GAAS,GAIpBS,EAAL,CAEM,oBAAE2I,EAAA,EAAAA,gBAAiB1kB,EAAA,EAAAA,SAEnB2N,EAAc+W,EAChBA,EAAgBlb,QAAQmE,YACxBnE,EAAQmE,YAGZ,GAAoB,YAAhBA,EAAJ,CAEA,IAAMvB,EAAUkO,EAAyByB,EAAgB1P,eACnDuC,EAAa8V,GAAmBA,EAAgB7V,gBAEhDiY,KACJlY,GACAA,EAAWvC,gBAAkB0P,EAAgB1P,eAGzC0a,EACJvd,EAAQuX,oBACN4F,GAAW5K,EAAgB0C,mBAC5BqI,GAAwBtd,EAAQwd,6BACjB,eAAhBrZ,GACgB,sBAAhBA,EAEF,IAAIvB,GAAY2a,EAAhB,CAIA,IAAME,EAAmBzM,EAAgBuB,EAAgB5M,eAEnD+M,EAA2BwI,GAC5BA,EAAgBlb,QAAQ0S,aACxB1S,EAAQ0S,aACR,OAIL,GAAoB,SAAhBA,GAA0B+K,GAAoBlL,EAAgBrB,aAChE,OAAOmM,EAAO,QAAS,IAAI7L,EAAY,CACrC7L,cAAe4M,EAAgB5M,cAC/BuL,aAAcqB,EAAgBrB,gBAIlC,IACE,IAAIlO,OAAI,EACJ0a,OAAS,EAEb,GAAIP,EAOkB,aAAhBhZ,GAA8C,iBAAhBA,GAChC,EAAK0W,SAAS/I,GAAS,WAAM,MAAC,CAAEqL,QAAS,SAG3Cna,EAAOma,EAAQrhB,OACf4hB,GAAaP,EAAQvU,aAChB,CACL,IAAM1D,EAAYgW,GAAmBA,EAAgB/V,eAC/CwY,EACY,SAAhBjL,IACCxN,GAAaA,EAAUS,iBACtB4M,EAAgB5M,cAEpB,GAAIP,GAAcA,EAAWpC,OAAS2a,EACpC3a,EAAOoC,EAAWpC,KAClB0a,GAAY,MACP,CACL,IAAME,EAAa,EAAK/J,UAAU2G,WAAWlD,KAAK,CAChD/V,MAAO/K,EACPC,UACE8b,EAAgB0C,mBAChB1C,EAAgB9b,UAClB8gB,mBAAmB,EACnBC,YAAY,IAGdxU,EAAO4a,EAAW9hB,OAClB4hB,GAAaE,EAAWhV,UAO5B,IAAMgK,EAAQ8K,KACZ1d,EAAQuX,mBACQ,eAAhBpT,GAGI0Z,EAAwC,CAC5C7a,KAAM4P,EAAQxN,GAAcA,EAAWpC,KAAOA,EAC9CJ,QAAO,EACPC,cAAe0P,EAAgB1P,cAC/B+P,MAAK,GAIa,QAAhBF,GAAyB+K,IAC3BI,EAAgBnY,OAAS6M,EAAgB5M,eAG3C0X,EAAO,OAAQQ,GAEf,MAAO3M,GACPmM,EAAO,QAAS,IAAI7L,EAAY,CAAEN,aAAY,WAiB7C,YAAA2D,UAAP,SAAiBre,GACP,IAAA4jB,EAAA,KAAAA,eAER,IAAKA,EAAezpB,IAAI6F,GAAW,CACjC,IAAMR,EAAQhH,KAAK6kB,UAAU2G,WACvBsD,EAAc9nB,EAAM+nB,kBAAkBvnB,GACtCwnB,EAAU,YACdhoB,EAAMioB,iBAAiBH,IAEnBnH,EAAc3nB,KAAK8qB,WAAWnD,YAAYmH,GAC1C5I,EAAclmB,KAAK8qB,WAAW5E,YAAY8I,GAE1C,EAAa,CACjBxnB,SAAUsnB,EAGVhJ,iBAAkB,YAAiBgJ,GACnCb,mBAAoBjuB,KAAK8qB,WAAW5C,qBAAqB4G,GACzDnH,YAAW,EACXzB,YAAW,EACXgJ,YAAa,YACX,YAAuBJ,KAIrB/d,EAAM,SAACrC,GACPA,IAAQ0c,EAAezpB,IAAI+M,IAC7B0c,EAAeva,IAAInC,EAAK,IAM5BqC,EAAIvJ,GACJuJ,EAAI+d,GACJ/d,EAAI4W,GACJ5W,EAAImV,GAGN,OAAOkF,EAAexpB,IAAI4F,IAGpB,YAAAskB,aAAR,SACEtkB,EACAC,GAEA,kCACKzH,KAAK6lB,UAAUre,GAAU0nB,aACzBznB,IAWA,YAAAgO,WAAP,SACEzE,EACA0R,QAAA,IAAAA,OAAA,GAEA,0CAMA1R,EAAQvJ,UAAYzH,KAAK8rB,aAAa9a,EAAQuB,MAAOvB,EAAQvJ,WAEV,qBAAxCuJ,EAAQwd,8BACjBxd,EAAQwd,6BAA8B,GAGxC,IAAIW,EAAqB,eAAKne,GAE9B,OAAO,IAAIoe,EAA+B,CACxC3M,aAAcziB,KACdgR,QAASme,EACTzM,gBAAiBA,KAId,YAAAnQ,MAAP,SAAgBvB,GAAhB,WAsBE,OAnBE,wBAIF,0CAMI,aAAAA,EAAA,sBAKA,aAAAA,EAAA,iBAIG,IAAIyJ,SAA8B,SAACC,EAASwI,GACjD,IAAMmM,EAAe,EAAK5Z,WAAczE,GAAS,GACjD,EAAKma,oBAAoBta,IAAI,SAASwe,EAAavM,QAAWI,GAC9DmM,EACGviB,SACAoL,KAAKwC,EAASwI,GAOdhL,MAAK,WACJ,SAAKiT,oBAAoBhI,OAAO,SAASkM,EAAavM,gBAKvD,YAAAC,gBAAP,WACE,OAAOnD,OAAO5f,KAAKkrB,cAGd,YAAAoE,iBAAP,SAAwBxM,GACtB9iB,KAAKuvB,4BAA4BzM,GACjC9iB,KAAK+kB,oBAGC,YAAAwK,4BAAR,SAAoCzM,GAClC9iB,KAAKglB,iBAAiBlC,GACtB9iB,KAAKwjB,WAAWc,UAAUxB,GAC1B9iB,KAAKutB,WAAWzK,IAGX,YAAA0M,iBAAP,SAAwB1M,EAAiB2M,GACvCzvB,KAAK6rB,SAAS/I,GAAS,SAAC,GAEtB,OAFwB,EAAA9d,UACd+L,IAAI0e,GACP,CAAEnC,aAAa,OAInB,YAAAF,iBAAP,SACEtK,EACAtb,EACAwJ,GAHF,WAKUmc,EAAA,iBAAAA,OACJA,GAAQA,IAaZ,OAAOntB,KAAK6kB,UAAU2G,WAAWkE,MAAM,CACrCnd,MAAO/K,EACPC,UAAWuJ,EAAQvJ,UACnB+gB,YAAY,EACZxS,eAhBqB,WACrB,IAAIA,EAAiB,KACbkW,EAAA,cAAAA,gBACR,GAAIA,EAAiB,CACnB,IAAM9V,EAAa8V,EAAgB7V,gBAC/BD,IACFJ,EAAiBI,EAAWpC,MAIhC,OAAOgC,GAOPnU,SAAU,SAAAssB,GACR,EAAKtC,SAAS/I,GAAS,WAAM,MAAC,CAAEwK,aAAa,EAAMa,QAAO,UAMzD,YAAAzI,mBAAP,SACE5C,EACAoJ,GAEAlsB,KAAK6rB,SAAS/I,GAAS,WAAM,MAAC,CAAEoJ,gBAAe,OAG1C,YAAA9F,sBAAP,SAA6BtD,GACnB,IAAAqK,EAAA,iBAAAA,OACRntB,KAAK6rB,SAAS/I,GAAS,WAAM,MAAC,CAAEoJ,gBAAiB,SAC7CiB,GAAQA,KAGP,YAAAwC,WAAP,WAOE3vB,KAAKmrB,oBAAoBrQ,SAAQ,SAAAoI,GAC/BA,EAAO,gBAKT,IAAM0M,EAAqB,GAS3B,OARA5vB,KAAKgI,QAAQ8S,SAAQ,SAAC,EAAqBgI,GAAnB,EAAAoJ,iBACD0D,EAAS3tB,KAAK6gB,MAGrC9iB,KAAKwjB,WAAWrjB,MAAMyvB,GACtB5vB,KAAK+qB,cAAc5qB,QAGZH,KAAK6kB,UAAU1kB,SAGjB,YAAA0vB,WAAP,sBAOE,OAAO7vB,KAAK2vB,aAAazX,MAAK,WAC5B,OAAO,EAAK4X,+BAIT,YAAAA,yBAAP,SACEC,GADF,gBACE,IAAAA,OAAA,GAEA,IAAMC,EAA6D,GAqBnE,OAnBAhwB,KAAKgI,QAAQ8S,SAAQ,SAAC,EAAqBgI,G,IAAnBoJ,EAAA,EAAAA,gBACtB,GAAIA,EAAiB,CACnB,IAAM/W,EAAc+W,EAAgBlb,QAAQmE,YAE5C+W,EAAgB5V,mBAEE,eAAhBnB,IACC4a,GAAkC,YAAhB5a,GAEnB6a,EAAwB/tB,KAAKiqB,EAAgB1Z,WAG/C,EAAKqZ,SAAS/I,GAAS,WAAM,MAAC,CAAEqL,QAAS,SACzC,EAAKZ,WAAWzK,OAIpB9iB,KAAK+kB,mBAEEtK,QAAQO,IAAIgV,IAGd,YAAApK,aAAP,SACE9C,EACA9R,EACAsL,GAMA,OAJAtc,KAAKwvB,iBACH1M,EACA9iB,KAAKouB,yBAAyBtL,EAAS9R,EAASsL,IAE3Ctc,KAAKikB,WAAcnB,EAAS9R,IAG9B,YAAAif,WAAP,SACEnN,EACA9R,EACAye,GAWA,OAPAzvB,KAAKwvB,iBAAiB1M,EAAS2M,GAE/BzvB,KAAKikB,WAAcnB,EAAS9R,GAGzB4E,OAAM,eAEFkN,GAGF,YAAAyB,yBAAP,SAAyC,GAAzC,WACEhS,EAAA,EAAAA,MACA4C,EAAA,EAAAA,YACA1N,EAAA,EAAAA,UAEA8K,EAAQvS,KAAK6lB,UAAUtT,GAAO/K,SAC9BC,EAAYzH,KAAK8rB,aAAavZ,EAAO9K,GAErC,IAAMyoB,EAAiB,SAACzoB,GACtB,SAAK+kB,sBACHja,EACA,GACA9K,GACA,GACAuH,KAAI,SAAAlC,GAUJ,GATKqI,GAA+B,aAAhBA,IAClB,EAAK0P,UAAUsL,uBACbrjB,EACAyF,EACA9K,GAEF,EAAKsd,oBAGH,YAAsBjY,GACxB,MAAM,IAAI0V,EAAY,CACpB7L,cAAe7J,EAAO4J,SAI1B,OAAO5J,MAGX,GAAI9M,KAAK6lB,UAAUtT,GAAOuT,iBAAkB,CAC1C,IAAM,EAAoB9lB,KAAK8qB,WAAW9E,qBACxCzT,EACA9K,GACAyQ,KAAKgY,GAEP,OAAO,IAAI3R,GAA2B,SAAAjC,GACpC,IAAI6J,EAA2B,KAK/B,OAJA,EAAkBjO,MAChB,SAAAiC,GAAc,OAAAgM,EAAMhM,EAAWpE,UAAUuG,KACzCA,EAASld,OAEJ,WAAM,OAAA+mB,GAAOA,EAAIpP,kBAI5B,OAAOmZ,EAAezoB,IAGjB,YAAA6c,UAAP,SAAiBxB,GACf9iB,KAAK2rB,qBAAqB7I,GAC1B9iB,KAAK+kB,oBAGC,YAAA4G,qBAAR,SAA6B7I,GAC3B9iB,KAAKuvB,4BAA4BzM,GACjC9iB,KAAKojB,YAAYN,IAGZ,YAAAM,YAAP,SAAmBN,GAMjB9iB,KAAKmrB,oBAAoBhI,OAAO,SAASL,GACzC9iB,KAAKmrB,oBAAoBhI,OAAO,gBAAgBL,GAChD9iB,KAAK8tB,SAAShL,GAAS3a,cAAc2S,SAAQ,SAAAhT,GAAK,OAAAA,EAAEiP,iBACpD/W,KAAKgI,QAAQmb,OAAOL,IAGf,YAAAsN,sBAAP,SACElE,EACA1D,QAAA,IAAAA,OAAA,GAKM,gBAAE/gB,EAAA,EAAAA,UAAW8K,EAAA,EAAAA,MAAO4C,EAAA,EAAAA,YAAaoT,EAAA,EAAAA,kBACjCnS,EAAa8V,EAAgB7V,gBAC3B8X,EAAA,yBAAAA,QAER,GAAIA,GAAWA,EAAQvU,SACrB,MAAO,CAAE5F,KAAMma,EAAQrhB,OAAQ2J,SAAS,GAG1C,GAAoB,aAAhBtB,GAA8C,iBAAhBA,EAChC,MAAO,CAAEnB,UAAM1I,EAAWmL,SAAS,GAG/B,sC,uFAAE3J,EAAA,EAAAA,OAAQ8M,EAAA,EAAAA,SAQhB,MAAO,CACL5F,KAAO4F,GAAY2O,EAAqBzb,OAAS,EACjD2J,SAAUmD,IAIP,YAAAyW,2BAAP,SACEC,GAMA,IAAIpE,EACJ,GAAmC,kBAAxBoE,EAAkC,CACnC,uBAAApE,gBAGR,kBAIAA,EAAkBqE,OAElBrE,EAAkBoE,EAGd,gBAAE7oB,EAAA,EAAAA,UAAW8K,EAAA,EAAAA,MACnB,MAAO,CACLyD,eAAgBhW,KAAKowB,sBAAsBlE,GAAiB,GAAOlY,KACnEvM,UAAS,EACTD,SAAU+K,IAIP,YAAAwS,iBAAP,sBACE/kB,KAAK2qB,cACL3qB,KAAKgI,QAAQ8S,SAAQ,SAACzZ,EAAMmvB,GACtBnvB,EAAKisB,aACPjsB,EAAK2D,UAAU8V,SAAQ,SAAA2U,GAGjBA,GACFA,EAAS,EAAKjM,WAAW5hB,IAAI4uB,GAAKnvB,EAAK8sB,gBAO1C,YAAApI,cAAP,WACE,OAAO/lB,KAAK8qB,YAQN,YAAA0B,sBAAR,SACEja,EACAzL,EACAW,EACAgpB,GAJF,IAMMtW,EANN,YAIE,IAAAsW,MAAyBzwB,KAAK0qB,oBAItB,IAAAxE,EAAA,kBAAAA,YACR,GAAIA,EAAa,CACT,IAAE,EAAF,KAAEmF,wBAAyBpP,EAA3B,KAA2BA,KAE3BhU,EAAY,CAChBsK,MAAO2T,EACPze,UAAS,EACTP,cAAe,YAAiBgf,SAAgB,EAChDpf,QAAS9G,KAAK4nB,eAAc,2BACvB9gB,GAAO,CACV4pB,YAAaD,MAMjB,GAFA3pB,EAAUmB,EAAUnB,QAEhB2pB,EAAe,CACjB,IAAM,EAAc,EAAwB7uB,IAAIskB,IAAgB,IAAIjf,IACpE,EAAwB4J,IAAIqV,EAAa,GAEzC,IAAM,EAAU/K,KAAKC,UAAU3T,GAG/B,KAFA0S,EAAa,EAAYvY,IAAI,IAEZ,CACf,EAAYiP,IACV,EACAsJ,EAAaqQ,EACX,YAAQvO,EAAMhU,KAIlB,IAAM0J,EAAU,WACd,EAAYwR,OAAO,GACd,EAAYjiB,MAAM,EAAwBiiB,OAAO+C,GACtD,EAAWnP,eAGP,EAAaoD,EAAWpE,UAAU,CACtCzU,KAAMqQ,EACNvS,MAAOuS,EACPiI,SAAUjI,UAKdwI,EAAaqQ,EAAU,YAAQvO,EAAMhU,SAGvCkS,EAAaoE,EAAWxB,GAAG,CAAE/I,KAAM,KACnClN,EAAU9G,KAAK4nB,eAAe9gB,GAGxB,IAAA6gB,EAAA,kBAAAA,YAYR,OAXIA,IACFxN,EDjnCN,SACEA,EACAtH,GAEA,OAAO,IAAI0L,GAAc,SAAAjC,GACf,QAAAhb,KAAM,IAAAlC,MAAO,IAAAwa,SACjB+W,EAAkB,EAClBC,GAAY,EAEV3T,EAAuB,CAC3B3b,KAAA,SAAKE,KACDmvB,EACF,IAAIlW,SAAQ,SAAAC,GACVA,EAAQ7H,EAAMrR,OACb0W,MACD,SAAApL,KACI6jB,EACF,GAAQ,EAAKjwB,KAAK4b,EAAUxP,GAC5B8jB,GAAa3T,EAAQrD,cAEvB,SAAA/W,KACI8tB,EACF,GAAS,EAAMjwB,KAAK4b,EAAUzZ,OAIpCzD,MAAK,SAACyD,GACJ,GAAS,EAAMnC,KAAK4b,EAAUzZ,IAEhC+W,SAAQ,WACNgX,GAAY,EACPD,GACH,GAAY,EAASjwB,KAAK4b,KAK1B6J,EAAMhM,EAAWpE,UAAUkH,GACjC,OAAO,WAAM,OAAAkJ,EAAIpP,kBC2kCF8Z,CAAS1W,GAAY,SAAArN,GAChC,OAAO,EAAKge,WAAWzD,aAAa,CAClC7f,SAAUmgB,EACVL,aAAcxa,EACdhG,QAAO,EACPW,UAAS,QAKR0S,GAMD,YAAA0T,aAAR,SAAwB,GAAxB,IAcMgB,EACAiC,EAfN,OACE5D,EAAA,EAAAA,UACApK,EAAA,EAAAA,QACAtb,EAAA,EAAAA,SACAwJ,EAAA,EAAAA,QACA8b,EAAA,EAAAA,oBAQQrlB,EAAA,EAAAA,UAAW,IAAAic,mBAAA,IAAc,EAAd,SAAsBvO,EAAA,EAAAA,YAIzC,OAAO,IAAIsF,SAA8B,SAACC,EAASwI,GACjD,IAAM/I,EAAa,EAAKqS,sBACtBhlB,EACAwJ,EAAQlK,QACRW,GAGIspB,EAAS,gBAAgBjO,EAC/B,EAAKqI,oBAAoBta,IAAIkgB,EAAQ7N,GAErC,IAAMvR,EAAU,WACd,EAAKwZ,oBAAoBhI,OAAO4N,GAChC,EAAKlF,SAAS/I,GAAS,SAAC,GAAE,EAAA3a,cACVgb,OAAOtN,OAInBA,EAAesE,EAAWnL,KAAI,SAAClC,GAqBnC,GApBIogB,GAAa,EAAKY,SAAShL,GAASuK,gBACtC,EAAKa,gBACHpL,EACAhW,EACAkE,EACA8b,GAGF,EAAKtJ,WAAW0K,gBACdpL,EACAhW,EACAggB,GAGF,EAAKS,WAAWzK,GAChB,EAAKyK,WAAWT,GAEhB,EAAK/H,oBAGa,SAAhBrB,GAA0B1B,EAAgBlV,EAAO4J,QACnD,OAAOwM,EAAO,IAAIV,EAAY,CAC5B7L,cAAe7J,EAAO4J,UAQ1B,GAJoB,QAAhBgN,IACFoN,EAAkBhkB,EAAO4J,QAGvBoW,GAAuC,aAAhB3X,EAGzB0Z,EAAkB/hB,EAAOkH,SACpB,CAEC,mC,yDAAE,IAAAlH,QAAQ,EAAA8M,UAOA5I,EAAQuX,qBACtBsG,EAAkB,OAGrB9Y,UAAU,CACX3W,MAAA,SAAM,GACJuS,IACAuR,EAAO,IAGTtJ,SAAQ,WACNjI,IACA+I,EAAQ,CACN1G,KAAM6a,EACNnY,OAAQoa,EACRld,SAAS,EACTC,cAAegO,EAAc/N,MAC7B8P,OAAO,OAKb,EAAKiI,SAAS/I,GAAS,SAAC,GAAE,EAAA3a,cACV4I,IAAI8E,UAKhB,YAAAiY,SAAR,SAAiBhL,GACf,OACE9iB,KAAKgI,QAAQpG,IAAIkhB,IAAY,CAC3B9d,UAAW,IAAI8L,IACfwc,aAAa,EACb9lB,SAAU,KACV2mB,QAAS,KACTd,cAAe,EACfnB,gBAAiB,KACjB/jB,cAAe,IAAI2I,MAKjB,YAAA+a,SAAR,SACE/I,EACAqJ,GAEA,IAAMtf,EAAO7M,KAAK8tB,SAAShL,GACrBkO,EAAU,OAAH,IAAG,CAAH,eAAQnkB,GAASsf,EAAQtf,IACtC7M,KAAKgI,QAAQ6I,IAAIiS,EAASkO,IAGpB,YAAAzD,WAAR,SACEzK,EACAwK,QAAA,IAAAA,OAAA,GAEIxK,GACF9iB,KAAK6rB,SAAS/I,GAAS,WAAM,MAAC,CAAEwK,YAAW,OAIvC,YAAA1F,eAAR,SAAuB9gB,QAAA,IAAAA,MAAA,IACrB,IAAMmqB,EAAajxB,KAAK8qB,WAAWlD,eAAe9gB,GAClD,kCACKmqB,GAAU,CACbpG,gBAAiB7qB,KAAK6qB,mBAInB,YAAAqG,cAAP,SAAqBpO,GACnB,IAAMvQ,EAAQvS,KAAKwjB,WAAW5hB,IAAIkhB,GAElC,OACEvQ,GACAA,EAAMsB,gBAAkBgO,EAAc/N,OACtCvB,EAAMsB,gBAAkBgO,EAAcziB,OAWnC,YAAA8lB,kBAAP,SACElU,EACA8R,EACA2M,GAHF,WAKUzc,EAAA,EAAAA,aAQR,GANA,mBAMKhT,KAAK4qB,QAAS,CACjB,IAAIvpB,EAAOrB,KAAKsrB,qBAAqB1pB,IAAIkhB,GACpCzhB,GACHrB,KAAKsrB,qBAAqBza,IAAIiS,EAAUzhB,EAAO,IAGjDA,EAAK8vB,SAAWne,EAChB3R,EAAK2P,QAAO,2BACPA,GAAO,CACVmE,YAAa,iBAGf,IAAM,EAAa,WACjB,IAAM9T,EAAO,EAAKiqB,qBAAqB1pB,IAAIkhB,GACvCzhB,IACE,EAAK6vB,cAAcpO,GACrB,IAEA,EAAKmB,WAAWnB,EAASzhB,EAAK2P,QAASiR,EAAUyL,MAAMxV,KACrD,EACA,KAMF,EAAO,WACX,IAAM7W,EAAO,EAAKiqB,qBAAqB1pB,IAAIkhB,GACvCzhB,IACFyB,aAAazB,EAAKiC,SAClBjC,EAAKiC,QAAUV,WAAW,EAAYvB,EAAK8vB,YAI3C1B,GACFzvB,KAAKwvB,iBAAiB1M,EAAS2M,GAGjC,IAGF,OAAO3M,GAGF,YAAAkC,iBAAP,SAAwBlC,GACtB9iB,KAAKsrB,qBAAqBnI,OAAOL,IAErC,EAt0CA,GCjCA,aAGE,WAAYsO,GACVpxB,KAAKgH,MAAQoqB,EAgLjB,OA7KS,YAAA5F,SAAP,WACE,OAAOxrB,KAAKgH,OAGP,YAAAknB,gBAAP,SACEphB,EACAtF,EACAC,EACAqlB,EACAuE,QAAA,IAAAA,OAAA,GAEA,IAAIC,GAAmB,YAAsBxkB,GACzCukB,GAAgB,YAAsBvkB,IAAWA,EAAOkH,OAC1Dsd,GAAkB,IAEfxE,GAAuBwE,GAC1BtxB,KAAKgH,MAAMuqB,MAAM,CACfzkB,OAAQA,EAAOkH,KACfwd,OAAQ,aACRjf,MAAO/K,EACPC,UAAWA,KAKV,YAAA0oB,uBAAP,SACErjB,EACAtF,EACAC,GAIK,YAAsBqF,IACzB9M,KAAKgH,MAAMuqB,MAAM,CACfzkB,OAAQA,EAAOkH,KACfwd,OAAQ,oBACRjf,MAAO/K,EACPC,UAAWA,KAKV,YAAA2kB,iBAAP,SAAwB9T,GAAxB,IASQ,EATR,OAQMA,EAASE,qBAGT,EADyC,oBAAhCF,EAASE,mBACLF,EAASE,mBAAmBF,EAAS7Q,WAErC6Q,EAASE,mBAGxBxY,KAAKgH,MAAMyqB,6BAA4B,SAAAC,GACrC,IAAMC,EAAO,EAAK3qB,MAClB,EAAKA,MAAQ0qB,EAEb,IACE,EAAK/K,mBAAmB,CACtB5O,WAAYO,EAASP,WACrBjL,OAAQ,CAAEkH,KAAM,GAChBxM,SAAU8Q,EAAS9Q,SACnBC,UAAW6Q,EAAS7Q,UACpBmkB,cAAetT,EAASsT,cACxBnT,OAAQH,EAASG,SAPrB,QAUE,EAAKzR,MAAQ2qB,KAEdrZ,EAASP,cAIT,YAAA4O,mBAAP,SAA0BrO,GAA1B,WASE,IAAK,YAAsBA,EAASxL,QAAS,CAC3C,IAAM,EAAoC,CAAC,CACzCA,OAAQwL,EAASxL,OAAOkH,KACxBwd,OAAQ,gBACRjf,MAAO+F,EAAS9Q,SAChBC,UAAW6Q,EAAS7Q,YAGd,IAAAmkB,cACJ,GACFjsB,OAAOmB,KAAK,GAAega,SAAQ,SAAA0V,GAC3B,WAAEje,EAAA,EAAAA,MAAO4Z,EAAA,EAAAA,QAGT,gB,4EAAE,IAAArf,OAOR,GAPoC,EAAA8M,SAOtB,CAEZ,IAAMgY,EAAkB,aAAsB,WAC5C,OAAAzF,EAAQ0F,EAAoB,CAC1BC,eAAgBxZ,EAASxL,OACzBmW,UAAW,YAAiB1Q,EAAM/K,gBAAa8D,EAC/CymB,eAAgBxf,EAAM9K,eAKtBmqB,GACF,EAAY3vB,KAAK,CACf6K,OAAQ8kB,EACRJ,OAAQ,aACRjf,MAAOA,EAAM/K,SACbC,UAAW8K,EAAM9K,gBAO3BzH,KAAKgH,MAAMgrB,oBAAmB,SAAAN,GAC5B,EAAY5W,SAAQ,SAAAyW,GAAS,OAAAG,EAAEH,MAAMA,MAK7B,IAAA9Y,EAAA,EAAAA,OACJA,GACF,aAAsB,WAAM,OAAAA,EAAOiZ,EAAGpZ,EAASxL,gBAMhD,YAAA2f,qBAAP,SAA4B,G,IAC1B1U,EAAA,EAAAA,WACA,EAAAS,oBAMExY,KAAKgH,MAAMirB,iBAAiBla,IAIzB,YAAA+M,sBAAP,SACEtd,EACAC,EACAqc,GAEA9jB,KAAKgH,MAAMuqB,MAAM,CACfzkB,OAAQgX,EACR0N,OAAQ,aACR/pB,UAAS,EACT8K,MAAO/K,KAIJ,YAAArH,MAAP,WACE,OAAOH,KAAKgH,MAAM7G,SAEtB,EApLA,GCuCA,aAkDE,WAAY6Q,GAAZ,WA1CO,KAAAkhB,eAAiC,GAIhC,KAAAC,oBAAiD,GACjD,KAAAC,oBAAiD,GAuCrD,IAAAprB,EAAA,EAAAA,MACA,IAAA4jB,eAAA,IAAU,GAAV,EACA,IAAAyH,0BAAA,IAAqB,EAArB,IACAC,EAAA,EAAAA,kBACA,IAAA5H,0BAAA,IAAqB,GAArB,EACAwH,EAAA,EAAAA,eACA,IAAA/M,8BAAA,IAAyB,GAAzB,EACA2B,EAAA,EAAAA,UACAyL,EAAA,EAAAA,SACAxL,EAAA,EAAAA,gBACA,IAAAvoB,KACA,IAAA6F,QAGI4X,EAAA,EAAAA,KAQN,IAJKA,GAAQ6K,IACX7K,EAAO,IAAWkB,UAGflB,IAASjV,EACZ,MAAM,WAQRhH,KAAKic,KAAOA,EACZjc,KAAKgH,MAAQA,EACbhH,KAAKumB,MAAQ,IAAIiM,EAAUxrB,GAC3BhH,KAAK8U,sBAAwB8V,GAAWyH,EAAqB,EAC7DryB,KAAK0qB,mBAAqBA,EAC1B1qB,KAAKkyB,eAAiBA,GAAkB,GACxClyB,KAAKuyB,SAAWA,EAEZF,GACFzvB,YACE,WAAM,OAAC,EAAKkS,uBAAwB,IACpCud,GAIJryB,KAAKyV,WAAazV,KAAKyV,WAAWhB,KAAKzU,MACvCA,KAAKuS,MAAQvS,KAAKuS,MAAMkC,KAAKzU,MAC7BA,KAAKiY,OAASjY,KAAKiY,OAAOxD,KAAKzU,MAC/BA,KAAK6vB,WAAa7vB,KAAK6vB,WAAWpb,KAAKzU,MACvCA,KAAK8vB,yBAA2B9vB,KAAK8vB,yBAAyBrb,KAAKzU,MAUpC,qBAAtBsyB,IAEHA,GAAuC,qBAAXG,UAE/BA,OAAeC,kBAAoB1yB,MAkCtCA,KAAKqE,QCrNc,QDuNnBrE,KAAK8qB,WAAa,IAAIS,EAAW,CAC/BvkB,MAAK,EACLL,OAAQ3G,KACR8mB,UAAS,EACTC,gBAAe,IAGjB/mB,KAAKyiB,aAAe,IAAIkQ,EAAa,CACnC1W,KAAMjc,KAAKic,KACXsK,MAAOvmB,KAAKumB,MACZmE,mBAAkB,EAClBE,QAAO,EACPC,gBAAiB,CACfrsB,KAAMo0B,EACNvuB,QAASwuB,GAEX/H,WAAY9qB,KAAK8qB,WACjB3F,uBAAsB,EACtBwF,YAAa,WACP,EAAKmI,gBACP,EAAKA,eAAe,CAClBC,OAAQ,GACRC,MAAO,CACLhrB,QAAS,EAAKya,aAAae,WAAWgD,WACtCte,UAAW,EAAKua,aAAasI,cAAcvE,YAE7CyM,0BAA2B,EAAKjsB,MAAMksB,SAAQ,QAyV1D,OA9US,YAAAzH,KAAP,WACEzrB,KAAKyiB,aAAagJ,QAsBb,YAAAhW,WAAP,SACEzE,GAkBA,OAhBIhR,KAAKkyB,eAAezc,aACtBzE,EAAU,2BACLhR,KAAKkyB,eAAezc,YACpBzE,KAMLhR,KAAK8U,uBACoB,iBAAxB9D,EAAQmE,aACiB,sBAAxBnE,EAAQmE,cAEVnE,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAEmE,YAAa,iBAGhCnV,KAAKyiB,aAAahN,WAA0BzE,IAY9C,YAAAuB,MAAP,SACEvB,GAoBA,OAlBIhR,KAAKkyB,eAAe3f,QACtBvB,EAAU,2BAAKhR,KAAKkyB,eAAe3f,OAAUvB,IAK/C,mDAQIhR,KAAK8U,uBAAiD,iBAAxB9D,EAAQmE,cACxCnE,EAAU,OAAH,IAAG,CAAH,eAAQA,GAAO,CAAEmE,YAAa,iBAGhCnV,KAAKyiB,aAAalQ,MAASvB,IAU7B,YAAAiH,OAAP,SACEjH,GASA,OAPIhR,KAAKkyB,eAAeja,SACtBjH,EAAU,2BACLhR,KAAKkyB,eAAeja,QACpBjH,IAIAhR,KAAKyiB,aAAaxK,OAAUjH,IAO9B,YAAA+E,UAAP,SACE/E,GAEA,OAAOhR,KAAKyiB,aAAa8B,yBAA4BvT,IAYhD,YAAAmiB,UAAP,SACEniB,EACAwX,GAEA,YAFA,IAAAA,OAAA,GAEOxoB,KAAKgH,MAAMmsB,UAAyBniB,EAASwX,IAiB/C,YAAA4K,aAAP,SACEpiB,EACAwX,GAEA,YAFA,IAAAA,OAAA,GAEOxoB,KAAKgH,MAAMosB,aAA4BpiB,EAASwX,IAQlD,YAAA6K,WAAP,SACEriB,GAEA,IAAMlE,EAAS9M,KAAKgH,MAAMqsB,WAA8BriB,GAExD,OADAhR,KAAKyiB,aAAasC,mBACXjY,GAcF,YAAAwmB,cAAP,SACEtiB,GAEA,IAAMlE,EAAS9M,KAAKgH,MAAMssB,cAAiCtiB,GAE3D,OADAhR,KAAKyiB,aAAasC,mBACXjY,GAaF,YAAAymB,UAAP,SACEviB,GAEA,IAAMlE,EAAS9M,KAAKgH,MAAMusB,UAAiBviB,GAE3C,OADAhR,KAAKyiB,aAAasC,mBACXjY,GAGF,YAAA0mB,wBAAP,SAA+BC,GAC7BzzB,KAAK8yB,eAAiBW,GAGjB,YAAAC,aAAP,SAAoBC,GAClB,OAAO,YAAQ3zB,KAAKic,KAAM0X,IAMrB,YAAAC,iBAAP,WAKE,OAAO5zB,KAAKyiB,cAmBP,YAAAoN,WAAP,sBACE,OAAOpV,QAAQC,UACZxC,MAAK,WAAM,SAAKuK,aAAakN,gBAC7BzX,MAAK,WAAM,OAAAuC,QAAQO,IAAI,EAAKmX,oBAAoBnjB,KAAI,SAAA6kB,GAAM,OAAAA,WAC1D3b,MAAK,WAAM,SAAK4X,+BAOd,YAAAH,WAAP,sBACE,OAAOlV,QAAQC,UACZxC,MAAK,WAAM,SAAKuK,aAAakN,gBAC7BzX,MAAK,WAAM,OAAAuC,QAAQO,IAAI,EAAKoX,oBAAoBpjB,KAAI,SAAA6kB,GAAM,OAAAA,YAQxD,YAAAC,aAAP,SAAoBL,GAApB,WAEE,OADAzzB,KAAKmyB,oBAAoBlwB,KAAKwxB,GACvB,WACL,EAAKtB,oBAAsB,EAAKA,oBAAoBtqB,QAAO,SAAA6pB,GAAK,OAAAA,IAAM+B,OASnE,YAAAM,aAAP,SAAoBN,GAApB,WAEE,OADAzzB,KAAKoyB,oBAAoBnwB,KAAKwxB,GACvB,WACL,EAAKrB,oBAAsB,EAAKA,oBAAoBvqB,QAAO,SAAA6pB,GAAK,OAAAA,IAAM+B,OAgBnE,YAAA3D,yBAAP,SACEC,GAEA,OAAO/vB,KAAKyiB,aAAaqN,yBAAyBC,IAM7C,YAAAmD,QAAP,SAAe1K,GACb,OAAOxoB,KAAKgH,MAAMksB,QAAQ1K,IAUrB,YAAAwL,QAAP,SAAeC,GACb,OAAOj0B,KAAKgH,MAAMgtB,QAAQC,IAMrB,YAAAjN,aAAP,SAAoBF,GAClB9mB,KAAK8qB,WAAW9D,aAAaF,IAMxB,YAAAK,aAAP,SAAoBL,GAClB9mB,KAAK8qB,WAAW3D,aAAaL,IAMxB,YAAAM,aAAP,WACE,OAAOpnB,KAAK8qB,WAAW1D,gBAMlB,YAAA8M,6BAAP,SAAoCnN,GAClC/mB,KAAK8qB,WAAW7D,mBAAmBF,IAEvC,EA3gBA,I,iCE/DA,0KAgBA,IAAIzhB,EAAgB,SAASC,EAAGhF,GAI5B,OAHA+E,EAAgB3F,OAAOvB,gBAClB,CAAEoH,UAAW,cAAgBxB,OAAS,SAAUuB,EAAGhF,GAAKgF,EAAEC,UAAYjF,IACvE,SAAUgF,EAAGhF,GAAK,IAAK,IAAIkF,KAAKlF,EAAOA,EAAEV,eAAe4F,KAAIF,EAAEE,GAAKlF,EAAEkF,MACpDF,EAAGhF,IAGrB,SAASmF,EAAUH,EAAGhF,GAEzB,SAASoF,IAAO3F,KAAK4F,YAAcL,EADnCD,EAAcC,EAAGhF,GAEjBgF,EAAE7G,UAAkB,OAAN6B,EAAaZ,OAAOkG,OAAOtF,IAAMoF,EAAGjH,UAAY6B,EAAE7B,UAAW,IAAIiH,GAG5E,IAAIG,EAAW,WAQlB,OAPAA,EAAWnG,OAAOoG,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGhC,EAAI,EAAGiC,EAAIhH,UAAUkB,OAAQ6D,EAAIiC,EAAGjC,IAE5C,IAAK,IAAIwB,KADTQ,EAAI/G,UAAU+E,GACOtE,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,KAAIO,EAAEP,GAAKQ,EAAER,IAE9E,OAAOO,IAEK/G,MAAMe,KAAMd,YA8BzB,SAASi1B,EAAUC,EAASC,EAAYC,EAAGC,GAC9C,OAAO,IAAKD,IAAMA,EAAI7Z,WAAU,SAAUC,EAASwI,GAC/C,SAASsR,EAAUhzB,GAAS,IAAMizB,EAAKF,EAAUjzB,KAAKE,IAAW,MAAOqB,GAAKqgB,EAAOrgB,IACpF,SAAS6xB,EAASlzB,GAAS,IAAMizB,EAAKF,EAAS,MAAU/yB,IAAW,MAAOqB,GAAKqgB,EAAOrgB,IACvF,SAAS4xB,EAAK3nB,GAAUA,EAAOvL,KAAOmZ,EAAQ5N,EAAOtL,OAAS,IAAI8yB,GAAE,SAAU5Z,GAAWA,EAAQ5N,EAAOtL,UAAW0W,KAAKsc,EAAWE,GACnID,GAAMF,EAAYA,EAAUt1B,MAAMm1B,EAASC,GAAc,KAAK/yB,WAI/D,SAASqzB,EAAYP,EAASzkB,GACjC,IAAsG4L,EAAGgC,EAAGvX,EAAG4uB,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAP/uB,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOgvB,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEtzB,KAAM4zB,EAAK,GAAI,MAASA,EAAK,GAAI,OAAUA,EAAK,IAAwB,oBAAX7V,SAA0BuV,EAAEvV,OAAOC,UAAY,WAAa,OAAOtf,OAAU40B,EACvJ,SAASM,EAAKhvB,GAAK,OAAO,SAAUivB,GAAK,OACzC,SAActY,GACV,GAAItB,EAAG,MAAM,IAAIO,UAAU,mCAC3B,KAAO+Y,GAAG,IACN,GAAItZ,EAAI,EAAGgC,IAAMvX,EAAY,EAAR6W,EAAG,GAASU,EAAC,OAAaV,EAAG,GAAKU,EAAC,SAAevX,EAAIuX,EAAC,SAAevX,EAAEtF,KAAK6c,GAAI,GAAKA,EAAEjc,SAAW0E,EAAIA,EAAEtF,KAAK6c,EAAGV,EAAG,KAAKtb,KAAM,OAAOyE,EAE3J,OADIuX,EAAI,EAAGvX,IAAG6W,EAAK,CAAS,EAARA,EAAG,GAAQ7W,EAAExE,QACzBqb,EAAG,IACP,KAAK,EAAG,KAAK,EAAG7W,EAAI6W,EAAI,MACxB,KAAK,EAAc,OAAXgY,EAAEC,QAAgB,CAAEtzB,MAAOqb,EAAG,GAAItb,MAAM,GAChD,KAAK,EAAGszB,EAAEC,QAASvX,EAAIV,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKgY,EAAEI,IAAI/yB,MAAO2yB,EAAEG,KAAK9yB,MAAO,SACxC,QACI,KAAkB8D,GAAZA,EAAI6uB,EAAEG,MAAY50B,OAAS,GAAK4F,EAAEA,EAAE5F,OAAS,MAAkB,IAAVyc,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEgY,EAAI,EAAG,SACjG,GAAc,IAAVhY,EAAG,MAAc7W,GAAM6W,EAAG,GAAK7W,EAAE,IAAM6W,EAAG,GAAK7W,EAAE,IAAM,CAAE6uB,EAAEC,MAAQjY,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYgY,EAAEC,MAAQ9uB,EAAE,GAAI,CAAE6uB,EAAEC,MAAQ9uB,EAAE,GAAIA,EAAI6W,EAAI,MAC7D,GAAI7W,GAAK6uB,EAAEC,MAAQ9uB,EAAE,GAAI,CAAE6uB,EAAEC,MAAQ9uB,EAAE,GAAI6uB,EAAEI,IAAIhzB,KAAK4a,GAAK,MACvD7W,EAAE,IAAI6uB,EAAEI,IAAI/yB,MAChB2yB,EAAEG,KAAK9yB,MAAO,SAEtB2a,EAAKlN,EAAKjP,KAAK0zB,EAASS,GAC1B,MAAOhyB,GAAKga,EAAK,CAAC,EAAGha,GAAI0a,EAAI,EAjBrB,QAiBoChC,EAAIvV,EAAI,EACtD,GAAY,EAAR6W,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAErb,MAAOqb,EAAG,GAAKA,EAAG,QAAK,EAAQtb,MAAM,GArB9BkzB,CAAK,CAACvuB,EAAGivB,MA+DtD,SAASC,IACZ,IAAK,IAAInvB,EAAI,EAAGhC,EAAI,EAAGoxB,EAAKn2B,UAAUkB,OAAQ6D,EAAIoxB,EAAIpxB,IAAKgC,GAAK/G,UAAU+E,GAAG7D,OACxE,IAAIk1B,EAAItxB,MAAMiC,GAAIsG,EAAI,EAA3B,IAA8BtI,EAAI,EAAGA,EAAIoxB,EAAIpxB,IACzC,IAAK,IAAI3D,EAAIpB,UAAU+E,GAAIsxB,EAAI,EAAGC,EAAKl1B,EAAEF,OAAQm1B,EAAIC,EAAID,IAAKhpB,IAC1D+oB,EAAE/oB,GAAKjM,EAAEi1B,GACjB,OAAOD,I,iCCnJX,sGAgBA,IAAIhwB,EAAgB,SAASC,EAAGhF,GAI5B,OAHA+E,EAAgB3F,OAAOvB,gBAClB,CAAEoH,UAAW,cAAgBxB,OAAS,SAAUuB,EAAGhF,GAAKgF,EAAEC,UAAYjF,IACvE,SAAUgF,EAAGhF,GAAK,IAAK,IAAIkF,KAAKlF,EAAOA,EAAEV,eAAe4F,KAAIF,EAAEE,GAAKlF,EAAEkF,MACpDF,EAAGhF,IAGrB,SAASmF,EAAUH,EAAGhF,GAEzB,SAASoF,IAAO3F,KAAK4F,YAAcL,EADnCD,EAAcC,EAAGhF,GAEjBgF,EAAE7G,UAAkB,OAAN6B,EAAaZ,OAAOkG,OAAOtF,IAAMoF,EAAGjH,UAAY6B,EAAE7B,UAAW,IAAIiH,GAG5E,IAAIG,EAAW,WAQlB,OAPAA,EAAWnG,OAAOoG,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGhC,EAAI,EAAGiC,EAAIhH,UAAUkB,OAAQ6D,EAAIiC,EAAGjC,IAE5C,IAAK,IAAIwB,KADTQ,EAAI/G,UAAU+E,GACOtE,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,KAAIO,EAAEP,GAAKQ,EAAER,IAE9E,OAAOO,IAEK/G,MAAMe,KAAMd,YAyGzB,SAASk2B,IACZ,IAAK,IAAInvB,EAAI,EAAGhC,EAAI,EAAGoxB,EAAKn2B,UAAUkB,OAAQ6D,EAAIoxB,EAAIpxB,IAAKgC,GAAK/G,UAAU+E,GAAG7D,OACxE,IAAIk1B,EAAItxB,MAAMiC,GAAIsG,EAAI,EAA3B,IAA8BtI,EAAI,EAAGA,EAAIoxB,EAAIpxB,IACzC,IAAK,IAAI3D,EAAIpB,UAAU+E,GAAIsxB,EAAI,EAAGC,EAAKl1B,EAAEF,OAAQm1B,EAAIC,EAAID,IAAKhpB,IAC1D+oB,EAAE/oB,GAAKjM,EAAEi1B,GACjB,OAAOD,I,oBCnJXhzB,EAAOC,QAAUyL,EAAQ,KAAuBuQ,Y,iCCEhD5e,OAAO8c,eAAela,EAAS,aAAc,CAC3Cf,OAAO,IAGT,IAAIi0B,EAAe,WAAc,SAAS3nB,EAAiBiR,EAAQ3E,GAAS,IAAK,IAAInW,EAAI,EAAGA,EAAImW,EAAMha,OAAQ6D,IAAK,CAAE,IAAIyxB,EAAatb,EAAMnW,GAAIyxB,EAAWhZ,WAAagZ,EAAWhZ,aAAc,EAAOgZ,EAAWC,cAAe,EAAU,UAAWD,IAAYA,EAAWE,UAAW,GAAMj2B,OAAO8c,eAAesC,EAAQ2W,EAAWz0B,IAAKy0B,IAAiB,OAAO,SAAUG,EAAaC,EAAYC,GAAiJ,OAA9HD,GAAYhoB,EAAiB+nB,EAAYn3B,UAAWo3B,GAAiBC,GAAajoB,EAAiB+nB,EAAaE,GAAqBF,GAA7gB,GAEnB,SAASG,EAAgBC,EAAUJ,GAAe,KAAMI,aAAoBJ,GAAgB,MAAM,IAAI/Z,UAAU,qCAIhH,IAAIoa,EAAa,WACf,MAAyB,oBAAX7W,QAEZ8W,EAAY,SAAU33B,GACxB,OAAO03B,KAAgB9oB,QAAQiS,OAAO7gB,KAEpC43B,EAAY,SAAU53B,GACxB,OAAO23B,EAAU33B,GAAQ6gB,OAAO7gB,GAAQ,KAAOA,GAG7C03B,MAAiBC,EAAU,gBAC7B9W,OAAOlF,WAAakF,OAAO,eAG7B,IAAIgX,EAAiBD,EAAU,YAC3BE,EAAmBF,EAAU,cAC7BG,EAAgBH,EAAU,WAI9B,SAASI,EAAUpX,EAAKne,GACtB,IAAIO,EAAQ4d,EAAIne,GAEhB,GAAa,MAATO,EAAJ,CAEA,GAAqB,oBAAVA,EAAsB,MAAM,IAAIsa,UAAUta,EAAQ,sBAE7D,OAAOA,GAGT,SAASi1B,EAAWrX,GAClB,IAAIsX,EAAOtX,EAAIxZ,YAOf,YANa0F,IAATorB,GAEW,QADbA,EAAOA,EAAKH,MAEVG,OAAOprB,QAGKA,IAATorB,EAAqBA,EAAOnY,EAGrC,SAASoY,EAAa7uB,GACpB,OAAOA,aAAayW,EAGtB,SAASqY,EAAgB/zB,GACnB+zB,EAAgBC,IAClBD,EAAgBC,IAAIh0B,GAEpBD,YAAW,WACT,MAAMC,KAKZ,SAASi0B,EAAQjD,GACfpZ,QAAQC,UAAUxC,MAAK,WACrB,IACE2b,IACA,MAAOhxB,GACP+zB,EAAgB/zB,OAKtB,SAASk0B,EAAoBlhB,GAC3B,IAAIlE,EAAUkE,EAAamhB,SAC3B,QAAgB1rB,IAAZqG,IAEJkE,EAAamhB,cAAW1rB,EAEnBqG,GAIL,IACE,GAAuB,oBAAZA,EACTA,QACK,CACL,IAAIoF,EAAcyf,EAAU7kB,EAAS,eACjCoF,GACFA,EAAYrW,KAAKiR,IAGrB,MAAO9O,GACP+zB,EAAgB/zB,IAIpB,SAASo0B,EAAkBphB,GACzBA,EAAayP,eAAYha,EACzBuK,EAAaqhB,YAAS5rB,EACtBuK,EAAashB,OAAS,SAgBxB,SAASC,EAAmBvhB,EAAc1O,EAAM3F,GAC9CqU,EAAashB,OAAS,UAEtB,IAAI7a,EAAWzG,EAAayP,UAE5B,IACE,IAAI+R,EAAIb,EAAUla,EAAUnV,GAC5B,OAAQA,GACN,IAAK,OACCkwB,GAAGA,EAAE32B,KAAK4b,EAAU9a,GACxB,MACF,IAAK,QAEH,GADAy1B,EAAkBphB,IACdwhB,EAAgC,MAAM71B,EAAnC61B,EAAE32B,KAAK4b,EAAU9a,GACxB,MACF,IAAK,WACHy1B,EAAkBphB,GACdwhB,GAAGA,EAAE32B,KAAK4b,IAGlB,MAAOzZ,GACP+zB,EAAgB/zB,GAGU,WAAxBgT,EAAashB,OAAqBJ,EAAoBlhB,GAA+C,YAAxBA,EAAashB,SAAsBthB,EAAashB,OAAS,SAG5I,SAASG,EAASzhB,EAAc1O,EAAM3F,GACpC,GAA4B,WAAxBqU,EAAashB,OAAjB,CAEA,GAA4B,cAAxBthB,EAAashB,OAKjB,MAA4B,UAAxBthB,EAAashB,QACfthB,EAAashB,OAAS,YACtBthB,EAAaqhB,OAAS,CAAC,CAAE/vB,KAAMA,EAAM3F,MAAOA,SAC5Cs1B,GAAQ,WACN,OApDN,SAA2BjhB,GACzB,IAAI7S,EAAQ6S,EAAaqhB,OACzB,GAAKl0B,EAAL,CAGA6S,EAAaqhB,YAAS5rB,EACtBuK,EAAashB,OAAS,QACtB,IAAK,IAAIlzB,EAAI,EAAGA,EAAIjB,EAAM5C,SACxBg3B,EAAmBvhB,EAAc7S,EAAMiB,GAAGkD,KAAMnE,EAAMiB,GAAGzC,OAC7B,WAAxBqU,EAAashB,UAFiBlzB,KA6CzBszB,CAAkB1hB,YAK7BuhB,EAAmBvhB,EAAc1O,EAAM3F,GAbrCqU,EAAaqhB,OAAOj1B,KAAK,CAAEkF,KAAMA,EAAM3F,MAAOA,KAgBlD,IAAI8F,EAAe,WACjB,SAASA,EAAagV,EAAUkb,GAC9BxB,EAAgBh2B,KAAMsH,GAKtBtH,KAAKg3B,cAAW1rB,EAChBtL,KAAKslB,UAAYhJ,EACjBtc,KAAKk3B,YAAS5rB,EACdtL,KAAKm3B,OAAS,eAEd,IAAIM,EAAuB,IAAIC,EAAqB13B,MAEpD,IACEA,KAAKg3B,SAAWQ,EAAW92B,UAAK4K,EAAWmsB,GAC3C,MAAO50B,GACP40B,EAAqBr4B,MAAMyD,GAGT,iBAAhB7C,KAAKm3B,SAA2Bn3B,KAAKm3B,OAAS,SAkBpD,OAfA1B,EAAanuB,EAAc,CAAC,CAC1BrG,IAAK,cACLO,MAAO,WACe,WAAhBxB,KAAKm3B,SACPF,EAAkBj3B,MAClB+2B,EAAoB/2B,SAGvB,CACDiB,IAAK,SACLW,IAAK,WACH,MAAuB,WAAhB5B,KAAKm3B,WAIT7vB,EAtCU,GAyCfowB,EAAuB,WACzB,SAASA,EAAqB7hB,GAC5BmgB,EAAgBh2B,KAAM03B,GAEtB13B,KAAKqlB,cAAgBxP,EAyBvB,OAtBA4f,EAAaiC,EAAsB,CAAC,CAClCz2B,IAAK,OACLO,MAAO,SAAcA,GACnB81B,EAASt3B,KAAKqlB,cAAe,OAAQ7jB,KAEtC,CACDP,IAAK,QACLO,MAAO,SAAeA,GACpB81B,EAASt3B,KAAKqlB,cAAe,QAAS7jB,KAEvC,CACDP,IAAK,WACLO,MAAO,WACL81B,EAASt3B,KAAKqlB,cAAe,cAE9B,CACDpkB,IAAK,SACLW,IAAK,WACH,MAAqC,WAA9B5B,KAAKqlB,cAAc8R,WAIvBO,EA7BkB,GAgCvBnZ,EAAahc,EAAQgc,WAAa,WACpC,SAASA,EAAWiZ,GAGlB,GAFAxB,EAAgBh2B,KAAMue,KAEhBve,gBAAgBue,GAAa,MAAM,IAAIzC,UAAU,6CAEvD,GAA0B,oBAAf0b,EAA2B,MAAM,IAAI1b,UAAU,6CAE1D9b,KAAK23B,YAAcH,EA8VrB,OA3VA/B,EAAalX,EAAY,CAAC,CACxBtd,IAAK,YACLO,MAAO,SAAmB8a,GAQxB,MAPwB,kBAAbA,GAAsC,OAAbA,IAClCA,EAAW,CACThb,KAAMgb,EACNld,MAAOF,UAAU,GACjB0a,SAAU1a,UAAU,KAGjB,IAAIoI,EAAagV,EAAUtc,KAAK23B,eAExC,CACD12B,IAAK,UACLO,MAAO,SAAiBqyB,GACtB,IAAIrzB,EAAQR,KAEZ,OAAO,IAAIya,SAAQ,SAAUC,EAASwI,GACpC,GAAkB,oBAAP2Q,EAUX,IAAIhe,EAAerV,EAAMuV,UAAU,CACjCzU,KAAM,SAAUE,GACd,IACEqyB,EAAGryB,EAAOD,GACV,MAAOsB,GACPqgB,EAAOrgB,GACPgT,EAAakB,gBAIjB3X,MAAO8jB,EACPtJ,SAAUc,SApBVwI,EAAO,IAAIpH,UAAU+X,EAAK,uBAI5B,SAAStyB,IACPsU,EAAakB,cACb2D,UAkBL,CACDzZ,IAAK,MACLO,MAAO,SAAaqyB,GAClB,IAAI+D,EAAS53B,KAEb,GAAkB,oBAAP6zB,EAAmB,MAAM,IAAI/X,UAAU+X,EAAK,sBAIvD,OAAO,IAFC4C,EAAWz2B,MAEZ,EAAM,SAAUsc,GACrB,OAAOsb,EAAO7hB,UAAU,CACtBzU,KAAM,SAAUE,GACd,IACEA,EAAQqyB,EAAGryB,GACX,MAAOqB,GACP,OAAOyZ,EAASld,MAAMyD,GAExByZ,EAAShb,KAAKE,IAEhBpC,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACR0C,EAAS1C,mBAKhB,CACD3Y,IAAK,SACLO,MAAO,SAAgBqyB,GACrB,IAAIgE,EAAS73B,KAEb,GAAkB,oBAAP6zB,EAAmB,MAAM,IAAI/X,UAAU+X,EAAK,sBAIvD,OAAO,IAFC4C,EAAWz2B,MAEZ,EAAM,SAAUsc,GACrB,OAAOub,EAAO9hB,UAAU,CACtBzU,KAAM,SAAUE,GACd,IACE,IAAKqyB,EAAGryB,GAAQ,OAChB,MAAOqB,GACP,OAAOyZ,EAASld,MAAMyD,GAExByZ,EAAShb,KAAKE,IAEhBpC,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACR0C,EAAS1C,mBAKhB,CACD3Y,IAAK,SACLO,MAAO,SAAgBqyB,GACrB,IAAIiE,EAAS93B,KAEb,GAAkB,oBAAP6zB,EAAmB,MAAM,IAAI/X,UAAU+X,EAAK,sBAEvD,IAAIkE,EAAItB,EAAWz2B,MACfg4B,EAAU94B,UAAUkB,OAAS,EAC7B63B,GAAW,EACXC,EAAOh5B,UAAU,GACjBi5B,EAAMD,EAEV,OAAO,IAAIH,GAAE,SAAUzb,GACrB,OAAOwb,EAAO/hB,UAAU,CACtBzU,KAAM,SAAUE,GACd,IAAIsc,GAASma,EAGb,GAFAA,GAAW,GAENna,GAASka,EACZ,IACEG,EAAMtE,EAAGsE,EAAK32B,GACd,MAAOqB,GACP,OAAOyZ,EAASld,MAAMyD,QAGxBs1B,EAAM32B,GAGVpC,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACR,IAAKqe,IAAaD,EAAS,OAAO1b,EAASld,MAAM,IAAI0c,UAAU,oCAE/DQ,EAAShb,KAAK62B,GACd7b,EAAS1C,mBAKhB,CACD3Y,IAAK,SACLO,MAAO,WAGL,IAFA,IAAI42B,EAASp4B,KAEJq4B,EAAOn5B,UAAUkB,OAAQk4B,EAAUt0B,MAAMq0B,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IAC9ED,EAAQC,GAAQr5B,UAAUq5B,GAG5B,IAAIR,EAAItB,EAAWz2B,MAEnB,OAAO,IAAI+3B,GAAE,SAAUzb,GACrB,IAAIzG,OAAe,EACfnK,EAAQ,EAuBZ,OArBA,SAAS8sB,EAAUl3B,GACjBuU,EAAevU,EAAKyU,UAAU,CAC5BzU,KAAM,SAAU6zB,GACd7Y,EAAShb,KAAK6zB,IAEhB/1B,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACJlO,IAAU4sB,EAAQl4B,QACpByV,OAAevK,EACfgR,EAAS1C,YAET4e,EAAUT,EAAE3a,KAAKkb,EAAQ5sB,UAMjC8sB,CAAUJ,GAEH,WACDviB,IACFA,EAAakB,cACblB,OAAevK,SAKtB,CACDrK,IAAK,UACLO,MAAO,SAAiBqyB,GACtB,IAAI4E,EAASz4B,KAEb,GAAkB,oBAAP6zB,EAAmB,MAAM,IAAI/X,UAAU+X,EAAK,sBAEvD,IAAIkE,EAAItB,EAAWz2B,MAEnB,OAAO,IAAI+3B,GAAE,SAAUzb,GACrB,IAAInU,EAAgB,GAEhBuwB,EAAQD,EAAO1iB,UAAU,CAC3BzU,KAAM,SAAUE,GACd,GAAIqyB,EACF,IACEryB,EAAQqyB,EAAGryB,GACX,MAAOqB,GACP,OAAOyZ,EAASld,MAAMyD,GAI1B,IAAI4nB,EAAQsN,EAAE3a,KAAK5b,GAAOuU,UAAU,CAClCzU,KAAM,SAAUE,GACd8a,EAAShb,KAAKE,IAEhBpC,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACR,IAAI3V,EAAIkE,EAAc/B,QAAQqkB,GAC1BxmB,GAAK,GAAGkE,EAAcyE,OAAO3I,EAAG,GACpC00B,OAIJxwB,EAAclG,KAAKwoB,IAErBrrB,MAAO,SAAUyD,GACfyZ,EAASld,MAAMyD,IAEjB+W,SAAU,WACR+e,OAIJ,SAASA,IACHD,EAAME,QAAmC,IAAzBzwB,EAAc/H,QAAckc,EAAS1C,WAG3D,OAAO,WACLzR,EAAc2S,SAAQ,SAAU7U,GAC9B,OAAOA,EAAE8Q,iBAEX2hB,EAAM3hB,oBAIX,CACD9V,IAAKq1B,EACL90B,MAAO,WACL,OAAOxB,QAEP,CAAC,CACHiB,IAAK,OACLO,MAAO,SAAcsG,GACnB,IAAIiwB,EAAoB,oBAAT/3B,KAAsBA,KAAOue,EAE5C,GAAS,MAALzW,EAAW,MAAM,IAAIgU,UAAUhU,EAAI,qBAEvC,IAAI/I,EAASy3B,EAAU1uB,EAAGwuB,GAC1B,GAAIv3B,EAAQ,CACV,IAAIob,EAAapb,EAAO2B,KAAKoH,GAE7B,GAAInI,OAAOwa,KAAgBA,EAAY,MAAM,IAAI2B,UAAU3B,EAAa,qBAExE,OAAIwc,EAAaxc,IAAeA,EAAWvU,cAAgBmyB,EAAU5d,EAE9D,IAAI4d,GAAE,SAAUzb,GACrB,OAAOnC,EAAWpE,UAAUuG,MAIhC,GAAI6Z,EAAU,cACZp3B,EAASy3B,EAAU1uB,EAAGuuB,IAEpB,OAAO,IAAI0B,GAAE,SAAUzb,GACrBwa,GAAQ,WACN,IAAIxa,EAASsc,OAAb,CACA,IAAIC,GAA4B,EAC5BC,GAAoB,EACpBC,OAAiBztB,EAErB,IACE,IAAK,IAAmD0tB,EAA/CC,EAAYl6B,EAAO2B,KAAKoH,GAAGuX,OAAOC,cAAsBuZ,GAA6BG,EAAQC,EAAU33B,QAAQC,MAAOs3B,GAA4B,EAAM,CAC/J,IAAItO,EAAOyO,EAAMx3B,MAGjB,GADA8a,EAAShb,KAAKipB,GACVjO,EAASsc,OAAQ,QAEvB,MAAOvW,GACPyW,GAAoB,EACpBC,EAAiB1W,EATnB,QAWE,KACOwW,GAA6BI,EAAUC,QAC1CD,EAAUC,SAFd,QAKE,GAAIJ,EACF,MAAMC,GAKZzc,EAAS1C,kBAMjB,GAAI5V,MAAMyH,QAAQ3D,GAChB,OAAO,IAAIiwB,GAAE,SAAUzb,GACrBwa,GAAQ,WACN,IAAIxa,EAASsc,OAAb,CACA,IAAK,IAAI30B,EAAI,EAAGA,EAAI6D,EAAE1H,SAAU6D,EAE9B,GADAqY,EAAShb,KAAKwG,EAAE7D,IACZqY,EAASsc,OAAQ,OAEvBtc,EAAS1C,kBAKf,MAAM,IAAIkC,UAAUhU,EAAI,wBAEzB,CACD7G,IAAK,KACLO,MAAO,WACL,IAAK,IAAI23B,EAAQj6B,UAAUkB,OAAQ+f,EAAQnc,MAAMm1B,GAAQC,EAAQ,EAAGA,EAAQD,EAAOC,IACjFjZ,EAAMiZ,GAASl6B,UAAUk6B,GAG3B,IAAIrB,EAAoB,oBAAT/3B,KAAsBA,KAAOue,EAE5C,OAAO,IAAIwZ,GAAE,SAAUzb,GACrBwa,GAAQ,WACN,IAAIxa,EAASsc,OAAb,CACA,IAAK,IAAI30B,EAAI,EAAGA,EAAIkc,EAAM/f,SAAU6D,EAElC,GADAqY,EAAShb,KAAK6e,EAAMlc,IAChBqY,EAASsc,OAAQ,OAEvBtc,EAAS1C,oBAId,CACD3Y,IAAKs1B,EACL30B,IAAK,WACH,OAAO5B,SAIJue,EAtW6B,GAyWlC2X,KACFv2B,OAAO8c,eAAe8B,EAAYc,OAAO,cAAe,CACtD7d,MAAO,CACL63B,OAAQ/C,EACRM,gBAAiBA,GAEnBjB,cAAc,K,u0BChgBlB,SAAgB2D,EACdC,EACA/6B,EACAgD,EACAiG,GAEA,GAlCF,SAAoBjG,GAClB,MAAsB,aAAfA,EAAMuG,KAiCTyxB,CAAWh4B,IA9BjB,SAAsBA,GACpB,MAAsB,eAAfA,EAAMuG,KA6BY0xB,CAAaj4B,GACpC+3B,EAAO/6B,EAAKgD,OAASk4B,OAAOl4B,EAAMA,YAC7B,GAxCT,SAAwBA,GACtB,MAAsB,iBAAfA,EAAMuG,KAuCF4xB,CAAen4B,IA5C5B,SAAuBA,GACrB,MAAsB,gBAAfA,EAAMuG,KA2CuB6xB,CAAcp4B,GAChD+3B,EAAO/6B,EAAKgD,OAASA,EAAMA,WACtB,GA1BT,SAAuBA,GACrB,MAAsB,gBAAfA,EAAMuG,KAyBF8xB,CAAcr4B,GAAQ,CAC/B,IAAM,EAAe,GACrBA,EAAMs4B,OAAO9qB,KAAI,SAAAoQ,GACf,OAAAka,EAA4B,EAAcla,EAAI5gB,KAAM4gB,EAAI5d,MAAOiG,MAEjE8xB,EAAO/6B,EAAKgD,OAAS,OAChB,GApCT,SAAoBA,GAClB,MAAsB,aAAfA,EAAMuG,KAmCFgyB,CAAWv4B,GAAQ,CAC5B,IAAMw4B,GAAiBvyB,GAAc,IAAYjG,EAAMhD,KAAKgD,OAC5D+3B,EAAO/6B,EAAKgD,OAASw4B,OAChB,GA/BT,SAAqBx4B,GACnB,MAAsB,cAAfA,EAAMuG,KA8BFkyB,CAAYz4B,GACrB+3B,EAAO/6B,EAAKgD,OAASA,EAAM04B,OAAOlrB,KAAI,SAAAmrB,GACpC,IAAMC,EAAoB,GAO1B,OANAd,EACEc,EACA57B,EACA27B,EACA1yB,GAEM2yB,EAA0B57B,EAAKgD,eAEpC,GAtCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAMuG,KAqCFsyB,CAAY74B,GACrB+3B,EAAO/6B,EAAKgD,OAAUA,EAAwBA,UACzC,KApCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAMuG,KAmCFuyB,CAAY94B,GAGrB,MAAM,YAFN+3B,EAAO/6B,EAAKgD,OAAS,MAoHzB,SAAgB+4B,EACd5Q,EACAliB,GAEA,GAAIkiB,EAAMzqB,WAAayqB,EAAMzqB,UAAUkB,OAAQ,CAC7C,IAAM,EAAiB,GAIvB,OAHAupB,EAAMzqB,UAAU4b,SAAQ,SAAC,G,IAAEtc,EAAA,EAAAA,KAAMgD,EAAA,EAAAA,MAC/B,OAAA83B,EAA4B,EAAQ96B,EAAMgD,EAAOiG,MAE5C,EAGT,OAAO,KAGT,SAAgB+yB,EAAuB7Q,GACrC,OAAOA,EAAM8Q,MAAQ9Q,EAAM8Q,MAAMj5B,MAAQmoB,EAAMnrB,KAAKgD,MAGtD,SAAgBk5B,EAAQtR,GACtB,MAA0B,UAAnBA,EAAUrhB,KAGnB,SAAgB4yB,EACdvR,GAEA,MAA0B,mBAAnBA,EAAUrhB,KCtOnB,SAAgB6yB,EACdxR,EACA3hB,GAEA,YAFA,IAAAA,MAAA,KAuDA2iB,EApDEhB,EAAUgB,WAsDLA,EAAaA,EAAWviB,OAAOgzB,GAAsB7rB,KAAI,SAAAqb,GAC9D,IAAMyQ,EAAqBzQ,EAAUnrB,UACfmrB,EAAU7rB,KAAKgD,MAErC,YAC0C,mBAI1C,IAAMu5B,EAAaD,EAAmB,GAEN,YAAU,EACxC,6BAGF,IAAME,EAAqBD,EAAWv5B,MAUpC,OAPF,gBAEsB,aAAjBw5B,EAAQjzB,MAAwC,iBAAjBizB,EAAQjzB,MAC1C,GAIA,8B,IA9EF/G,OAAM,SAAC,G,IAAEqpB,EAAA,EAAAA,UAAW0Q,EAAA,EAAAA,WAChBE,GAAuB,EAU3B,MAT8B,aAA1BF,EAAWv5B,MAAMuG,MACnBkzB,EAAcxzB,EAAWszB,EAAWv5B,MAAuBhD,KAAKgD,OAChE,uBAEqC,IAGrCy5B,EAAeF,EAAWv5B,MAA2BA,MAEvB,SAAzB6oB,EAAU7rB,KAAKgD,OAAoBy5B,EAAcA,KAuC5D,IACE7Q,EAxBF,SAAgB8Q,EAAcC,EAAiBzsB,GAC7C,OAbF,SAAkCA,GAChC,IAAMysB,EAAkB,GAQxB,OANA,YAAMzsB,EAAK,CACTjF,UAAS,SAACmC,GACRuvB,EAAMl5B,KAAK2J,EAAKpN,KAAKgD,UAIlB25B,EAIAC,CAAkB1sB,GAAK0Z,MAC5B,SAAC5pB,GAAiB,OAAA28B,EAAM/0B,QAAQ5H,IAAS,KAI7C,SAAgBsnB,EAAiBte,GAC/B,OACEA,GACA0zB,EAAc,CAAC,UAAW1zB,IAC1B0zB,EAAc,CAAC,UAAW1zB,GAS9B,SAASqzB,EAAqB,G,IAAUr5B,EAAA,OAAAA,MACtC,MAAiB,SAAVA,GAA8B,YAAVA,E,SC5EbuE,EACdgZ,G,IACA,wDAUA,OARAuZ,EAAQxd,SAAQ,SAAApL,GACQ,qBAAXA,GAAqC,OAAXA,GAGrC/P,OAAOmB,KAAK4O,GAAQoL,SAAQ,SAAA7Z,GAC1B8d,EAAO9d,GAAOyO,EAAOzO,SAGlB8d,E/BCT,SAAgBsc,EAAc3sB,GAEI,sCAKhC,IAAM4sB,EAAa5sB,EAAI9G,YACpBC,QAAO,SAAAtC,GAAK,MAAW,uBAAXA,EAAEwC,QACdiH,KAAI,SAAAyP,GACH,GAAwB,wBAApBA,EAAW1W,KACb,MAAM,WAMR,OAAO0W,KAQX,OAJY,4BAIL/P,EAGT,SAAgB6sB,EACd7sB,GAGA,OADA2sB,EAAc3sB,GACPA,EAAI9G,YAAYC,QACrB,SAAA4W,GAAc,MAAoB,wBAApBA,EAAW1W,QACzB,GAWJ,SAAgByW,EAAiB9P,GAC/B,OACEA,EAAI9G,YACDC,QACC,SAAA4W,GACE,MAAoB,wBAApBA,EAAW1W,MAAkC0W,EAAWjgB,QAE3DwQ,KAAI,SAAClH,GAA+B,OAAAA,EAAEtJ,KAAKgD,SAAO,IAAM,KAK/D,SAAgBg6B,EACd9sB,GAEA,OAAOA,EAAI9G,YAAYC,QACrB,SAAA4W,GAAc,MAAoB,uBAApBA,EAAW1W,QA4C7B,SAAgB0zB,EACdC,GAIA,IAAInsB,EAFJ8rB,EAAcK,GAId,IAAuB,UAAAA,EAAS9zB,YAAT,eAAsB,CAAxC,IAAI6W,EAAU,KACjB,GAAwB,wBAApBA,EAAW1W,KAAgC,CAC7C,IAAME,EAAawW,EAAuCxW,UAC1D,GACgB,UAAdA,GACc,aAAdA,GACc,iBAAdA,EAEA,OAAOwW,EAGa,uBAApBA,EAAW1W,MAAkCwH,IAG/CA,EAAqBkP,GAIzB,GAAIlP,EACF,OAAOA,EAGT,MAAM,YAcR,SAAgBosB,EACdh0B,QAAA,IAAAA,MAAA,IAEA,IAAMi0B,EAAwB,GAK9B,OAJAj0B,EAAUmT,SAAQ,SAAAyO,GAChBqS,EAASrS,EAAS/qB,KAAKgD,OAAS+nB,KAG3BqS,EAGT,SAAgBC,EACdpd,GAEA,GACEA,GACAA,EAAWqd,qBACXrd,EAAWqd,oBAAoB17B,OAC/B,CACA,IAAM27B,EAAgBtd,EAAWqd,oBAC9Bj0B,QAAO,SAAC,GAAqB,OAAnB,EAAAm0B,gBACVhtB,KACC,SAAC,G,IAAEitB,EAAA,EAAAA,SAAUD,EAAA,EAAAA,aACLE,EAAgD,GAOtD,OANA5C,EACE4C,EACAD,EAASz9B,KACTw9B,GAGKE,KAIb,OAAOn2B,EAAM,0BAAC,IAAOg2B,IAGvB,MAAO,G,SgCvNOI,EACdv4B,EACA6Z,EACA3W,GAEA,IAAIiY,EAAS,EAOb,OANAnb,EAAMkX,SAAQ,SAAUshB,EAAMn4B,GACxBwZ,EAAK/c,KAAKV,KAAMo8B,EAAMn4B,EAAGL,KAC3BA,EAAMmb,KAAYqd,KAEnBt1B,GACHlD,EAAMxD,OAAS2e,EACRnb,EC0DT,SAASy4B,EAAiB3tB,GACxB,OAZF,SAAS4tB,EACPzf,EACAlV,GAEA,OAAOkV,EAAGqM,aAAaQ,WAAW1oB,OAChC,SAAAooB,GACE,MAAmB,mBAAnBA,EAAUrhB,MACVu0B,EAAQ30B,EAAUyhB,EAAU5qB,KAAKgD,OAAQmG,MAKtC20B,CACLf,EAAuB7sB,IjCkC3B,SACEA,GAEA,oCAO6B,wCAI7B,IAAM6tB,EAAc7tB,EAAI9G,YAAY,GAOpC,OALA,8CAKO20B,EiCvD0BC,CAAsB9tB,GACrDitB,EAAkBH,EAAuB9sB,KAEvC,KACAA,EAGN,SAAS+tB,EACPrS,GAEA,OAAO,SAA0BC,GAC/B,OAAOD,EAAWhC,MAChB,SAAAhjB,GACE,OAACA,EAAI5G,MAAQ4G,EAAI5G,OAAS6rB,EAAU7rB,KAAKgD,OACxC4D,EAAIqY,MAAQrY,EAAIqY,KAAK4M,OAK9B,SAAgBqS,EACdtS,EACA1b,GAEA,IAAMiuB,EAA0Ch9B,OAAOkG,OAAO,MAC1D+2B,EAA6C,GAE3CC,EAAgDl9B,OAAOkG,OAAO,MAChEi3B,EAAwD,GAExDC,EAAcV,EAChB,YAAM3tB,EAAK,CACTjG,SAAU,CACR+E,MAAA,SAAM5B,EAAM2sB,EAAM1sB,GAO8B,uBAA3CA,EAAkC9D,OAEnC40B,EAAe/wB,EAAKpN,KAAKgD,QAAS,KAKxCmH,MAAO,CACL6E,MAAA,SAAM5B,GACJ,GAAIwe,GAAcxe,EAAKwe,aAGKA,EAAWhC,MACnC,SAAAiC,GAAa,OAAAA,EAAU2S,WAKvBpxB,EAAKwe,YACLxe,EAAKwe,WAAWhC,KAAKqU,EAAoBrS,KA2BzC,OAzBIxe,EAAK1M,WAGP0M,EAAK1M,UAAU4b,SAAQ,SAAAuN,GACE,aAAnBA,EAAI7mB,MAAMuG,MACZ60B,EAAkB36B,KAAK,CACrBzD,KAAO6pB,EAAI7mB,MAAuBhD,KAAKgD,WAM3CoK,EAAKsd,cAqTvB,SAAS+T,EACP/T,GAEA,IAAMgU,EAAqC,GAe3C,OAbAhU,EAAaQ,WAAW5O,SAAQ,SAAAsO,IAE3BsR,EAAQtR,IAAcuR,EAAiBvR,KACxCA,EAAUF,aAEV+T,EAAsC7T,EAAUF,cAAcpO,SAC5D,SAAAqiB,GAAQ,OAAAD,EAAaj7B,KAAKk7B,MAEA,mBAAnB/T,EAAUrhB,MACnBm1B,EAAaj7B,KAAKmnB,MAIf8T,EApUOD,CAAsCrxB,EAAKsd,cAAcpO,SACvD,SAAAqiB,GACEL,EAAwB76B,KAAK,CAC3BzD,KAAM2+B,EAAK3+B,KAAKgD,WAOjB,OAMfqH,eAAgB,CACd2E,MAAK,SAAC5B,GAGJixB,EAAqBjxB,EAAKpN,KAAKgD,QAAS,IAI5CiI,UAAW,CACT+D,MAAK,SAAC5B,GAEJ,GAAI6wB,EAAoBrS,EAApBqS,CAAgC7wB,GAClC,OAAO,UA+BjB,OApBEmxB,GACAZ,EAAcS,GAAmB,SAAAzH,GAAK,OAACwH,EAAexH,EAAE32B,SAAO4B,SAE/D28B,EA+LJ,SACEjV,EACApZ,GAEA,IAAM0uB,EAjBR,SAA4BtV,GAC1B,OAAO,SAAyBzB,GAC9B,OAAOyB,EAAOM,MACZ,SAACiV,GACC,OAAAhX,EAAS7kB,OACe,aAAxB6kB,EAAS7kB,MAAMuG,MACfse,EAAS7kB,MAAMhD,OACd6+B,EAAQ7+B,OAAS6nB,EAAS7kB,MAAMhD,KAAKgD,OACnC67B,EAAQ5f,MAAQ4f,EAAQ5f,KAAK4I,QASnBiX,CAAmBxV,GAEtC,OAAOuU,EACL,YAAM3tB,EAAK,CACTnG,oBAAqB,CACnBiF,MAAK,SAAC5B,GACJ,kCACKA,GAAI,CAEPkwB,oBAAqBlwB,EAAKkwB,oBAAoBj0B,QAC5C,SAAA01B,GACE,OAACzV,EAAOM,MAAK,SAAAC,GAAO,OAAAA,EAAI7pB,OAAS++B,EAAOtB,SAASz9B,KAAKgD,gBAMhEmH,MAAO,CACL6E,MAAK,SAAC5B,GAKJ,GAF0Bkc,EAAOM,MAAK,SAAAoV,GAAa,OAAAA,EAAUR,UAEtC,CACrB,IAAI,EAAgB,EAMpB,GALApxB,EAAK1M,UAAU4b,SAAQ,SAAAuN,GACjB+U,EAAW/U,KACb,GAAiB,MAGC,IAAlB,EACF,OAAO,QAMfzf,SAAU,CACR4E,MAAK,SAAC5B,GAEJ,GAAIwxB,EAAWxxB,GACb,OAAO,UA5OD6xB,CAA4Bb,EAAmBG,IAO7DA,GACAZ,EAAcW,GAAyB,SAAAY,GAAM,OAACb,EAAqBa,EAAGl/B,SACnE4B,SAEH28B,EAyOJ,SACEjV,EACApZ,GAEA,SAASlB,EACP5B,GAEA,GAAIkc,EAAOM,MAAK,SAAAuV,GAAO,OAAAA,EAAIn/B,OAASoN,EAAKpN,KAAKgD,SAC5C,OAAO,KAIX,OAAO66B,EACL,YAAM3tB,EAAK,CACT7F,eAAgB,CAAE2E,MAAK,GACvBzE,mBAAoB,CAAEyE,MAAK,MAxPfowB,CACZd,EACAC,IAIGA,EAuDT,IAAMc,EAAyB,CAC7BpgB,KAAM,SAAC4M,GACL,IAAMyT,EAAsC,eAAzBzT,EAAU7rB,KAAKgD,MAalC,OAZIs8B,KAECzT,EAAUnrB,WACVmrB,EAAUnrB,UAAUkpB,MAAK,SAAAC,GAAO,MAAmB,QAAnBA,EAAI7pB,KAAKgD,UASvCs8B,IAIX,SAAgBC,EAAsCrvB,GACpD,OAAOguB,EACL,CAACmB,GACDxC,EAAc3sB,IAkMlB,SAAgBsvB,EACdx2B,GAKA,MAA4B,UAHTi0B,EAAkBj0B,GAC6BS,UAIzDT,EAIW,YAAMA,EAAU,CAClCe,oBAAqB,CACnBiF,MAAK,SAAC5B,GACJ,kCACKA,GAAI,CACP3D,UAAW,cASrB,SAAgBg2B,EACdz2B,GAEA6zB,EAAc7zB,GAEd,IAAIu1B,EAAcL,EAChB,CACE,CACEjf,KAAM,SAAC4M,GAA6B,MAAyB,WAAzBA,EAAU7rB,KAAKgD,OACnDw7B,QAAQ,IAGZx1B,GAyBF,OAlBIu1B,IACFA,EAAc,YAAMA,EAAa,CAC/Bh0B,mBAAoB,CAClByE,MAAK,SAAC5B,GACJ,GAAIA,EAAKsd,cACgBtd,EAAKsd,aAAaQ,WAAW1oB,OAClD,SAAAooB,GACE,OAAAsR,EAAQtR,IAAuC,eAAzBA,EAAU5qB,KAAKgD,SAGvC,OAAO,UAQZu7B,E,IhC5hBImB,EAAmC,oBAAZxf,WACb,kBAAdC,WACe,gBAAtBA,UAAUC,SCFJhf,EAAA,iBAAAA,SAKR,SAAgBu+B,EAAa38B,GAC3B,OAGF,SAAS48B,EAAmBC,EAAQ7jB,GAClC,OAAQ5a,EAASc,KAAK29B,IACtB,IAAK,iBACH,GAAI7jB,EAAK7Y,IAAI08B,GAAM,OAAO7jB,EAAK5Y,IAAIy8B,GACnC,IAAM,EAAmBA,EAAYlyB,MAAM,GAK3C,OAJAqO,EAAK3J,IAAIwtB,EAAK,GACd,EAAKvjB,SAAQ,SAAUwjB,EAAOr6B,GAC5B,EAAKA,GAAKm6B,EAAgBE,EAAO9jB,MAE5B,EAGT,IAAK,kBACH,GAAIA,EAAK7Y,IAAI08B,GAAM,OAAO7jB,EAAK5Y,IAAIy8B,GAGnC,IAAM,EAAO1+B,OAAOkG,OAAOlG,OAAO4+B,eAAeF,IAKjD,OAJA7jB,EAAK3J,IAAIwtB,EAAK,GACd1+B,OAAOmB,KAAKu9B,GAAKvjB,SAAQ,SAAA7Z,GACvB,EAAKA,GAAOm9B,EAAiBC,EAAYp9B,GAAMuZ,MAE1C,EAGT,QACE,OAAO6jB,GA5BFD,CAAgB58B,EAAO,IAAIyF,K,SgCJpBu3B,EAAsBjjB,GACpC,IACE,OAAOA,IACP,MAAO1Y,GACH7D,QAAQI,OACVJ,QAAQI,MAAMyD,IAKpB,SAAgB47B,EAAsB3xB,GACpC,OAAOA,EAAO4J,QAAU5J,EAAO4J,OAAOtW,O/BbhC,IAAAP,EAAA,iBAAAA,eAwBR,SAAgB6+B,I,IACd,sDAEA,OAAOC,EAAerG,GASxB,SAAgBqG,EAAkBrG,GAChC,IAAIvZ,EAASuZ,EAAQ,IAAM,GACrBsG,EAAQtG,EAAQl4B,OACtB,GAAIw+B,EAAQ,EAAG,CACb,IAAMC,EAAoB,GAC1B9f,EAAS+f,EAAoB/f,EAAQ8f,GACrC,IAAK,IAAI56B,EAAI,EAAGA,EAAI26B,IAAS36B,EAC3B8a,EAASggB,EAAYhgB,EAAQuZ,EAAQr0B,GAAI46B,GAG7C,OAAO9f,EAGT,SAASigB,EAAS5f,GAChB,OAAe,OAARA,GAA+B,kBAARA,EAGhC,SAAS2f,EACPhgB,EACArP,EACAmvB,GAEA,OAAIG,EAAStvB,IAAWsvB,EAASjgB,IAG3Bpf,OAAOs/B,eAAiBt/B,OAAOs/B,aAAalgB,KAC9CA,EAAS+f,EAAoB/f,EAAQ8f,IAGvCl/B,OAAOmB,KAAK4O,GAAQoL,SAAQ,SAAArL,GAC1B,IAAMyvB,EAAcxvB,EAAOD,GAC3B,GAAI5P,EAAea,KAAKqe,EAAQtP,GAAY,CAC1C,IAAM0vB,EAAcpgB,EAAOtP,GACvByvB,IAAgBC,IAQlBpgB,EAAOtP,GAAasvB,EAClBD,EAAoBK,EAAaN,GACjCK,EACAL,SAMJ9f,EAAOtP,GAAayvB,KAIjBngB,GAIFrP,EAGT,SAASovB,EAAuBt9B,EAAUq9B,GAgBxC,OAdY,OAAVr9B,GACiB,kBAAVA,GACPq9B,EAAWz4B,QAAQ5E,GAAS,IAG1BA,EADEwC,MAAMyH,QAAQjK,GACPA,EAAc2K,MAAM,GAErB,OAAH,IAAG,CAAH,CACH3G,UAAW7F,OAAO4+B,eAAe/8B,IAC9BA,GAGPq9B,EAAW58B,KAAKT,IAEXA,EC/GU7B,OAAOkG,OAAO,M,8H+B8BjB,EAAQ,GACtB,OAAO,IAAI,KAAW,SAAC,EAAW,GAChC,OAAO,IAAI,KAAW,YACpB,IAAI,EACA,EACA,EAEJ,IACE,EAAM,EAAQ,GAAW,UAAU,CACjC,KAAM,YACA,EAAO,SACT,EAAgB,EAAa,CAC3B,cAAe,EAAO,OACtB,SAAU,EACV,UAAS,EACT,QAAO,KAIP,EAAa,EAAc,UAAU,CACnC,KAAM,EAAS,KAAK,KAAK,GACzB,MAAO,EAAS,MAAM,KAAK,GAC3B,SAAU,EAAS,SAAS,KAAK,KAKvC,EAAS,KAAK,IAEhB,MAAO,aACL,EAAgB,EAAa,CAC3B,UAAS,EACT,aAAY,EAEZ,cACE,GACA,EAAa,QACb,EAAa,OAAO,OACtB,QAAO,KAGP,EAAa,EAAc,UAAU,CACnC,KAAM,EAAS,KAAK,KAAK,GACzB,MAAO,EAAS,MAAM,KAAK,GAC3B,SAAU,EAAS,SAAS,KAAK,KAIrC,EAAS,MAAM,IAEjB,SAAU,WAGH,GACH,EAAS,SAAS,KAAK,EAAvB,MAIN,MAAO,GACP,EAAa,CAAE,aAAc,EAAG,UAAS,EAAE,QAAO,IAClD,EAAS,MAAM,GAGjB,OAAO,WACD,GAAK,EAAI,cACT,GAAY,EAAI,sBAM5B,YAEE,WAAY,GAAZ,MACE,cAAO,K,OACP,EAAK,KAAO,EAAQ,G,EAJO,iBAOtB,oBAAP,SACE,EACA,GAEA,OAAO,KAAK,KAAK,QAAQ,EAAW,IAXxC,CAA+B,M,s5BNR/B,SAAgByzB,EACdC,EACA/6B,EACAgD,EACAiG,GAEA,GAlCF,SAAoBjG,GAClB,MAAsB,aAAfA,EAAMuG,KAiCTyxB,CAAWh4B,IA9BjB,SAAsBA,GACpB,MAAsB,eAAfA,EAAMuG,KA6BY0xB,CAAaj4B,GACpC+3B,EAAO/6B,EAAKgD,OAASk4B,OAAOl4B,EAAMA,YAC7B,GAxCT,SAAwBA,GACtB,MAAsB,iBAAfA,EAAMuG,KAuCF4xB,CAAen4B,IA5C5B,SAAuBA,GACrB,MAAsB,gBAAfA,EAAMuG,KA2CuB6xB,CAAcp4B,GAChD+3B,EAAO/6B,EAAKgD,OAASA,EAAMA,WACtB,GA1BT,SAAuBA,GACrB,MAAsB,gBAAfA,EAAMuG,KAyBF8xB,CAAcr4B,GAAQ,CAC/B,IAAM,EAAe,GACrBA,EAAMs4B,OAAO9qB,KAAI,SAAAoQ,GACf,OAAAka,EAA4B,EAAcla,EAAI5gB,KAAM4gB,EAAI5d,MAAOiG,MAEjE8xB,EAAO/6B,EAAKgD,OAAS,OAChB,GApCT,SAAoBA,GAClB,MAAsB,aAAfA,EAAMuG,KAmCFgyB,CAAWv4B,GAAQ,CAC5B,IAAMw4B,GAAiBvyB,GAAc,IAAYjG,EAAMhD,KAAKgD,OAC5D+3B,EAAO/6B,EAAKgD,OAASw4B,OAChB,GA/BT,SAAqBx4B,GACnB,MAAsB,cAAfA,EAAMuG,KA8BFkyB,CAAYz4B,GACrB+3B,EAAO/6B,EAAKgD,OAASA,EAAM04B,OAAOlrB,KAAI,SAAAmrB,GACpC,IAAMC,EAAoB,GAO1B,OANAd,EACEc,EACA57B,EACA27B,EACA1yB,GAEM2yB,EAA0B57B,EAAKgD,eAEpC,GAtCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAMuG,KAqCFsyB,CAAY74B,GACrB+3B,EAAO/6B,EAAKgD,OAAUA,EAAwBA,UACzC,KApCT,SAAqBA,GACnB,MAAsB,cAAfA,EAAMuG,KAmCFuyB,CAAY94B,GAGrB,MAAM,YAFN+3B,EAAO/6B,EAAKgD,OAAS,MAUzB,SAAgB49B,EACdzV,EACAliB,GAEA,IAAI43B,EAAqB,KACrB1V,EAAMS,aACRiV,EAAgB,GAChB1V,EAAMS,WAAWtP,SAAQ,SAAAuP,GACvBgV,EAAchV,EAAU7rB,KAAKgD,OAAS,GAElC6oB,EAAUnrB,WACZmrB,EAAUnrB,UAAU4b,SAAQ,SAAC,G,IAAEtc,EAAA,EAAAA,KAAMgD,EAAA,EAAAA,MACnC,OAAA83B,EACE+F,EAAchV,EAAU7rB,KAAKgD,OAC7BhD,EACAgD,EACAiG,UAOV,IAAI8xB,EAAc,KAQlB,OAPI5P,EAAMzqB,WAAayqB,EAAMzqB,UAAUkB,SACrCm5B,EAAS,GACT5P,EAAMzqB,UAAU4b,SAAQ,SAAC,G,IAAEtc,EAAA,EAAAA,KAAMgD,EAAA,EAAAA,MAC/B,OAAA83B,EAA4BC,EAAQ/6B,EAAMgD,EAAOiG,OAI9C63B,EAAgB3V,EAAMnrB,KAAKgD,MAAO+3B,EAAQ8F,GASnD,IAAME,EAA6B,CACjC,aACA,UACA,OACA,SACA,OACA,UAGF,SAAgBD,EACd1V,EACA7lB,EACAqmB,GAEA,GACEA,GACAA,EAAU,YACVA,EAAU,WAAV,IACA,CACA,GACEA,EAAU,WAAV,QACCA,EAAU,WAAV,OAAgDhqB,OAAS,EAC1D,CACA,IAAMo/B,EAAapV,EAAU,WAAV,OACdA,EAAU,WAAV,OACD,GACJoV,EAAWxjB,OAEX,IAAM,EAAYjY,EACZ,EAAe,GAKrB,OAJAy7B,EAAW1kB,SAAQ,SAAA7Z,GACjB,EAAaA,GAAO,EAAUA,MAGtBmpB,EAAU,WAAV,IAA+B,IAAIjP,KAAKC,UAChD,GACD,IAED,OAAOgP,EAAU,WAAV,IAIX,IAAIqV,EAA4B7V,EAEhC,GAAI7lB,EAAM,CAIR,IAAM27B,EAA0B,IAAU37B,GAC1C07B,GAAqB,IAAIC,EAAe,IAc1C,OAXItV,GACFzqB,OAAOmB,KAAKspB,GAAYtP,SAAQ,SAAA7Z,IACS,IAAnCs+B,EAAiBn5B,QAAQnF,KACzBmpB,EAAWnpB,IAAQtB,OAAOmB,KAAKspB,EAAWnpB,IAAMb,OAClDq/B,GAAqB,IAAIx+B,EAAG,IAAIka,KAAKC,UAAUgP,EAAWnpB,IAAK,IAE/Dw+B,GAAqB,IAAIx+B,MAKxBw+B,EAGT,SAAgBlF,EACd5Q,EACAliB,GAEA,GAAIkiB,EAAMzqB,WAAayqB,EAAMzqB,UAAUkB,OAAQ,CAC7C,IAAM,EAAiB,GAIvB,OAHAupB,EAAMzqB,UAAU4b,SAAQ,SAAC,G,IAAEtc,EAAA,EAAAA,KAAMgD,EAAA,EAAAA,MAC/B,OAAA83B,EAA4B,EAAQ96B,EAAMgD,EAAOiG,MAE5C,EAGT,OAAO,KAGT,SAAgB+yB,EAAuB7Q,GACrC,OAAOA,EAAM8Q,MAAQ9Q,EAAM8Q,MAAMj5B,MAAQmoB,EAAMnrB,KAAKgD,MAGtD,SAAgBk5B,EAAQtR,GACtB,MAA0B,UAAnBA,EAAUrhB,KAGnB,SAAgB4yB,EACdvR,GAEA,MAA0B,mBAAnBA,EAAUrhB,KAGnB,SAAgB43B,EAAUC,GACxB,OAAOA,GACsC,OAA1CA,EAAiCz4B,MACS,mBAAnCy4B,EAAqBC,UAQjC,SAAgBC,EACdC,EACAF,GAEA,YAFA,IAAAA,OAAA,GAEA,aACE14B,KAAM,KACN04B,UAAS,GACe,kBAAbE,EACP,CAAEvP,GAAIuP,EAAUC,cAAU10B,GAC1By0B,GAIR,SAAgBE,EAAYC,GAC1B,OACgB,MAAdA,GACsB,kBAAfA,GACsC,SAA5CA,EAAmC/4B,K,SCtRxBg5B,EACdxW,EACAliB,GAEA,GAAIkiB,EAAMS,YAAcT,EAAMS,WAAWhqB,OAAQ,CAC/C,IAAM,EAA8B,GAOpC,OANAupB,EAAMS,WAAWtP,SAAQ,SAACuP,GACxB,EAAaA,EAAU7rB,KAAKgD,OAAS+4B,EACnClQ,EACA5iB,MAGG,EAET,OAAO,KAGT,SAAgBmzB,EACdxR,EACA3hB,GAEA,YAFA,IAAAA,MAAA,KAuDA2iB,EApDEhB,EAAUgB,WAsDLA,EAAaA,EAAWviB,OAAOgzB,GAAsB7rB,KAAI,SAAAqb,GAC9D,IAAMyQ,EAAqBzQ,EAAUnrB,UACfmrB,EAAU7rB,KAAKgD,MAErC,YAC0C,mBAI1C,IAAMu5B,EAAaD,EAAmB,GAEN,YAAU,EACxC,6BAGF,IAAME,EAAqBD,EAAWv5B,MAUpC,OAPF,gBAEsB,aAAjBw5B,EAAQjzB,MAAwC,iBAAjBizB,EAAQjzB,MAC1C,GAIA,8B,IA9EF/G,OAAM,SAAC,G,IAAEqpB,EAAA,EAAAA,UAAW0Q,EAAA,EAAAA,WAChBE,GAAuB,EAU3B,MAT8B,aAA1BF,EAAWv5B,MAAMuG,MACnBkzB,EAAcxzB,EAAWszB,EAAWv5B,MAAuBhD,KAAKgD,OAChE,uBAEqC,IAGrCy5B,EAAeF,EAAWv5B,MAA2BA,MAEvB,SAAzB6oB,EAAU7rB,KAAKgD,OAAoBy5B,EAAcA,KAuC5D,IACE7Q,EALF,SAASyQ,EAAqB,G,IAAUr5B,EAAA,OAAAA,MACtC,MAAiB,SAAVA,GAA8B,YAAVA,E,SC5EbuE,EACdgZ,G,IACA,wDAUA,OARAuZ,EAAQxd,SAAQ,SAAApL,GACQ,qBAAXA,GAAqC,OAAXA,GAGrC/P,OAAOmB,KAAK4O,GAAQoL,SAAQ,SAAA7Z,GAC1B8d,EAAO9d,GAAOyO,EAAOzO,SAGlB8d,E/BCT,SAAgBsc,EAAc3sB,GAEI,sCAKhC,IAAM4sB,EAAa5sB,EAAI9G,YACpBC,QAAO,SAAAtC,GAAK,MAAW,uBAAXA,EAAEwC,QACdiH,KAAI,SAAAyP,GACH,GAAwB,wBAApBA,EAAW1W,KACb,MAAM,WAMR,OAAO0W,KAQX,OAJY,4BAIL/P,EAGT,SAAgB6sB,EACd7sB,GAGA,OADA2sB,EAAc3sB,GACPA,EAAI9G,YAAYC,QACrB,SAAA4W,GAAc,MAAoB,wBAApBA,EAAW1W,QACzB,GAuBJ,SAAgByzB,EACd9sB,GAEA,OAAOA,EAAI9G,YAAYC,QACrB,SAAA4W,GAAc,MAAoB,uBAApBA,EAAW1W,QAI7B,SAAgBq4B,EAAmB1xB,GACjC,IAAM2xB,EAAW9E,EAAuB7sB,GAOxC,OAJgC,yCAIzB2xB,EAgCT,SAAgB5E,EACdC,GAIA,IAAInsB,EAFJ8rB,EAAcK,GAId,IAAuB,UAAAA,EAAS9zB,YAAT,eAAsB,CAAxC,IAAI6W,EAAU,KACjB,GAAwB,wBAApBA,EAAW1W,KAAgC,CAC7C,IAAME,EAAawW,EAAuCxW,UAC1D,GACgB,UAAdA,GACc,aAAdA,GACc,iBAAdA,EAEA,OAAOwW,EAGa,uBAApBA,EAAW1W,MAAkCwH,IAG/CA,EAAqBkP,GAIzB,GAAIlP,EACF,OAAOA,EAGT,MAAM,YAcR,SAAgBosB,EACdh0B,QAAA,IAAAA,MAAA,IAEA,IAAMi0B,EAAwB,GAK9B,OAJAj0B,EAAUmT,SAAQ,SAAAyO,GAChBqS,EAASrS,EAAS/qB,KAAKgD,OAAS+nB,KAG3BqS,EAGT,SAAgBC,EACdpd,GAEA,GACEA,GACAA,EAAWqd,qBACXrd,EAAWqd,oBAAoB17B,OAC/B,CACA,IAAM27B,EAAgBtd,EAAWqd,oBAC9Bj0B,QAAO,SAAC,GAAqB,OAAnB,EAAAm0B,gBACVhtB,KACC,SAAC,G,IAAEitB,EAAA,EAAAA,SAAUD,EAAA,EAAAA,aACLE,EAAgD,GAOtD,OANA5C,EACE4C,EACAD,EAASz9B,KACTw9B,GAGKE,KAIb,OAAOn2B,EAAM,0BAAC,IAAOg2B,IAGvB,MAAO,GiCpKT,IAAMuE,EAA4B,CAChCv4B,KAAM,QACNvJ,KAAM,CACJuJ,KAAM,OACNvG,MAAO,eA0JX,SAAgB++B,EAAsB7xB,GACpC,OAAO,YAAM2sB,EAAc3sB,GAAM,CAC/BhG,aAAc,CACZ8E,MAAA,SAAM5B,EAAM2sB,EAAM1sB,GAEhB,IACEA,GAC6C,wBAA5CA,EAAmC9D,KAFtC,CAQQ,IAAA2hB,EAAA,EAAAA,WACR,GAAKA,EAaL,IAPaA,EAAWtB,MAAK,SAAAgB,GAC3B,OACEsR,EAAQtR,KACkB,eAAzBA,EAAU5qB,KAAKgD,OACgC,IAA9C4nB,EAAU5qB,KAAKgD,MAAMO,YAAY,KAAM,OAG7C,CAMA,IAAM4nB,EAAQ9d,EACd,KACE6uB,EAAQ/Q,IACRA,EAAMS,YACNT,EAAMS,WAAWhC,MAAK,SAAA7iB,GAAK,MAAiB,WAAjBA,EAAE/G,KAAKgD,UAMpC,kCACKoK,GAAI,CACP8d,WAAY,OAAF,IAAE,CAAIA,EAAU,CAAE4W,Y,IhC9PzBpC,EAAmC,oBAAZxf,WACb,kBAAdC,WACe,gBAAtBA,UAAUC,SCFJ,iBAAAhf,SkCSR,SAAgB4gC,EAAMlhC,GACpB,OATuB,qBAAZC,EACF,aAIF,iBAIaD,EAGtB,SAAgBmhC,IACd,OAA+B,IAAxBD,EAAM,cAOf,SAAgBE,IACd,OAAyB,IAAlBF,EAAM,QCFf,SAAgBG,EAAgBvhB,GAC9B,KDHgC,IAAzBohB,EAAM,gBCGUE,QAID,oBAAXrhB,QAA+C,kBAAfA,OAAO,KAG9C,OAxBN,SAASuhB,EAAWC,GAalB,OAZAlhC,OAAOsL,OAAO41B,GAEdlhC,OAAOmhC,oBAAoBD,GAAG/lB,SAAQ,SAASimB,GAE/B,OAAZF,EAAEE,IACkB,kBAAZF,EAAEE,IAAyC,oBAAZF,EAAEE,IACxCphC,OAAOqhC,SAASH,EAAEE,KAEnBH,EAAWC,EAAEE,OAIVF,EAWID,CAAWxhB,GAGtB,OAAOA,ElC/BD,IAAAvf,EAAA,iBAAAA,eAoCR,SAAgB8+B,EAAkBrG,GAChC,IAAIvZ,EAASuZ,EAAQ,IAAM,GACrBsG,EAAQtG,EAAQl4B,OACtB,GAAIw+B,EAAQ,EAAG,CACb,IAAMC,EAAoB,GAC1B9f,EAAS+f,EAAoB/f,EAAQ8f,GACrC,IAAK,IAAI56B,EAAI,EAAGA,EAAI26B,IAAS36B,EAC3B8a,EAASggB,EAAYhgB,EAAQuZ,EAAQr0B,GAAI46B,GAG7C,OAAO9f,EAGT,SAASigB,EAAS5f,GAChB,OAAe,OAARA,GAA+B,kBAARA,EAGhC,SAAS2f,EACPhgB,EACArP,EACAmvB,GAEA,OAAIG,EAAStvB,IAAWsvB,EAASjgB,IAG3Bpf,OAAOs/B,eAAiBt/B,OAAOs/B,aAAalgB,KAC9CA,EAAS+f,EAAoB/f,EAAQ8f,IAGvCl/B,OAAOmB,KAAK4O,GAAQoL,SAAQ,SAAArL,GAC1B,IAAMyvB,EAAcxvB,EAAOD,GAC3B,GAAI5P,EAAea,KAAKqe,EAAQtP,GAAY,CAC1C,IAAM0vB,EAAcpgB,EAAOtP,GACvByvB,IAAgBC,IAQlBpgB,EAAOtP,GAAasvB,EAClBD,EAAoBK,EAAaN,GACjCK,EACAL,SAMJ9f,EAAOtP,GAAayvB,KAIjBngB,GAIFrP,EAGT,SAASovB,EAAuBt9B,EAAUq9B,GAgBxC,OAdY,OAAVr9B,GACiB,kBAAVA,GACPq9B,EAAWz4B,QAAQ5E,GAAS,IAG1BA,EADEwC,MAAMyH,QAAQjK,GACPA,EAAc2K,MAAM,GAErB,OAAH,IAAG,CAAH,CACH3G,UAAW7F,OAAO4+B,eAAe/8B,IAC9BA,GAGPq9B,EAAW58B,KAAKT,IAEXA,EC/GU7B,OAAOkG,OAAO,M,uJkCuBjBo7B,EACdz5B,EACAgI,GAEA,IAAI0xB,EAAqB1xB,EAKnB7H,EAA2C,GAwDjD,OAvDAH,EAASI,YAAYkT,SAAQ,SAAA2D,GAG3B,GAAwB,wBAApBA,EAAW1W,KACb,MAAM,WASgB,uBAApB0W,EAAW1W,MACbJ,EAAU1F,KAAKwc,MAMe,qBAAvByiB,IAEG,kBAAA9gC,OAAA,GAKZ8gC,EAAqBv5B,EAAU,GAAGnJ,KAAKgD,OAK9B,2BACNgG,GAAQ,CACXI,YAAa,OAAF,IAAE,CAAF,CACT,CACEG,KAAM,sBACNE,UAAW,QACXihB,aAAc,CACZnhB,KAAM,eACN2hB,WAAY,CACV,CACE3hB,KAAM,iBACNvJ,KAAM,CACJuJ,KAAM,OACNvG,MAAO0/B,QAMd15B,EAASI,erCtF8B,oBAAZ8W,SACb,kBAAdC,WACPA,UAAUC,QCFJ,iBAAAhf,SCAA,iBAAAC,eCEWF,OAAOkG,OAAO,M,oDmCFjC,oEA6BO,IAAIC,EAAW,WAQlB,OAPAA,EAAWnG,OAAOoG,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGhC,EAAI,EAAGiC,EAAIhH,UAAUkB,OAAQ6D,EAAIiC,EAAGjC,IAE5C,IAAK,IAAIwB,KADTQ,EAAI/G,UAAU+E,GACOtE,OAAOjB,UAAUmB,eAAea,KAAKuF,EAAGR,KAAIO,EAAEP,GAAKQ,EAAER,IAE9E,OAAOO,IAEK/G,MAAMe,KAAMd,YAyGzB,SAASk2B,IACZ,IAAK,IAAInvB,EAAI,EAAGhC,EAAI,EAAGoxB,EAAKn2B,UAAUkB,OAAQ6D,EAAIoxB,EAAIpxB,IAAKgC,GAAK/G,UAAU+E,GAAG7D,OACxE,IAAIk1B,EAAItxB,MAAMiC,GAAIsG,EAAI,EAA3B,IAA8BtI,EAAI,EAAGA,EAAIoxB,EAAIpxB,IACzC,IAAK,IAAI3D,EAAIpB,UAAU+E,GAAIsxB,EAAI,EAAGC,EAAKl1B,EAAEF,OAAQm1B,EAAIC,EAAID,IAAKhpB,IAC1D+oB,EAAE/oB,GAAKjM,EAAEi1B,GACjB,OAAOD,I,qDCnJI,SAAS6L,EAAUtiC,EAAWR,GAG3C,IAFuB+O,QAAQvO,GAG7B,MAAM,IAAIF,MAAMN,G,aCEL,SAAS+iC,EAAaC,GACnC,IAAIxN,EAAK30B,UAAUkB,OAAS,QAAsBkL,IAAjBpM,UAAU,GAAmBA,UAAU,GAAKmiC,EAAY3iC,UAAUkB,SACnGyhC,EAAY3iC,UAAUid,OAASkY,EAC/BwN,EAAY3iC,UAAUsO,QAAU6mB,EAE5BhU,MACFwhB,EAAY3iC,UAAUmhB,KAA6BgU,GCZvD,SAAS1U,EAAQC,GAAwT,OAAtOD,EAArD,oBAAXE,QAAoD,kBAApBA,OAAOC,SAAmC,SAAiBF,GAAO,cAAcA,GAA2B,SAAiBA,GAAO,OAAOA,GAAyB,oBAAXC,QAAyBD,EAAIxZ,cAAgByZ,QAAUD,IAAQC,OAAO3gB,UAAY,gBAAkB0gB,IAAyBA,GCQjV,SAASkiB,EAAY5xB,EAAQ6xB,GAMlC,IALA,IAGIC,EAHAC,EAAa,eACb1gB,EAAO,EACP2gB,EAASH,EAAW,GAGhBC,EAAQC,EAAWE,KAAKjyB,EAAOC,QAAU6xB,EAAM91B,MAAQ61B,GAC7DxgB,GAAQ,EACR2gB,EAASH,EAAW,GAAKC,EAAM91B,MAAQ81B,EAAM,GAAGphC,QAGlD,MAAO,CACL2gB,KAAMA,EACN2gB,OAAQA,GChBL,SAASE,EAAcC,GAC5B,OAAOC,EAAoBD,EAASnyB,OAAQ4xB,EAAYO,EAASnyB,OAAQmyB,EAAShyB,QAM7E,SAASiyB,EAAoBpyB,EAAQqyB,GAC1C,IAAIC,EAAwBtyB,EAAOuyB,eAAeP,OAAS,EACvD/xB,EAAOuyB,EAAWF,GAAyBtyB,EAAOC,KAClDwyB,EAAYJ,EAAehhB,KAAO,EAClCqhB,EAAa1yB,EAAOuyB,eAAelhB,KAAO,EAC1CshB,EAAUN,EAAehhB,KAAOqhB,EAChCE,EAAuC,IAAxBP,EAAehhB,KAAaihB,EAAwB,EACnEO,EAAYR,EAAeL,OAASY,EACpCE,EAAc,GAAGp/B,OAAOsM,EAAOlR,KAAM,KAAK4E,OAAOi/B,EAAS,KAAKj/B,OAAOm/B,EAAW,MACjF1hB,EAAQlR,EAAK6N,MAAM,gBACnBilB,EAAe5hB,EAAMshB,GAEzB,GAAIM,EAAariC,OAAS,IAAK,CAK7B,IAJA,IAAIsiC,EAAe1iB,KAAK2iB,MAAMJ,EAAY,IACtCK,EAAmBL,EAAY,GAC/BM,EAAW,GAEN5+B,EAAI,EAAGA,EAAIw+B,EAAariC,OAAQ6D,GAAK,GAC5C4+B,EAAS5gC,KAAKwgC,EAAat2B,MAAMlI,EAAGA,EAAI,KAG1C,OAAOu+B,EAAcM,EAAmB,CAAC,CAAC,GAAG1/B,OAAOi/B,GAAUQ,EAAS,KAAKz/B,OAAOy/B,EAAS12B,MAAM,EAAGu2B,EAAe,GAAG1zB,KAAI,SAAU+zB,GACnI,MAAO,CAAC,GAAIA,MACV,CAAC,CAAC,IAAKb,EAAWU,EAAmB,GAAK,KAAM,CAAC,GAAIC,EAASH,EAAe,OAGnF,OAAOF,EAAcM,EAAmB,CACxC,CAAC,GAAG1/B,OAAOi/B,EAAU,GAAIxhB,EAAMshB,EAAY,IAAK,CAAC,GAAG/+B,OAAOi/B,GAAUI,GAAe,CAAC,GAAIP,EAAWK,EAAY,GAAK,KAAM,CAAC,GAAGn/B,OAAOi/B,EAAU,GAAIxhB,EAAMshB,EAAY,MAGxK,SAASW,EAAmBjiB,GAC1B,IAAImiB,EAAgBniB,EAAMhZ,QAAO,SAAUo7B,GACjCA,EAAK,GAEb,YAAgB33B,IADL23B,EAAK,MAGdC,EAASljB,KAAKmjB,IAAIlkC,MAAM+gB,KAAMgjB,EAAch0B,KAAI,SAAUo0B,GAE5D,OADaA,EAAM,GACLhjC,WAEhB,OAAO4iC,EAAch0B,KAAI,SAAUq0B,GACjC,IAUehiB,EAVXiiB,EAASD,EAAM,GACftiB,EAAOsiB,EAAM,GACjB,OASKnB,EATOgB,GAQG7hB,EARKiiB,GASMljC,QAAUihB,GATLN,EAAO,MAAQA,EAAO,SACpDX,KAAK,MAGV,SAAS8hB,EAAW3+B,GAClB,OAAOS,MAAMT,EAAM,GAAG6c,KAAK,KClDtB,SAASmjB,EAChBllC,EAASmlC,EAAO9zB,EAAQ+zB,EAAW33B,EAAM43B,EAAevlB,GAEtD,IAAIwlB,EAAS3/B,MAAMyH,QAAQ+3B,GAA0B,IAAjBA,EAAMpjC,OAAeojC,OAAQl4B,EAAYk4B,EAAQ,CAACA,QAASl4B,EAG3Fs4B,EAAUl0B,EAEd,IAAKk0B,GAAWD,EAAQ,CACtB,IAAI/3B,EAAO+3B,EAAO,GAClBC,EAAUh4B,GAAQA,EAAKqD,KAAOrD,EAAKqD,IAAIS,OAGzC,IAgBIm0B,EAhBAC,EAAaL,GAEZK,GAAcH,IACjBG,EAAaH,EAAOrmB,QAAO,SAAUymB,EAAMn4B,GAKzC,OAJIA,EAAKqD,KACP80B,EAAK9hC,KAAK2J,EAAKqD,IAAIY,OAGdk0B,IACN,KAGDD,GAAoC,IAAtBA,EAAW1jC,SAC3B0jC,OAAax4B,GAKXm4B,GAAa/zB,EACfm0B,EAAaJ,EAAUz0B,KAAI,SAAUg1B,GACnC,OAAO1C,EAAY5xB,EAAQs0B,MAEpBL,IACTE,EAAaF,EAAOrmB,QAAO,SAAUymB,EAAMn4B,GAKzC,OAJIA,EAAKqD,KACP80B,EAAK9hC,KAAKq/B,EAAY11B,EAAKqD,IAAIS,OAAQ9D,EAAKqD,IAAIY,QAG3Ck0B,IACN,KAGL,IHjDmCviC,EGiD/ByiC,EAAc9lB,EAElB,GAAmB,MAAf8lB,GAAwC,MAAjBP,EAAuB,CAChD,IAAIQ,EAAqBR,EAAcvlB,WHnDhB,UAAlBgB,EAD4B3d,EGsDhB0iC,IHrD4B,OAAV1iC,IGsDjCyiC,EAAcC,GAIlBvkC,OAAOmO,iBAAiB9N,KAAM,CAC5B3B,QAAS,CACPmD,MAAOnD,EAIPqe,YAAY,EACZkZ,UAAU,GAEZuO,UAAW,CAGT3iC,MAAOqiC,QAAcv4B,EAIrBoR,WAAYtP,QAAQy2B,IAEtB/3B,KAAM,CAGJtK,MAAOsK,QAAQR,EAIfoR,WAAYtP,QAAQtB,IAEtB03B,MAAO,CACLhiC,MAAOmiC,QAAUr4B,GAEnBoE,OAAQ,CACNlO,MAAOoiC,QAAWt4B,GAEpBm4B,UAAW,CACTjiC,MAAOsiC,QAAcx4B,GAEvBo4B,cAAe,CACbliC,MAAOkiC,GAETvlB,WAAY,CAGV3c,MAAOyiC,QAAe34B,EAItBoR,WAAYtP,QAAQ62B,MAIpBP,GAAiBA,EAAcn4B,MACjC5L,OAAO8c,eAAezc,KAAM,QAAS,CACnCwB,MAAOkiC,EAAcn4B,MACrBqqB,UAAU,EACVD,cAAc,IAEPh3B,MAAMylC,kBACfzlC,MAAMylC,kBAAkBpkC,KAAMujC,GAE9B5jC,OAAO8c,eAAezc,KAAM,QAAS,CACnCwB,MAAO7C,QAAQ4M,MACfqqB,UAAU,EACVD,cAAc,ICzHb,SAAS0O,EAAY30B,EAAQ6xB,EAAU+C,GAC5C,OAAO,IAAIf,EAAa,iBAAiBngC,OAAOkhC,QAAch5B,EAAWoE,EAAQ,CAAC6xB,ID4HpFgC,EAAa7kC,UAAYiB,OAAOkG,OAAOlH,MAAMD,UAAW,CACtDkH,YAAa,CACXpE,MAAO+hC,GAET/kC,KAAM,CACJgD,MAAO,gBAET5B,SAAU,CACR4B,MAAO,WACL,OASC,SAAoBpC,GACzB,IAAImlC,EAASnlC,EAAMf,QAEnB,GAAIe,EAAMokC,MACR,IAAK,IAAIn3B,EAAM,EAAGm4B,EAAgBplC,EAAMokC,MAAOn3B,EAAMm4B,EAAcpkC,OAAQiM,IAAO,CAChF,IAAIT,EAAO44B,EAAcn4B,GAErBT,EAAKqD,MACPs1B,GAAU,OAAS3C,EAAch2B,EAAKqD,WAGrC,GAAI7P,EAAMsQ,QAAUtQ,EAAM+kC,UAC/B,IAAK,IAAIM,EAAM,EAAGC,EAAoBtlC,EAAM+kC,UAAWM,EAAMC,EAAkBtkC,OAAQqkC,IAAO,CAC5F,IAAI5C,EAAW6C,EAAkBD,GACjCF,GAAU,OAASzC,EAAoB1iC,EAAMsQ,OAAQmyB,GAIzD,OAAO0C,EA3BII,CAAW3kC,UEzIjB,IAAI4kC,EAAOjlC,OAAOsL,OAAO,CAE9B45B,KAAM,OAENC,SAAU,WACVC,qBAAsB,sBACtBC,oBAAqB,qBACrBC,cAAe,eACfC,MAAO,QACPC,SAAU,WAEVC,gBAAiB,iBACjBC,gBAAiB,iBACjBC,oBAAqB,qBAErBC,SAAU,WACVC,IAAK,WACLC,MAAO,aACPC,OAAQ,cACRC,QAAS,eACTC,KAAM,YACNC,KAAM,YACNC,KAAM,YACNC,OAAQ,cACRC,aAAc,cAEdC,UAAW,YAEXC,WAAY,YACZC,UAAW,WACXC,cAAe,cAEfC,kBAAmB,mBACnBC,0BAA2B,0BAE3BC,uBAAwB,uBACxBC,uBAAwB,uBACxBC,iBAAkB,kBAClBC,uBAAwB,uBACxBC,0BAA2B,0BAC3BC,sBAAuB,sBACvBC,qBAAsB,qBACtBC,sBAAuB,sBACvBC,6BAA8B,4BAE9BC,qBAAsB,sBAEtBC,iBAAkB,kBAElBC,sBAAuB,sBACvBC,sBAAuB,sBACvBC,yBAA0B,yBAC1BC,qBAAsB,qBACtBC,oBAAqB,oBACrBC,4BAA6B,6BC9CxB,ICEmClG,EDF/BmG,EAAS,SAAgB73B,EAAMnR,EAAMyjC,GAC9CjiC,KAAK2P,KAAOA,EACZ3P,KAAKxB,KAAOA,GAAQ,kBACpBwB,KAAKiiC,eAAiBA,GAAkB,CACtClhB,KAAM,EACN2gB,OAAQ,GAEV1hC,KAAKiiC,eAAelhB,KAAO,GAAKogB,EAAU,EAAG,4DAC7CnhC,KAAKiiC,eAAeP,OAAS,GAAKP,EAAU,EAAG,+DCNPE,EDSxBmG,ECRM,oBAAXnoB,QAAyBA,OAAOooB,aACzC9nC,OAAO8c,eAAe4kB,EAAY3iC,UAAW2gB,OAAOooB,YAAa,CAC/D7lC,IAAK,WACH,OAAO5B,KAAK4F,YAAYpH,Q,aCbrBkpC,EAAY/nC,OAAOsL,OAAO,CACnC08B,IAAK,QACLC,IAAK,QACLC,KAAM,IACNC,OAAQ,IACRC,IAAK,IACLC,QAAS,IACTC,QAAS,IACTC,OAAQ,MACRC,MAAO,IACPC,OAAQ,IACRC,GAAI,IACJC,UAAW,IACXC,UAAW,IACXC,QAAS,IACTC,KAAM,IACNC,QAAS,IACT7D,KAAM,OACNW,IAAK,MACLC,MAAO,QACPC,OAAQ,SACRiD,aAAc,cACdC,QAAS,YCEX,SAASC,IAGP,OAFA7oC,KAAK8oC,UAAY9oC,KAAK+oC,MACV/oC,KAAK+oC,MAAQ/oC,KAAKgpC,YAIhC,SAASA,IACP,IAAID,EAAQ/oC,KAAK+oC,MAEjB,GAAIA,EAAMhhC,OAAS2/B,EAAUE,IAC3B,GAEEmB,EAAQA,EAAMznC,OAASynC,EAAMznC,KAAO2nC,EAAUjpC,KAAM+oC,UAC7CA,EAAMhhC,OAAS2/B,EAAUkB,SAGpC,OAAOG,EAgBT,SAASG,EAAInhC,EAAM8H,EAAOC,EAAKiR,EAAM2gB,EAAQ70B,EAAMrL,GACjDxB,KAAK+H,KAAOA,EACZ/H,KAAK6P,MAAQA,EACb7P,KAAK8P,IAAMA,EACX9P,KAAK+gB,KAAOA,EACZ/gB,KAAK0hC,OAASA,EACd1hC,KAAKwB,MAAQA,EACbxB,KAAK6M,KAAOA,EACZ7M,KAAKsB,KAAO,KAad,SAAS6nC,EAAcC,GACrB,OACEC,MAAMD,GAAQ1B,EAAUE,IACxBwB,EAAO,IAASjuB,KAAKC,UAAUwE,OAAO0pB,aAAaF,IACnD,OAAQhmC,QAAQ,KAAOgmC,EAAKxpC,SAAS,IAAImpB,eAAe5c,OAAO,GAAI,KAYvE,SAAS88B,EAAUM,EAAO18B,GACxB,IAAI6C,EAAS65B,EAAM75B,OACfC,EAAOD,EAAOC,KACd65B,EAAa75B,EAAKvP,OAClB4jC,EAmLN,SAAiCr0B,EAAM85B,EAAeF,GACpD,IAAIC,EAAa75B,EAAKvP,OAClBmhC,EAAWkI,EAEf,KAAOlI,EAAWiI,GAAY,CAC5B,IAAIJ,EAAOz5B,EAAK+5B,WAAWnI,GAE3B,GAAa,IAAT6H,GAAuB,KAATA,GAAwB,KAATA,GAAwB,QAATA,IAC5C7H,OACG,GAAa,KAAT6H,IAEP7H,IACAgI,EAAMxoB,KACRwoB,EAAMI,UAAYpI,MACb,IAAa,KAAT6H,EAWT,MATsC,KAAlCz5B,EAAK+5B,WAAWnI,EAAW,GAC7BA,GAAY,IAEVA,IAGFgI,EAAMxoB,KACRwoB,EAAMI,UAAYpI,GAMtB,OAAOA,EAhNGqI,CAAwBj6B,EAAM9C,EAAKiD,IAAKy5B,GAC9CxoB,EAAOwoB,EAAMxoB,KACb8oB,EAAM,EAAI7F,EAAMuF,EAAMI,UAE1B,GAAI3F,GAAOwF,EACT,OAAO,IAAIN,EAAIxB,EAAUE,IAAK4B,EAAYA,EAAYzoB,EAAM8oB,EAAKh9B,GAGnE,IAAIu8B,EAAOz5B,EAAK+5B,WAAW1F,GAE3B,OAAQoF,GAEN,KAAK,GACH,OAAO,IAAIF,EAAIxB,EAAUG,KAAM7D,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG1D,KAAK,GACH,OAwMN,SAAqB6C,EAAQG,EAAOkR,EAAM8oB,EAAKh9B,GAC7C,IACIu8B,EADAz5B,EAAOD,EAAOC,KAEd4xB,EAAW1xB,EAEf,GACEu5B,EAAOz5B,EAAK+5B,aAAanI,UACjB8H,MAAMD,KAChBA,EAAO,IAAmB,IAATA,IAEjB,OAAO,IAAIF,EAAIxB,EAAUkB,QAAS/4B,EAAO0xB,EAAUxgB,EAAM8oB,EAAKh9B,EAAM8C,EAAKxD,MAAM0D,EAAQ,EAAG0xB,IAlN/EuI,CAAYp6B,EAAQs0B,EAAKjjB,EAAM8oB,EAAKh9B,GAG7C,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUI,OAAQ9D,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG5D,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUK,IAAK/D,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAGzD,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUM,QAAShE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG7D,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUO,QAASjE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG7D,KAAK,GACH,GAAiC,KAA7B8C,EAAK+5B,WAAW1F,EAAM,IAA0C,KAA7Br0B,EAAK+5B,WAAW1F,EAAM,GAC3D,OAAO,IAAIkF,EAAIxB,EAAUQ,OAAQlE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG5D,MAGF,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUS,MAAOnE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG3D,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUU,OAAQpE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG5D,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUW,GAAIrE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAGxD,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUY,UAAWtE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG/D,KAAK,GACH,OAAO,IAAIq8B,EAAIxB,EAAUa,UAAWvE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG/D,KAAK,IACH,OAAO,IAAIq8B,EAAIxB,EAAUc,QAASxE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG7D,KAAK,IACH,OAAO,IAAIq8B,EAAIxB,EAAUe,KAAMzE,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG1D,KAAK,IACH,OAAO,IAAIq8B,EAAIxB,EAAUgB,QAAS1E,EAAKA,EAAM,EAAGjjB,EAAM8oB,EAAKh9B,GAG7D,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACL,KAAK,IACH,OA+WN,SAAkB6C,EAAQG,EAAOkR,EAAM8oB,EAAKh9B,GAC1C,IAAI8C,EAAOD,EAAOC,KACd65B,EAAa75B,EAAKvP,OAClBmhC,EAAW1xB,EAAQ,EACnBu5B,EAAO,EAEX,KAAO7H,IAAaiI,IAAeH,MAAMD,EAAOz5B,EAAK+5B,WAAWnI,MAAwB,KAAT6H,GAC/EA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,IACtBA,GAAQ,IAAMA,GAAQ,QAElB7H,EAGJ,OAAO,IAAI2H,EAAIxB,EAAU7C,KAAMh1B,EAAO0xB,EAAUxgB,EAAM8oB,EAAKh9B,EAAM8C,EAAKxD,MAAM0D,EAAO0xB,IA7XxEwI,CAASr6B,EAAQs0B,EAAKjjB,EAAM8oB,EAAKh9B,GAG1C,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACL,KAAK,GACH,OA+FN,SAAoB6C,EAAQG,EAAOm6B,EAAWjpB,EAAM8oB,EAAKh9B,GACvD,IAAI8C,EAAOD,EAAOC,KACdy5B,EAAOY,EACPzI,EAAW1xB,EACXo6B,GAAU,EAED,KAATb,IAEFA,EAAOz5B,EAAK+5B,aAAanI,IAG3B,GAAa,KAAT6H,GAIF,IAFAA,EAAOz5B,EAAK+5B,aAAanI,KAEb,IAAM6H,GAAQ,GACxB,MAAM/E,EAAY30B,EAAQ6xB,EAAU,6CAA6Cn+B,OAAO+lC,EAAcC,GAAO,WAG/G7H,EAAW2I,EAAWx6B,EAAQ6xB,EAAU6H,GACxCA,EAAOz5B,EAAK+5B,WAAWnI,GAGZ,KAAT6H,IAEFa,GAAU,EACVb,EAAOz5B,EAAK+5B,aAAanI,GACzBA,EAAW2I,EAAWx6B,EAAQ6xB,EAAU6H,GACxCA,EAAOz5B,EAAK+5B,WAAWnI,IAGZ,KAAT6H,GAAwB,MAATA,IAEjBa,GAAU,EAGG,MAFbb,EAAOz5B,EAAK+5B,aAAanI,KAEG,KAAT6H,IAEjBA,EAAOz5B,EAAK+5B,aAAanI,IAG3BA,EAAW2I,EAAWx6B,EAAQ6xB,EAAU6H,GACxCA,EAAOz5B,EAAK+5B,WAAWnI,IAIzB,GAAa,KAAT6H,GAAwB,KAATA,GAAwB,MAATA,EAChC,MAAM/E,EAAY30B,EAAQ6xB,EAAU,2CAA2Cn+B,OAAO+lC,EAAcC,GAAO,MAG7G,OAAO,IAAIF,EAAIe,EAAUvC,EAAUjC,MAAQiC,EAAUlC,IAAK31B,EAAO0xB,EAAUxgB,EAAM8oB,EAAKh9B,EAAM8C,EAAKxD,MAAM0D,EAAO0xB,IAjJnG4I,CAAWz6B,EAAQs0B,EAAKoF,EAAMroB,EAAM8oB,EAAKh9B,GAGlD,KAAK,GACH,OAAiC,KAA7B8C,EAAK+5B,WAAW1F,EAAM,IAA0C,KAA7Br0B,EAAK+5B,WAAW1F,EAAM,GAyQnE,SAAyBt0B,EAAQG,EAAOkR,EAAM8oB,EAAKh9B,EAAM08B,GACvD,IAAI55B,EAAOD,EAAOC,KACd4xB,EAAW1xB,EAAQ,EACnBu6B,EAAa7I,EACb6H,EAAO,EACPiB,EAAW,GAEf,KAAO9I,EAAW5xB,EAAKvP,SAAWipC,MAAMD,EAAOz5B,EAAK+5B,WAAWnI,KAAY,CAEzE,GAAa,KAAT6H,GAAiD,KAAlCz5B,EAAK+5B,WAAWnI,EAAW,IAA+C,KAAlC5xB,EAAK+5B,WAAWnI,EAAW,GAEpF,OADA8I,GAAY16B,EAAKxD,MAAMi+B,EAAY7I,GAC5B,IAAI2H,EAAIxB,EAAUiB,aAAc94B,EAAO0xB,EAAW,EAAGxgB,EAAM8oB,EAAKh9B,EAAM8T,YAAuB0pB,IAItG,GAAIjB,EAAO,IAAmB,IAATA,GAA4B,KAATA,GAA4B,KAATA,EACzD,MAAM/E,EAAY30B,EAAQ6xB,EAAU,oCAAoCn+B,OAAO+lC,EAAcC,GAAO,MAGzF,KAATA,KAEA7H,IACAgI,EAAMxoB,KACRwoB,EAAMI,UAAYpI,GACA,KAAT6H,GAE6B,KAAlCz5B,EAAK+5B,WAAWnI,EAAW,GAC7BA,GAAY,IAEVA,IAGFgI,EAAMxoB,KACRwoB,EAAMI,UAAYpI,GAEX,KAAT6H,GAAiD,KAAlCz5B,EAAK+5B,WAAWnI,EAAW,IAA+C,KAAlC5xB,EAAK+5B,WAAWnI,EAAW,IAA+C,KAAlC5xB,EAAK+5B,WAAWnI,EAAW,IACxH8I,GAAY16B,EAAKxD,MAAMi+B,EAAY7I,GAAY,MAE/C6I,EADA7I,GAAY,KAGVA,EAIN,MAAM8C,EAAY30B,EAAQ6xB,EAAU,wBApTvB+I,CAAgB56B,EAAQs0B,EAAKjjB,EAAM8oB,EAAKh9B,EAAM08B,GA2K7D,SAAoB75B,EAAQG,EAAOkR,EAAM8oB,EAAKh9B,GAC5C,IAAI8C,EAAOD,EAAOC,KACd4xB,EAAW1xB,EAAQ,EACnBu6B,EAAa7I,EACb6H,EAAO,EACP5nC,EAAQ,GAEZ,KAAO+/B,EAAW5xB,EAAKvP,SAAWipC,MAAMD,EAAOz5B,EAAK+5B,WAAWnI,KACtD,KAAT6H,GAA4B,KAATA,GAAiB,CAElC,GAAa,KAATA,EAEF,OADA5nC,GAASmO,EAAKxD,MAAMi+B,EAAY7I,GACzB,IAAI2H,EAAIxB,EAAUhC,OAAQ71B,EAAO0xB,EAAW,EAAGxgB,EAAM8oB,EAAKh9B,EAAMrL,GAIzE,GAAI4nC,EAAO,IAAmB,IAATA,EACnB,MAAM/E,EAAY30B,EAAQ6xB,EAAU,oCAAoCn+B,OAAO+lC,EAAcC,GAAO,MAKtG,KAFE7H,EAEW,KAAT6H,EAAa,CAKf,OAHA5nC,GAASmO,EAAKxD,MAAMi+B,EAAY7I,EAAW,GAC3C6H,EAAOz5B,EAAK+5B,WAAWnI,IAGrB,KAAK,GACH//B,GAAS,IACT,MAEF,KAAK,GACHA,GAAS,IACT,MAEF,KAAK,GACHA,GAAS,KACT,MAEF,KAAK,GACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IACHA,GAAS,KACT,MAEF,KAAK,IAGD,IAAI+oC,GAwFKjqC,EAxFkBqP,EAAK+5B,WAAWnI,EAAW,GAwF1ChhC,EAxF8CoP,EAAK+5B,WAAWnI,EAAW,GAwFtE7P,EAxF0E/hB,EAAK+5B,WAAWnI,EAAW,GAwFlGh8B,EAxFsGoK,EAAK+5B,WAAWnI,EAAW,GAyFtJiJ,EAASlqC,IAAM,GAAKkqC,EAASjqC,IAAM,EAAIiqC,EAAS9Y,IAAM,EAAI8Y,EAASjlC,IAvFhE,GAAIglC,EAAW,EAAG,CAChB,IAAIE,EAAkB96B,EAAKxD,MAAMo1B,EAAW,EAAGA,EAAW,GAC1D,MAAM8C,EAAY30B,EAAQ6xB,EAAU,yCAAyCn+B,OAAOqnC,EAAiB,MAGvGjpC,GAASoe,OAAO0pB,aAAaiB,GAC7BhJ,GAAY,EACZ,MAGJ,QACE,MAAM8C,EAAY30B,EAAQ6xB,EAAU,wCAAwCn+B,OAAOwc,OAAO0pB,aAAaF,GAAO,QAGhH7H,EACF6I,EAAa7I,GAuEnB,IAAqBjhC,EAAGC,EAAGmxB,EAAGnsB,EAnE5B,MAAM8+B,EAAY30B,EAAQ6xB,EAAU,wBA5PzBmJ,CAAWh7B,EAAQs0B,EAAKjjB,EAAM8oB,EAAKh9B,GAG9C,MAAMw3B,EAAY30B,EAAQs0B,EAO5B,SAAoCoF,GAClC,GAAIA,EAAO,IAAmB,IAATA,GAA4B,KAATA,GAA4B,KAATA,EACzD,MAAO,wCAAwChmC,OAAO+lC,EAAcC,GAAO,KAG7E,GAAa,KAATA,EAEF,MAAO,kFAGT,MAAO,yCAAyChmC,OAAO+lC,EAAcC,GAAO,KAjB7CuB,CAA2BvB,IA6I5D,SAASc,EAAWx6B,EAAQG,EAAOm6B,GACjC,IAAIr6B,EAAOD,EAAOC,KACd4xB,EAAW1xB,EACXu5B,EAAOY,EAEX,GAAIZ,GAAQ,IAAMA,GAAQ,GAAI,CAE5B,GACEA,EAAOz5B,EAAK+5B,aAAanI,SAClB6H,GAAQ,IAAMA,GAAQ,IAG/B,OAAO7H,EAGT,MAAM8C,EAAY30B,EAAQ6xB,EAAU,2CAA2Cn+B,OAAO+lC,EAAcC,GAAO,MA6K7G,SAASoB,EAASlqC,GAChB,OAAOA,GAAK,IAAMA,GAAK,GAAKA,EAAI,GAC9BA,GAAK,IAAMA,GAAK,GAAKA,EAAI,GACzBA,GAAK,IAAMA,GAAK,IAAMA,EAAI,IACzB,EApgBL8gC,EAAa8H,GAAK,WAChB,MAAO,CACLnhC,KAAM/H,KAAK+H,KACXvG,MAAOxB,KAAKwB,MACZuf,KAAM/gB,KAAK+gB,KACX2gB,OAAQ1hC,KAAK0hC,WC1EV,IAAIkJ,EAAoBjrC,OAAOsL,OAAO,CAE3C4/B,MAAO,QACPC,SAAU,WACVC,aAAc,eACd7F,MAAO,QACPI,oBAAqB,sBACrBF,gBAAiB,kBACjBC,gBAAiB,kBACjBL,oBAAqB,sBAErBgG,OAAQ,SACRC,OAAQ,SACRlF,OAAQ,SACRU,iBAAkB,mBAClByE,oBAAqB,sBACrBC,UAAW,YACXC,MAAO,QACPvF,KAAM,OACNwF,WAAY,aACZC,aAAc,eACdC,uBAAwB,2BCVnB,SAASx9B,EAAM2B,EAAQsB,GAE5B,OADa,IAAIw6B,EAAO97B,EAAQsB,GAClBvC,gBAaT,SAASg9B,EAAW/7B,EAAQsB,GACjC,IAAIzJ,EAAS,IAAIikC,EAAO97B,EAAQsB,GAChCzJ,EAAOmkC,YAAYhE,EAAUC,KAC7B,IAAInmC,EAAQ+F,EAAOokC,mBAAkB,GAErC,OADApkC,EAAOmkC,YAAYhE,EAAUE,KACtBpmC,EAaF,SAASoqC,EAAUl8B,EAAQsB,GAChC,IAAIzJ,EAAS,IAAIikC,EAAO97B,EAAQsB,GAChCzJ,EAAOmkC,YAAYhE,EAAUC,KAC7B,IAAIxgC,EAAOI,EAAOskC,qBAElB,OADAtkC,EAAOmkC,YAAYhE,EAAUE,KACtBzgC,EApDT,2HAuDA,IAAIqkC,EAEJ,WACE,SAASA,EAAO97B,EAAQsB,GACtB,IAAI86B,EAA8B,kBAAXp8B,EAAsB,IAAI83B,EAAO93B,GAAUA,EAClEo8B,aAAqBtE,GAAUrG,EAAU,EAAG,kCAAkC/9B,OAAO4J,YAAQ8+B,KAC7F9rC,KAAK+rC,OFhDF,SAAqBr8B,EAAQsB,GAClC,IAAIg7B,EAAmB,IAAI9C,EAAIxB,EAAUC,IAAK,EAAG,EAAG,EAAG,EAAG,MAW1D,MAVY,CACVj4B,OAAQA,EACRsB,QAASA,EACT83B,UAAWkD,EACXjD,MAAOiD,EACPjrB,KAAM,EACN4oB,UAAW,EACXsC,QAASpD,EACTG,UAAWA,GEsCGkD,CAAYJ,GAC1B9rC,KAAKmsC,SAAWn7B,GAAW,GAO7B,IAAIo7B,EAASZ,EAAO9sC,UAy5CpB,OAv5CA0tC,EAAOC,UAAY,WACjB,IAAItD,EAAQ/oC,KAAK0rC,YAAYhE,EAAU7C,MACvC,MAAO,CACL98B,KAAM68B,EAAKC,KACXrjC,MAAOunC,EAAMvnC,MACbyN,IAAKjP,KAAKiP,IAAI85B,KASlBqD,EAAO39B,cAAgB,WACrB,IAAIoB,EAAQ7P,KAAK+rC,OAAOhD,MACxB,MAAO,CACLhhC,KAAM68B,EAAKE,SACXl9B,YAAa5H,KAAKssC,KAAK5E,EAAUC,IAAK3nC,KAAKusC,gBAAiB7E,EAAUE,KACtE34B,IAAKjP,KAAKiP,IAAIY,KAelBu8B,EAAOG,gBAAkB,WACvB,GAAIvsC,KAAKwsC,KAAK9E,EAAU7C,MACtB,OAAQ7kC,KAAK+rC,OAAOhD,MAAMvnC,OACxB,IAAK,QACL,IAAK,WACL,IAAK,eACH,OAAOxB,KAAKysC,2BAEd,IAAK,WACH,OAAOzsC,KAAK0sC,0BAEd,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,YACL,IAAK,QACL,IAAK,OACL,IAAK,QACL,IAAK,YACH,OAAO1sC,KAAK2sC,4BAEd,IAAK,SACH,OAAO3sC,KAAK4sC,+BAEX,IAAI5sC,KAAKwsC,KAAK9E,EAAUc,SAC7B,OAAOxoC,KAAKysC,2BACP,GAAIzsC,KAAK6sC,kBACd,OAAO7sC,KAAK2sC,4BAGd,MAAM3sC,KAAK8sC,cAUbV,EAAOK,yBAA2B,WAChC,IAAI58B,EAAQ7P,KAAK+rC,OAAOhD,MAExB,GAAI/oC,KAAKwsC,KAAK9E,EAAUc,SACtB,MAAO,CACLzgC,KAAM68B,EAAKG,qBACX98B,UAAW,QACXzJ,UAAM8M,EACNwwB,oBAAqB,GACrB1R,WAAY,GACZlB,aAAclpB,KAAK+sC,oBACnB99B,IAAKjP,KAAKiP,IAAIY,IAIlB,IACIrR,EADAyJ,EAAYjI,KAAKgtC,qBAOrB,OAJIhtC,KAAKwsC,KAAK9E,EAAU7C,QACtBrmC,EAAOwB,KAAKqsC,aAGP,CACLtkC,KAAM68B,EAAKG,qBACX98B,UAAWA,EACXzJ,KAAMA,EACNs9B,oBAAqB97B,KAAKitC,2BAC1B7iB,WAAYpqB,KAAKktC,iBAAgB,GACjChkB,aAAclpB,KAAK+sC,oBACnB99B,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOY,mBAAqB,WAC1B,IAAIG,EAAiBntC,KAAK0rC,YAAYhE,EAAU7C,MAEhD,OAAQsI,EAAe3rC,OACrB,IAAK,QACH,MAAO,QAET,IAAK,WACH,MAAO,WAET,IAAK,eACH,MAAO,eAGX,MAAMxB,KAAK8sC,WAAWK,IAOxBf,EAAOa,yBAA2B,WAChC,OAAOjtC,KAAKotC,aAAa1F,EAAUM,QAAShoC,KAAKqtC,wBAAyB3F,EAAUO,UAOtFmE,EAAOiB,wBAA0B,WAC/B,IAAIx9B,EAAQ7P,KAAK+rC,OAAOhD,MACxB,MAAO,CACLhhC,KAAM68B,EAAKI,oBACX/I,SAAUj8B,KAAKstC,gBACfnmC,MAAOnH,KAAK0rC,YAAYhE,EAAUS,OAAQnoC,KAAK6rC,sBAC/C7P,aAAch8B,KAAKutC,oBAAoB7F,EAAUU,QAAUpoC,KAAK2rC,mBAAkB,QAAQrgC,EAC1F8e,WAAYpqB,KAAKktC,iBAAgB,GACjCj+B,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOkB,cAAgB,WACrB,IAAIz9B,EAAQ7P,KAAK+rC,OAAOhD,MAExB,OADA/oC,KAAK0rC,YAAYhE,EAAUI,QACpB,CACL//B,KAAM68B,EAAKW,SACX/mC,KAAMwB,KAAKqsC,YACXp9B,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOW,kBAAoB,WACzB,IAAIl9B,EAAQ7P,KAAK+rC,OAAOhD,MACxB,MAAO,CACLhhC,KAAM68B,EAAKK,cACXvb,WAAY1pB,KAAKssC,KAAK5E,EAAUc,QAASxoC,KAAKwtC,eAAgB9F,EAAUgB,SACxEz5B,IAAKjP,KAAKiP,IAAIY,KAWlBu8B,EAAOoB,eAAiB,WACtB,OAAOxtC,KAAKwsC,KAAK9E,EAAUQ,QAAUloC,KAAKytC,gBAAkBztC,KAAK0tC,cASnEtB,EAAOsB,WAAa,WAClB,IAEIjT,EACAj8B,EAHAqR,EAAQ7P,KAAK+rC,OAAOhD,MACpB4E,EAAc3tC,KAAKqsC,YAWvB,OAPIrsC,KAAKutC,oBAAoB7F,EAAUS,QACrC1N,EAAQkT,EACRnvC,EAAOwB,KAAKqsC,aAEZ7tC,EAAOmvC,EAGF,CACL5lC,KAAM68B,EAAKM,MACXzK,MAAOA,EACPj8B,KAAMA,EACNU,UAAWc,KAAK4tC,gBAAe,GAC/BxjB,WAAYpqB,KAAKktC,iBAAgB,GACjChkB,aAAclpB,KAAKwsC,KAAK9E,EAAUc,SAAWxoC,KAAK+sC,yBAAsBzhC,EACxE2D,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOwB,eAAiB,SAAwBC,GAC9C,IAAItjB,EAAOsjB,EAAU7tC,KAAK8tC,mBAAqB9tC,KAAK+tC,cACpD,OAAO/tC,KAAKotC,aAAa1F,EAAUM,QAASzd,EAAMmd,EAAUO,UAO9DmE,EAAO2B,cAAgB,WACrB,IAAIl+B,EAAQ7P,KAAK+rC,OAAOhD,MACpBvqC,EAAOwB,KAAKqsC,YAEhB,OADArsC,KAAK0rC,YAAYhE,EAAUS,OACpB,CACLpgC,KAAM68B,EAAKO,SACX3mC,KAAMA,EACNgD,MAAOxB,KAAK2rC,mBAAkB,GAC9B18B,IAAKjP,KAAKiP,IAAIY,KAIlBu8B,EAAO0B,mBAAqB,WAC1B,IAAIj+B,EAAQ7P,KAAK+rC,OAAOhD,MACxB,MAAO,CACLhhC,KAAM68B,EAAKO,SACX3mC,KAAMwB,KAAKqsC,YACX7qC,OAAQxB,KAAK0rC,YAAYhE,EAAUS,OAAQnoC,KAAK2rC,mBAAkB,IAClE18B,IAAKjP,KAAKiP,IAAIY,KAalBu8B,EAAOqB,cAAgB,WACrB,IAAI59B,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAK0rC,YAAYhE,EAAUQ,QAC3B,IAAI8F,EAAmBhuC,KAAKiuC,sBAAsB,MAElD,OAAKD,GAAoBhuC,KAAKwsC,KAAK9E,EAAU7C,MACpC,CACL98B,KAAM68B,EAAKQ,gBACX5mC,KAAMwB,KAAKkuC,oBACX9jB,WAAYpqB,KAAKktC,iBAAgB,GACjCj+B,IAAKjP,KAAKiP,IAAIY,IAIX,CACL9H,KAAM68B,EAAKS,gBACX7b,cAAewkB,EAAmBhuC,KAAKmuC,sBAAmB7iC,EAC1D8e,WAAYpqB,KAAKktC,iBAAgB,GACjChkB,aAAclpB,KAAK+sC,oBACnB99B,IAAKjP,KAAKiP,IAAIY,KAWlBu8B,EAAOM,wBAA0B,WAC/B,IAAI78B,EAAQ7P,KAAK+rC,OAAOhD,MAKxB,OAJA/oC,KAAKouC,cAAc,YAIfpuC,KAAKmsC,SAAS39B,8BACT,CACLzG,KAAM68B,EAAKU,oBACX9mC,KAAMwB,KAAKkuC,oBACXpS,oBAAqB97B,KAAKitC,2BAC1BzjB,eAAgBxpB,KAAKouC,cAAc,MAAOpuC,KAAKmuC,kBAC/C/jB,WAAYpqB,KAAKktC,iBAAgB,GACjChkB,aAAclpB,KAAK+sC,oBACnB99B,IAAKjP,KAAKiP,IAAIY,IAIX,CACL9H,KAAM68B,EAAKU,oBACX9mC,KAAMwB,KAAKkuC,oBACX1kB,eAAgBxpB,KAAKouC,cAAc,MAAOpuC,KAAKmuC,kBAC/C/jB,WAAYpqB,KAAKktC,iBAAgB,GACjChkB,aAAclpB,KAAK+sC,oBACnB99B,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAO8B,kBAAoB,WACzB,GAAgC,OAA5BluC,KAAK+rC,OAAOhD,MAAMvnC,MACpB,MAAMxB,KAAK8sC,aAGb,OAAO9sC,KAAKqsC,aAuBdD,EAAOT,kBAAoB,SAA2BkC,GACpD,IAAI9E,EAAQ/oC,KAAK+rC,OAAOhD,MAExB,OAAQA,EAAMhhC,MACZ,KAAK2/B,EAAUY,UACb,OAAOtoC,KAAKquC,UAAUR,GAExB,KAAKnG,EAAUc,QACb,OAAOxoC,KAAKsuC,YAAYT,GAE1B,KAAKnG,EAAUlC,IAGb,OAFAxlC,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKY,IACXhkC,MAAOunC,EAAMvnC,MACbyN,IAAKjP,KAAKiP,IAAI85B,IAGlB,KAAKrB,EAAUjC,MAGb,OAFAzlC,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKa,MACXjkC,MAAOunC,EAAMvnC,MACbyN,IAAKjP,KAAKiP,IAAI85B,IAGlB,KAAKrB,EAAUhC,OACf,KAAKgC,EAAUiB,aACb,OAAO3oC,KAAKuuC,qBAEd,KAAK7G,EAAU7C,KACb,MAAoB,SAAhBkE,EAAMvnC,OAAoC,UAAhBunC,EAAMvnC,OAClCxB,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKe,QACXnkC,MAAuB,SAAhBunC,EAAMvnC,MACbyN,IAAKjP,KAAKiP,IAAI85B,KAES,SAAhBA,EAAMvnC,OACfxB,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKgB,KACX32B,IAAKjP,KAAKiP,IAAI85B,MAIlB/oC,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKiB,KACXrkC,MAAOunC,EAAMvnC,MACbyN,IAAKjP,KAAKiP,IAAI85B,KAGlB,KAAKrB,EAAUI,OACb,IAAK+F,EACH,OAAO7tC,KAAKstC,gBAMlB,MAAMttC,KAAK8sC,cAGbV,EAAOmC,mBAAqB,WAC1B,IAAIxF,EAAQ/oC,KAAK+rC,OAAOhD,MAIxB,OAFA/oC,KAAK+rC,OAAOE,UAEL,CACLlkC,KAAM68B,EAAKc,OACXlkC,MAAOunC,EAAMvnC,MACbgtC,MAAOzF,EAAMhhC,OAAS2/B,EAAUiB,aAChC15B,IAAKjP,KAAKiP,IAAI85B,KAUlBqD,EAAOiC,UAAY,SAAmBR,GACpC,IAAIrtC,EAAQR,KAER6P,EAAQ7P,KAAK+rC,OAAOhD,MAMxB,MAAO,CACLhhC,KAAM68B,EAAKkB,KACX5L,OAAQl6B,KAAKyuC,IAAI/G,EAAUY,WANlB,WACT,OAAO9nC,EAAMmrC,kBAAkBkC,KAKanG,EAAUa,WACtDt5B,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOkC,YAAc,SAAqBT,GACxC,IAAIjW,EAAS53B,KAET6P,EAAQ7P,KAAK+rC,OAAOhD,MAMxB,MAAO,CACLhhC,KAAM68B,EAAKmB,OACXjM,OAAQ95B,KAAKyuC,IAAI/G,EAAUc,SANlB,WACT,OAAO5Q,EAAO8W,iBAAiBb,KAKWnG,EAAUgB,SACpDz5B,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOsC,iBAAmB,SAA0Bb,GAClD,IAAIh+B,EAAQ7P,KAAK+rC,OAAOhD,MACpBvqC,EAAOwB,KAAKqsC,YAEhB,OADArsC,KAAK0rC,YAAYhE,EAAUS,OACpB,CACLpgC,KAAM68B,EAAKoB,aACXxnC,KAAMA,EACNgD,MAAOxB,KAAK2rC,kBAAkBkC,GAC9B5+B,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAOc,gBAAkB,SAAyBW,GAGhD,IAFA,IAAIzjB,EAAa,GAEVpqB,KAAKwsC,KAAK9E,EAAUW,KACzBje,EAAWnoB,KAAKjC,KAAK2uC,eAAed,IAGtC,OAAOzjB,GAOTgiB,EAAOuC,eAAiB,SAAwBd,GAC9C,IAAIh+B,EAAQ7P,KAAK+rC,OAAOhD,MAExB,OADA/oC,KAAK0rC,YAAYhE,EAAUW,IACpB,CACLtgC,KAAM68B,EAAKqB,UACXznC,KAAMwB,KAAKqsC,YACXntC,UAAWc,KAAK4tC,eAAeC,GAC/B5+B,IAAKjP,KAAKiP,IAAIY,KAYlBu8B,EAAOP,mBAAqB,WAC1B,IACI1kC,EADA0I,EAAQ7P,KAAK+rC,OAAOhD,MAexB,OAZI/oC,KAAKutC,oBAAoB7F,EAAUY,YACrCnhC,EAAOnH,KAAK6rC,qBACZ7rC,KAAK0rC,YAAYhE,EAAUa,WAC3BphC,EAAO,CACLY,KAAM68B,EAAKuB,UACXh/B,KAAMA,EACN8H,IAAKjP,KAAKiP,IAAIY,KAGhB1I,EAAOnH,KAAKmuC,iBAGVnuC,KAAKutC,oBAAoB7F,EAAUG,MAC9B,CACL9/B,KAAM68B,EAAKwB,cACXj/B,KAAMA,EACN8H,IAAKjP,KAAKiP,IAAIY,IAIX1I,GAOTilC,EAAO+B,eAAiB,WACtB,IAAIt+B,EAAQ7P,KAAK+rC,OAAOhD,MACxB,MAAO,CACLhhC,KAAM68B,EAAKsB,WACX1nC,KAAMwB,KAAKqsC,YACXp9B,IAAKjP,KAAKiP,IAAIY,KAoBlBu8B,EAAOO,0BAA4B,WAEjC,IAAIiC,EAAe5uC,KAAK6sC,kBAAoB7sC,KAAK+rC,OAAO/C,YAAchpC,KAAK+rC,OAAOhD,MAElF,GAAI6F,EAAa7mC,OAAS2/B,EAAU7C,KAClC,OAAQ+J,EAAaptC,OACnB,IAAK,SACH,OAAOxB,KAAK6uC,wBAEd,IAAK,SACH,OAAO7uC,KAAK8uC,4BAEd,IAAK,OACH,OAAO9uC,KAAK+uC,4BAEd,IAAK,YACH,OAAO/uC,KAAKgvC,+BAEd,IAAK,QACH,OAAOhvC,KAAKivC,2BAEd,IAAK,OACH,OAAOjvC,KAAKkvC,0BAEd,IAAK,QACH,OAAOlvC,KAAKmvC,iCAEd,IAAK,YACH,OAAOnvC,KAAKovC,2BAIlB,MAAMpvC,KAAK8sC,WAAW8B,IAGxBxC,EAAOS,gBAAkB,WACvB,OAAO7sC,KAAKwsC,KAAK9E,EAAUhC,SAAW1lC,KAAKwsC,KAAK9E,EAAUiB,eAO5DyD,EAAOiD,iBAAmB,WACxB,GAAIrvC,KAAK6sC,kBACP,OAAO7sC,KAAKuuC,sBAQhBnC,EAAOyC,sBAAwB,WAC7B,IAAIh/B,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnB,IAAIhkB,EAAapqB,KAAKktC,iBAAgB,GAClCoC,EAAiBtvC,KAAKssC,KAAK5E,EAAUc,QAASxoC,KAAKuvC,6BAA8B7H,EAAUgB,SAC/F,MAAO,CACL3gC,KAAM68B,EAAKyB,kBACXjc,WAAYA,EACZklB,eAAgBA,EAChBrgC,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOmD,6BAA+B,WACpC,IAAI1/B,EAAQ7P,KAAK+rC,OAAOhD,MACpB9gC,EAAYjI,KAAKgtC,qBACrBhtC,KAAK0rC,YAAYhE,EAAUS,OAC3B,IAAIhhC,EAAOnH,KAAKmuC,iBAChB,MAAO,CACLpmC,KAAM68B,EAAK0B,0BACXr+B,UAAWA,EACXd,KAAMA,EACN8H,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAO0C,0BAA4B,WACjC,IAAIj/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,UACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GACtC,MAAO,CACLnlC,KAAM68B,EAAK2B,uBACXjC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZnb,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAO2C,0BAA4B,WACjC,IAAIl/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,QACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZmD,EAAaxvC,KAAKyvC,4BAClBrlB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAK0vC,wBAClB,MAAO,CACL3nC,KAAM68B,EAAK4B,uBACXlC,YAAaA,EACb9lC,KAAMA,EACNgxC,WAAYA,EACZplB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOqD,0BAA4B,WACjC,IAAIE,EAAQ,GAEZ,GAAI3vC,KAAKiuC,sBAAsB,cAAe,CAE5CjuC,KAAKutC,oBAAoB7F,EAAUK,KAEnC,GACE4H,EAAM1tC,KAAKjC,KAAKmuC,wBACTnuC,KAAKutC,oBAAoB7F,EAAUK,MAC5C/nC,KAAKmsC,SAASyD,oCAAsC5vC,KAAKwsC,KAAK9E,EAAU7C,OAG1E,OAAO8K,GAOTvD,EAAOsD,sBAAwB,WAE7B,OAAI1vC,KAAKmsC,SAAS0D,2BAA6B7vC,KAAKwsC,KAAK9E,EAAUc,UAAYxoC,KAAK+rC,OAAO/C,YAAYjhC,OAAS2/B,EAAUgB,SACxH1oC,KAAK+rC,OAAOE,UAEZjsC,KAAK+rC,OAAOE,UAEL,IAGFjsC,KAAKotC,aAAa1F,EAAUc,QAASxoC,KAAK8vC,qBAAsBpI,EAAUgB,UAQnF0D,EAAO0D,qBAAuB,WAC5B,IAAIjgC,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACnB7wC,EAAOwB,KAAKqsC,YACZtoC,EAAO/D,KAAK+vC,oBAChB/vC,KAAK0rC,YAAYhE,EAAUS,OAC3B,IAAIhhC,EAAOnH,KAAK6rC,qBACZzhB,EAAapqB,KAAKktC,iBAAgB,GACtC,MAAO,CACLnlC,KAAM68B,EAAK6B,iBACXnC,YAAaA,EACb9lC,KAAMA,EACNU,UAAW6E,EACXoD,KAAMA,EACNijB,WAAYA,EACZnb,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAO2D,kBAAoB,WACzB,OAAO/vC,KAAKotC,aAAa1F,EAAUM,QAAShoC,KAAKgwC,mBAAoBtI,EAAUO,UAQjFmE,EAAO4D,mBAAqB,WAC1B,IAAIngC,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACnB7wC,EAAOwB,KAAKqsC,YAChBrsC,KAAK0rC,YAAYhE,EAAUS,OAC3B,IACInM,EADA70B,EAAOnH,KAAK6rC,qBAGZ7rC,KAAKutC,oBAAoB7F,EAAUU,UACrCpM,EAAeh8B,KAAK2rC,mBAAkB,IAGxC,IAAIvhB,EAAapqB,KAAKktC,iBAAgB,GACtC,MAAO,CACLnlC,KAAM68B,EAAK8B,uBACXpC,YAAaA,EACb9lC,KAAMA,EACN2I,KAAMA,EACN60B,aAAcA,EACd5R,WAAYA,EACZnb,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAO4C,6BAA+B,WACpC,IAAIn/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,aACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAK0vC,wBAClB,MAAO,CACL3nC,KAAM68B,EAAK+B,0BACXrC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAO6C,yBAA2B,WAChC,IAAIp/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,SACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCyC,EAAQ3vC,KAAKiwC,wBACjB,MAAO,CACLloC,KAAM68B,EAAKgC,sBACXtC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZulB,MAAOA,EACP1gC,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAO6D,sBAAwB,WAC7B,IAAIN,EAAQ,GAEZ,GAAI3vC,KAAKutC,oBAAoB7F,EAAUU,QAAS,CAE9CpoC,KAAKutC,oBAAoB7F,EAAUe,MAEnC,GACEkH,EAAM1tC,KAAKjC,KAAKmuC,wBACTnuC,KAAKutC,oBAAoB7F,EAAUe,OAG9C,OAAOkH,GAQTvD,EAAO8C,wBAA0B,WAC/B,IAAIr/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,QACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClChT,EAASl6B,KAAKkwC,4BAClB,MAAO,CACLnoC,KAAM68B,EAAKiC,qBACXvC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZ8P,OAAQA,EACRjrB,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAO8D,0BAA4B,WACjC,OAAOlwC,KAAKotC,aAAa1F,EAAUc,QAASxoC,KAAKmwC,yBAA0BzI,EAAUgB,UASvF0D,EAAO+D,yBAA2B,WAChC,IAAItgC,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACnB7wC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GACtC,MAAO,CACLnlC,KAAM68B,EAAKkC,sBACXxC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZnb,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAO+C,+BAAiC,WACtC,IAAIt/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,SACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAKowC,6BAClB,MAAO,CACLroC,KAAM68B,EAAKmC,6BACXzC,YAAaA,EACb9lC,KAAMA,EACN4rB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KAQlBu8B,EAAOgE,2BAA6B,WAClC,OAAOpwC,KAAKotC,aAAa1F,EAAUc,QAASxoC,KAAKgwC,mBAAoBtI,EAAUgB,UAiBjF0D,EAAOQ,yBAA2B,WAChC,IAAIgC,EAAe5uC,KAAK+rC,OAAO/C,YAE/B,GAAI4F,EAAa7mC,OAAS2/B,EAAU7C,KAClC,OAAQ+J,EAAaptC,OACnB,IAAK,SACH,OAAOxB,KAAKqwC,uBAEd,IAAK,SACH,OAAOrwC,KAAKswC,2BAEd,IAAK,OACH,OAAOtwC,KAAKuwC,2BAEd,IAAK,YACH,OAAOvwC,KAAKwwC,8BAEd,IAAK,QACH,OAAOxwC,KAAKywC,0BAEd,IAAK,OACH,OAAOzwC,KAAK0wC,yBAEd,IAAK,QACH,OAAO1wC,KAAK2wC,gCAIlB,MAAM3wC,KAAK8sC,WAAW8B,IASxBxC,EAAOiE,qBAAuB,WAC5B,IAAIxgC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,UACnB,IAAIhkB,EAAapqB,KAAKktC,iBAAgB,GAClCoC,EAAiBtvC,KAAKotC,aAAa1F,EAAUc,QAASxoC,KAAKuvC,6BAA8B7H,EAAUgB,SAEvG,GAA0B,IAAtBte,EAAWhqB,QAA0C,IAA1BkvC,EAAelvC,OAC5C,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAKqC,iBACX7c,WAAYA,EACZklB,eAAgBA,EAChBrgC,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAOkE,yBAA2B,WAChC,IAAIzgC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,UACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAEtC,GAA0B,IAAtB9iB,EAAWhqB,OACb,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAKsC,sBACX1oC,KAAMA,EACN4rB,WAAYA,EACZnb,IAAKjP,KAAKiP,IAAIY,KAWlBu8B,EAAOmE,yBAA2B,WAChC,IAAI1gC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,QACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZmD,EAAaxvC,KAAKyvC,4BAClBrlB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAK0vC,wBAElB,GAA0B,IAAtBF,EAAWpvC,QAAsC,IAAtBgqB,EAAWhqB,QAAkC,IAAlB05B,EAAO15B,OAC/D,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAKuC,sBACX3oC,KAAMA,EACNgxC,WAAYA,EACZplB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOoE,4BAA8B,WACnC,IAAI3gC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,aACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAK0vC,wBAElB,GAA0B,IAAtBtlB,EAAWhqB,QAAkC,IAAlB05B,EAAO15B,OACpC,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAKwC,yBACX5oC,KAAMA,EACN4rB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOqE,wBAA0B,WAC/B,IAAI5gC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,SACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCyC,EAAQ3vC,KAAKiwC,wBAEjB,GAA0B,IAAtB7lB,EAAWhqB,QAAiC,IAAjBuvC,EAAMvvC,OACnC,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAKyC,qBACX7oC,KAAMA,EACN4rB,WAAYA,EACZulB,MAAOA,EACP1gC,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOsE,uBAAyB,WAC9B,IAAI7gC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,QACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClChT,EAASl6B,KAAKkwC,4BAElB,GAA0B,IAAtB9lB,EAAWhqB,QAAkC,IAAlB85B,EAAO95B,OACpC,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAK0C,oBACX9oC,KAAMA,EACN4rB,WAAYA,EACZ8P,OAAQA,EACRjrB,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOuE,8BAAgC,WACrC,IAAI9gC,EAAQ7P,KAAK+rC,OAAOhD,MACxB/oC,KAAKouC,cAAc,UACnBpuC,KAAKouC,cAAc,SACnB,IAAI5vC,EAAOwB,KAAKqsC,YACZjiB,EAAapqB,KAAKktC,iBAAgB,GAClCpT,EAAS95B,KAAKowC,6BAElB,GAA0B,IAAtBhmB,EAAWhqB,QAAkC,IAAlB05B,EAAO15B,OACpC,MAAMJ,KAAK8sC,aAGb,MAAO,CACL/kC,KAAM68B,EAAK2C,4BACX/oC,KAAMA,EACN4rB,WAAYA,EACZ0P,OAAQA,EACR7qB,IAAKjP,KAAKiP,IAAIY,KASlBu8B,EAAOgD,yBAA2B,WAChC,IAAIv/B,EAAQ7P,KAAK+rC,OAAOhD,MACpBzE,EAActkC,KAAKqvC,mBACvBrvC,KAAKouC,cAAc,aACnBpuC,KAAK0rC,YAAYhE,EAAUW,IAC3B,IAAI7pC,EAAOwB,KAAKqsC,YACZtoC,EAAO/D,KAAK+vC,oBACZa,EAAa5wC,KAAKiuC,sBAAsB,cAC5CjuC,KAAKouC,cAAc,MACnB,IAAIjK,EAAYnkC,KAAK6wC,0BACrB,MAAO,CACL9oC,KAAM68B,EAAKoC,qBACX1C,YAAaA,EACb9lC,KAAMA,EACNU,UAAW6E,EACX6sC,WAAYA,EACZzM,UAAWA,EACXl1B,IAAKjP,KAAKiP,IAAIY,KAUlBu8B,EAAOyE,wBAA0B,WAE/B7wC,KAAKutC,oBAAoB7F,EAAUe,MACnC,IAAItE,EAAY,GAEhB,GACEA,EAAUliC,KAAKjC,KAAK8wC,gCACb9wC,KAAKutC,oBAAoB7F,EAAUe,OAE5C,OAAOtE,GA+BTiI,EAAO0E,uBAAyB,WAC9B,IAAIjhC,EAAQ7P,KAAK+rC,OAAOhD,MACpBvqC,EAAOwB,KAAKqsC,YAEhB,QAAsC/gC,IAAlCs/B,EAAkBpsC,EAAKgD,OACzB,OAAOhD,EAGT,MAAMwB,KAAK8sC,WAAWj9B,IASxBu8B,EAAOn9B,IAAM,SAAaC,GACxB,IAAKlP,KAAKmsC,SAAS4E,WACjB,OAAO,IAAIC,EAAI9hC,EAAYlP,KAAK+rC,OAAOjD,UAAW9oC,KAAK+rC,OAAOr8B,SAQlE08B,EAAOI,KAAO,SAAczkC,GAC1B,OAAO/H,KAAK+rC,OAAOhD,MAAMhhC,OAASA,GAQpCqkC,EAAOV,YAAc,SAAqB3jC,GACxC,IAAIghC,EAAQ/oC,KAAK+rC,OAAOhD,MAExB,GAAIA,EAAMhhC,OAASA,EAGjB,OAFA/H,KAAK+rC,OAAOE,UAELlD,EAGT,MAAM1E,EAAYrkC,KAAK+rC,OAAOr8B,OAAQq5B,EAAMl5B,MAAO,YAAYzM,OAAO2E,EAAM,YAAY3E,OAAO6tC,EAAalI,MAQ9GqD,EAAOmB,oBAAsB,SAA6BxlC,GACxD,IAAIghC,EAAQ/oC,KAAK+rC,OAAOhD,MAExB,GAAIA,EAAMhhC,OAASA,EAGjB,OAFA/H,KAAK+rC,OAAOE,UAELlD,GAWXqD,EAAOgC,cAAgB,SAAuB5sC,GAC5C,IAAIunC,EAAQ/oC,KAAK+rC,OAAOhD,MAExB,GAAIA,EAAMhhC,OAAS2/B,EAAU7C,MAAQkE,EAAMvnC,QAAUA,EAGnD,MAAM6iC,EAAYrkC,KAAK+rC,OAAOr8B,OAAQq5B,EAAMl5B,MAAO,aAAczM,OAAO5B,EAAO,aAAc4B,OAAO6tC,EAAalI,KAFjH/oC,KAAK+rC,OAAOE,WAWhBG,EAAO6B,sBAAwB,SAA+BzsC,GAC5D,IAAIunC,EAAQ/oC,KAAK+rC,OAAOhD,MAExB,OAAIA,EAAMhhC,OAAS2/B,EAAU7C,MAAQkE,EAAMvnC,QAAUA,IACnDxB,KAAK+rC,OAAOE,WAEL,IAWXG,EAAOU,WAAa,SAAoBoE,GACtC,IAAInI,EAAQmI,GAAWlxC,KAAK+rC,OAAOhD,MACnC,OAAO1E,EAAYrkC,KAAK+rC,OAAOr8B,OAAQq5B,EAAMl5B,MAAO,cAAczM,OAAO6tC,EAAalI,MAUxFqD,EAAOqC,IAAM,SAAa0C,EAAUC,EAASC,GAC3CrxC,KAAK0rC,YAAYyF,GAGjB,IAFA,IAAI3N,EAAQ,IAEJxjC,KAAKutC,oBAAoB8D,IAC/B7N,EAAMvhC,KAAKmvC,EAAQ1wC,KAAKV,OAG1B,OAAOwjC,GAWT4I,EAAOgB,aAAe,SAAsB+D,EAAUC,EAASC,GAC7D,GAAIrxC,KAAKutC,oBAAoB4D,GAAW,CACtC,IAAI3N,EAAQ,GAEZ,GACEA,EAAMvhC,KAAKmvC,EAAQ1wC,KAAKV,cAChBA,KAAKutC,oBAAoB8D,IAEnC,OAAO7N,EAGT,MAAO,IAUT4I,EAAOE,KAAO,SAAc6E,EAAUC,EAASC,GAC7CrxC,KAAK0rC,YAAYyF,GACjB,IAAI3N,EAAQ,GAEZ,GACEA,EAAMvhC,KAAKmvC,EAAQ1wC,KAAKV,cAChBA,KAAKutC,oBAAoB8D,IAEnC,OAAO7N,GAGFgI,EAr6CT,GAw6CA,SAASwF,EAAI9hC,EAAYC,EAAUO,GACjC1P,KAAK6P,MAAQX,EAAWW,MACxB7P,KAAK8P,IAAMX,EAASW,IACpB9P,KAAKkP,WAAaA,EAClBlP,KAAKmP,SAAWA,EAChBnP,KAAK0P,OAASA,EAchB,SAASuhC,EAAalI,GACpB,IAAIvnC,EAAQunC,EAAMvnC,MAClB,OAAOA,EAAQ,GAAG4B,OAAO2lC,EAAMhhC,KAAM,MAAO3E,OAAO5B,EAAO,KAAQunC,EAAMhhC,KAZ1Eq5B,EAAa4P,GAAK,WAChB,MAAO,CACLnhC,MAAO7P,KAAK6P,MACZC,IAAK9P,KAAK8P,S,gECr+CEwhC,EAAclyB,GAgB5B,MAL0B,CACxBrX,KAAM,WACNH,YAAa,CAZqB,CAClCG,KAAM,sBACNE,UAAW,QACXzJ,KAAM,CACJuJ,KAAM,OACNvG,MAAO,wBAET0nB,aAAcqoB,EAAoBnyB,MAoCtC,SAASmyB,EAAoBnyB,GAC3B,GACiB,kBAARA,GACQ,mBAARA,GACQ,kBAARA,GACQ,qBAARA,GACC,OAARA,EAGA,OAAO,KAGT,GAAIpb,MAAMyH,QAAQ2T,GAEhB,OAAOmyB,EAAoBnyB,EAAI,IAIjC,IAAMsK,EAA0B,GAsBhC,OApBA/pB,OAAOmB,KAAKse,GAAKtE,SAAQ,SAAA7Z,GACvB,IAEM0oB,EAAmB,CACvB5hB,KAAM,QACNvJ,KAAM,CACJuJ,KAAM,OACNvG,MAAOP,GAETioB,aARqCqoB,EAAoBnyB,EAAIne,UAQ/BqK,GAGhCoe,EAAWznB,KAAK0nB,MAGqB,CACrC5hB,KAAM,eACN2hB,WAAU,GAMP,IC7FU8nB,ED6FJC,EAAkC,CAC7C1pC,KAAM,WACNH,YAAa,CACX,CACEG,KAAM,sBACNE,UAAW,QACXzJ,KAAM,KACNs9B,oBAAqB,KACrB1R,WAAY,GACZlB,aAAc,CACZnhB,KAAM,eACN2hB,WAAY,CACV,CACE3hB,KAAM,QACN0yB,MAAO,KACPj8B,KAAM,CACJuJ,KAAM,OACNvG,MAAO,cAETtC,UAAW,GACXkrB,WAAY,GACZlB,aAAc,W,aE5G1B,cA6IA,OA/FS,8BAAP,SAAyB,GACvB,OAAO,GAGF,6BAAP,SAAwB,GACtB,OAAO,GASF,sBAAP,SACE,EACA,GAEA,YAFA,cAEO,KAAK,KAAK,CACf,MAAO,EAAQ,MACf,UAAW,EAAQ,UACnB,WAAU,KAIP,yBAAP,SACE,EACA,GAEA,YAFA,cAEO,KAAK,KAAK,CACf,MAAO,YAAyB,EAAQ,SAAU,EAAQ,cAC1D,UAAW,EAAQ,UACnB,OAAQ,EAAQ,GAChB,WAAU,KAIP,uBAAP,SACE,GAEA,KAAK,MAAM,CACT,OAAQ,aACR,OAAQ,EAAQ,KAChB,MAAO,EAAQ,MACf,UAAW,EAAQ,aAIhB,0BAAP,SACE,GAEA,KAAK,MAAM,CACT,OAAQ,EAAQ,GAChB,OAAQ,EAAQ,KAChB,UAAW,EAAQ,UACnB,MAAO,YAAyB,EAAQ,SAAU,EAAQ,iBAIvD,sBAAP,SAA8B,G,IFtFC9J,EAAU4gB,EEuFvC,OACA,SAEA,GAAkB,qBAAP,EAAoB,CAC7B,IAAI,EAAiB,KAKrB,IACE,EAAiB,KAAK,KAAU,CAC9B,OAAQ,EACR,YAAY,EACZ,MAAO,IAET,MAAO,IAKT,IAAM,EACH,GAAkB,EAAe,YAAe,eAG7C,EAAc,OAAO,OAAO,CAAE,WAAU,GAAI,GAElD,KAAK,cAAc,CACjB,GAAE,EACF,UFnHyB5gB,EEmHE,EFnHQ4gB,EEmHK,EFlGpB,CACxBj4B,KAAM,WACNH,YAAa,CAlBsB,CACnCG,KAAM,qBACNyhB,cAAe,CACbzhB,KAAM,YACNvJ,KAAM,CACJuJ,KAAM,OACNvG,MAAOw+B,GAAY,eAGvBxhC,KAAM,CACJuJ,KAAM,OACNvG,MAAO,wBAET0nB,aAAcqoB,EAAoBnyB,OEsG9B,KAAM,SAGR,KAAK,WAAW,CAAE,MAAO,EAAc,GAAO,KAAI,KAGxD,E,GDnJiBoyB,MAAK,I,sBEMlBE,EAAiC,KAI/BC,EAAqB,GAEvBzmB,EAAY,EAwHV0mB,EAAO5tC,MAEA6tC,EAAyCD,EAHpC,sBAGuD,WACvE,IAAMC,EAtHoB,wBAIV,KAAArhB,GAAK,CACnB,OACAtF,IACA4mB,KAAKC,MACL/xB,KAAKgyB,SAASpyC,SAAS,IAAIuM,MAAM,IACjCiU,KAAK,KA+FT,OA7FS,YAAA6X,SAAP,WACE,IAAK,IAAI,EAAUyZ,EAAgB,EAAS,EAAU,EAAQ7lC,OAG5D,GAAI7L,KAAKwwB,MAAM,EAAQyhB,MAAO,CAC5B,IAAMzwC,EAAQ,EAAQywC,MAAMjyC,KAAKwwB,IACjC,GAAIhvB,IAAUmwC,EAAe,MAO7B,OANI,IAAYD,IAIdA,EAAgBO,MAAMjyC,KAAKwwB,IAAMhvB,IAE5B,EASX,OANIkwC,IAIFA,EAAeO,MAAMjyC,KAAKwwB,IAAMmhB,IAE3B,GAGF,YAAAO,SAAP,WACE,GAAIlyC,KAAKi4B,WACP,OAAOyZ,EAAgBO,MAAMjyC,KAAKwwB,KAI/B,YAAA2hB,UAAP,SACE3wC,EACAK,EAGAkC,EACAqwB,G,MAEM6d,IAAK,GACTzsC,UAAW,OACVxF,KAAKwwB,IAAKhvB,EACZ,GACKqK,EAAS6lC,EACfA,EAAiB,CAAE7lC,OAAM,EAAEomC,MAAK,GAChC,IAGE,OAAOpwC,EAAS5C,MAAMm1B,EAAUrwB,GAHlC,QAKE2tC,EAAiB7lC,IAMd,EAAA4I,KAAP,SACE5S,GAEA,IAAMiF,EAAU4qC,EAChB,OAAO,WACL,IAAMU,EAAQV,EACd,IAEE,OADAA,EAAiB5qC,EACVjF,EAAS5C,MAAMe,KAAMd,WAF9B,QAIEwyC,EAAiBU,KAMhB,EAAAC,UAAP,SACExwC,EAGAkC,EACAqwB,GAEA,IAAIsd,EAWF,OAAO7vC,EAAS5C,MAAMm1B,EAAUrwB,GAVhC,IAAMquC,EAAQV,EACd,IAIE,OAHAA,EAAiB,KAGV7vC,EAAS5C,MAAMm1B,EAAUrwB,GAJlC,QAME2tC,EAAiBU,IAMzB,EAxG4B,GAuH1B,IACEzyC,OAAO8c,eAAem1B,EANR,oBAMyB,CACrCpwC,MAAOowC,EAPK,qBAOaC,EACzBn1B,YAAY,EACZkZ,UAAU,EACVD,cAAc,IALlB,QAQE,OAAOkc,GAV8D,GCtI1D,OAAM,YFKrB,SAASS,KAET,iBAKE,WACUnP,EACDoP,QADC,IAAApP,MAAA,UACD,IAAAoP,MAAA,GADC,KAAApP,MACD,KAAAoP,UAND,KAAAvjC,IAAM,IAAI/H,IACV,KAAAurC,OAA4B,KAC5B,KAAAC,OAA4B,KAsGtC,OA/FS,YAAA9wC,IAAP,SAAWV,GACT,OAAOjB,KAAKgP,IAAIrN,IAAIV,IAGf,YAAAW,IAAP,SAAWX,GACT,IAAMyxC,EAAQ1yC,KAAK2yC,SAAS1xC,GAC5B,OAAOyxC,GAASA,EAAMlxC,OAGhB,YAAAmxC,SAAR,SAAiB1xC,GACf,IAAMyxC,EAAQ1yC,KAAKgP,IAAIpN,IAAIX,GAE3B,GAAIyxC,GAASA,IAAU1yC,KAAKwyC,OAAQ,CAC1B,IAAAI,EAAA,EAAAA,MAAOC,EAAA,EAAAA,MAEXA,IACFA,EAAMD,MAAQA,GAGZA,IACFA,EAAMC,MAAQA,GAGhBH,EAAME,MAAQ5yC,KAAKwyC,OACnBE,EAAME,MAAOC,MAAQH,EAErBA,EAAMG,MAAQ,KACd7yC,KAAKwyC,OAASE,EAEVA,IAAU1yC,KAAKyyC,SACjBzyC,KAAKyyC,OAASI,GAIlB,OAAOH,GAGF,YAAA7hC,IAAP,SAAW5P,EAAQO,GACjB,IAAIkxC,EAAQ1yC,KAAK2yC,SAAS1xC,GAC1B,OAAIyxC,EACKA,EAAMlxC,MAAQA,GAGvBkxC,EAAQ,CACNzxC,IAAKA,EACLO,MAAOA,EACPqxC,MAAO,KACPD,MAAO5yC,KAAKwyC,QAGVxyC,KAAKwyC,SACPxyC,KAAKwyC,OAAOK,MAAQH,GAGtB1yC,KAAKwyC,OAASE,EACd1yC,KAAKyyC,OAASzyC,KAAKyyC,QAAUC,EAE7B1yC,KAAKgP,IAAI6B,IAAI5P,EAAKyxC,GAEXA,EAAMlxC,QAGR,YAAAsxC,MAAP,WACE,KAAO9yC,KAAKyyC,QAAUzyC,KAAKgP,IAAI9N,KAAOlB,KAAKmjC,KACzCnjC,KAAKmjB,OAAOnjB,KAAKyyC,OAAOxxC,MAIrB,YAAAkiB,OAAP,SAAcliB,GACZ,IAAMyxC,EAAQ1yC,KAAKgP,IAAIpN,IAAIX,GAC3B,QAAIyxC,IACEA,IAAU1yC,KAAKwyC,SACjBxyC,KAAKwyC,OAASE,EAAME,OAGlBF,IAAU1yC,KAAKyyC,SACjBzyC,KAAKyyC,OAASC,EAAMG,OAGlBH,EAAMG,QACRH,EAAMG,MAAMD,MAAQF,EAAME,OAGxBF,EAAME,QACRF,EAAME,MAAMC,MAAQH,EAAMG,OAG5B7yC,KAAKgP,IAAImU,OAAOliB,GAChBjB,KAAKuyC,QAAQG,EAAMlxC,MAAOP,IAEnB,IAKb,EAzGA,GENa8xC,EAAkB,IAAIlB,ECA7BmB,EAAiC,GACjCC,EAAgC,GAKtC,SAASC,EAAOr0C,EAAgBs0C,GAC9B,IAAMt0C,EACJ,MAAM,IAAIF,MAAMw0C,GAAmB,qBAuBvC,SAASC,EAAY5xC,GACnB,OAAQA,EAAMpB,QACZ,KAAK,EAAG,MAAM,IAAIzB,MAAM,iBACxB,KAAK,EAAG,OAAO6C,EAAM,GACrB,KAAK,EAAG,MAAMA,EAAM,IAUxB,iBAmBE,WACkBqyB,EACT9vB,GADS,KAAA8vB,KACT,KAAA9vB,OAdO,KAAAsvC,QAAU,IAAIviC,IACd,KAAAwiC,YAAc,IAAIrsC,IAK3B,KAAAssC,cAAsC,KAEtC,KAAAC,OAAQ,EACR,KAAAC,aAAc,EACL,KAAAjyC,MAAuB,KAMnCkyC,EAAM9U,MAuDZ,OA9CS,YAAA+U,UAAP,WAGE,GAFAT,GAASlzC,KAAKyzC,YAAa,uBA+C/B,SAAwBnV,GACtB,IAAMzyB,EAASknC,EAAgBb,WAC/B,GAAIrmC,EAaF,OAZAyyB,EAAM+U,QAAQtiC,IAAIlF,GAEZA,EAAOynC,YAAY3xC,IAAI28B,IAC3BzyB,EAAOynC,YAAYziC,IAAIytB,EAAO,IAG5BsV,EAAatV,GACfuV,EAAiBhoC,EAAQyyB,GAEzBwV,EAAiBjoC,EAAQyyB,GAGpBzyB,EA5DDkoC,CAAe/zC,QAASg0C,EAAkBh0C,MAOhD,OAAO4zC,EAAa5zC,MAyDxB,SAAyB0yC,GAIvB,IAAMuB,EAAmBC,EAAexB,GAGxCK,EAAgBZ,UAAUO,EAAOyB,EAAmB,CAACzB,IAqJvD,SAAwBA,GACtB,GAA+B,oBAApBA,EAAM38B,UACf,IACEq+B,EAAiB1B,GACjBA,EAAM37B,YAAc27B,EAAM38B,UAAU9W,MAAM,KAAMyzC,EAAM3uC,MACtD,MAAOlB,GAMP,OADA6vC,EAAM2B,YACC,EAMX,OAAO,EApKHC,CAAe5B,IAiCrB,SAAkBA,GAGhB,GAFAA,EAAMc,OAAQ,EAEVI,EAAalB,GAGf,OAGF6B,EAAY7B,GAvCV8B,CAAS9B,GAQX,OAFAuB,EAAiBn5B,QAAQk5B,GAElBZ,EAASV,EAAMlxC,OA5EhBizC,CAAgBz0C,MAChBozC,EAASpzC,KAAKwB,QAGb,YAAA6yC,SAAP,WACMr0C,KAAKwzC,QACTxzC,KAAKwzC,OAAQ,EACbxzC,KAAKwB,MAAMpB,OAAS,EACpBs0C,EAAY10C,MAIZo0C,EAAiBp0C,QAGZ,YAAAuyC,QAAP,sBACE2B,EAAel0C,MAAM8a,QAAQk5B,GAC7BI,EAAiBp0C,MAajBA,KAAKqzC,QAAQv4B,SAAQ,SAAAjP,GACnBA,EAAOwoC,WACPM,EAAY9oC,EAAQ,OA1EV,EAAA+yB,MAAQ,EA6ExB,EA9EA,GA0HA,SAASuV,EAAkBzB,GACzBA,EAAMe,aAAc,EAEpBf,EAAMlxC,MAAMpB,OAAS,EACrB,IAEEsyC,EAAMlxC,MAAM,GAAKkxC,EAAM7e,GAAG50B,MAAM,KAAMyzC,EAAM3uC,MAC5C,MAAOlB,GAEP6vC,EAAMlxC,MAAM,GAAKqB,EAGnB6vC,EAAMe,aAAc,EAGtB,SAASG,EAAalB,GACpB,OAAOA,EAAMc,UAAYd,EAAMa,gBAAiBb,EAAMa,cAAcryC,MAetE,SAASwzC,EAAYpW,GACnBA,EAAM+U,QAAQv4B,SAAQ,SAAAjP,GAAU,OAAAgoC,EAAiBhoC,EAAQyyB,MAG3D,SAASiW,EAAYjW,GACnBA,EAAM+U,QAAQv4B,SAAQ,SAAAjP,GAAU,OAAAioC,EAAiBjoC,EAAQyyB,MAI3D,SAASuV,EAAiBhoC,EAAkByyB,GAM1C,GAHA4U,EAAOrnC,EAAOynC,YAAY3xC,IAAI28B,IAC9B4U,EAAOU,EAAatV,IAEdzyB,EAAO0nC,eAGN,GAAI1nC,EAAO0nC,cAAc5xC,IAAI28B,GAIlC,YANAzyB,EAAO0nC,cAAgBN,EAAa/wC,OAAS,IAAI4O,IASnDjF,EAAO0nC,cAAcxiC,IAAIutB,GACzBoW,EAAY7oC,GAId,SAASioC,EAAiBjoC,EAAkByyB,GAG1C4U,EAAOrnC,EAAOynC,YAAY3xC,IAAI28B,IAC9B4U,GAASU,EAAatV,IAEtB,IAAMsW,EAAa/oC,EAAOynC,YAAY1xC,IAAI08B,GAChB,IAAtBsW,EAAWx0C,OACbyL,EAAOynC,YAAYziC,IAAIytB,EAAiBA,EAAM98B,MApMnC2K,MAAM,IArBrB,SAAiB7L,EAAeC,GAC9B,IAAMgD,EAAMjD,EAAEF,OACd,OAEEmD,EAAM,GAENA,IAAQhD,EAAEH,QAEVE,EAAEiD,EAAM,KAAOhD,EAAEgD,EAAM,IAkNZsxC,CAAQD,EAAYtW,EAAM98B,QACrCqK,EAAOwoC,WAGTS,EAAiBjpC,EAAQyyB,GAErBsV,EAAa/nC,IAIjB0oC,EAAY1oC,GAGd,SAASipC,EAAiBjpC,EAAkByyB,GAC1C,IAAMyW,EAAKlpC,EAAO0nC,cACdwB,IACFA,EAAG5xB,OAAOmb,GACM,IAAZyW,EAAG7zC,OACD+xC,EAAa7yC,OA7PE,KA8PjB6yC,EAAahxC,KAAK8yC,GAEpBlpC,EAAO0nC,cAAgB,OAU7B,SAASS,EAAkBtB,GACzB,OAA8B,IAAvBA,EAAMW,QAAQnyC,MACW,oBAAvBwxC,EAAMsC,eACY,IAAzBtC,EAAMsC,eAKV,SAASd,EAAeroC,GACtB,IAAIjF,EAAWosC,EAcf,OAZInnC,EAAOynC,YAAYpyC,KAAO,IAC5B0F,EAAW,GACXiF,EAAOynC,YAAYx4B,SAAQ,SAACm6B,EAAQ3W,GAClCqW,EAAY9oC,EAAQyyB,GACpB13B,EAAS3E,KAAKq8B,OAMlB4U,EAAgC,OAAzBrnC,EAAO0nC,eAEP3sC,EAGT,SAAS+tC,EAAY9oC,EAAkByyB,GACrCA,EAAM+U,QAAQlwB,OAAOtX,GACrBA,EAAOynC,YAAYnwB,OAAOmb,GAC1BwW,EAAiBjpC,EAAQyyB,GAuB3B,SAAS8V,EAAiB1B,GAChB,IAAA37B,EAAA,EAAAA,YACmB,oBAAhBA,IACT27B,EAAM37B,iBAAc,EACpBA,KCrUJ,iBAQE,WAA6Bm+B,GAAA,KAAAA,WAoB/B,OAlBS,YAAAC,OAAP,W,IAA+B,sDAC7B,OAAOn1C,KAAKo1C,YAAYxxC,IAGnB,YAAAwxC,YAAP,SAAoCxxC,GAClC,IAAIgI,EAAmB5L,KAEvB,OADA4D,EAAMkX,SAAQ,SAAA7Z,GAAO,OAAA2K,EAAOA,EAAKypC,aAAap0C,MACvC2K,EAAKoI,OAASpI,EAAKoI,KAAOrU,OAAOkG,OAAO,QAGzC,YAAAwvC,aAAR,SAAqBp0C,GACnB,IAAM+N,EAAMhP,KAAKk1C,UASrB,SAAkB1zC,GAChB,cAAeA,GACf,IAAK,SACH,GAAc,OAAVA,EAAgB,MAEtB,IAAK,WACH,OAAO,EAET,OAAO,EAjBwB8zC,CAASr0C,GAClCjB,KAAKu1C,OAASv1C,KAAKu1C,KAAO,IAAI72B,SAC9B1e,KAAKw1C,SAAWx1C,KAAKw1C,OAAS,IAAIvuC,KAClCq3B,EAAQtvB,EAAIpN,IAAIX,GAEpB,OADKq9B,GAAOtvB,EAAI6B,IAAI5P,EAAKq9B,EAAQ,IAAImX,EAAWz1C,KAAKk1C,WAC9C5W,GAEX,EA5BA,GzB2BA,IAAM,EAAU,IAAI,EAAsC,oBAAZ,SAC9C,SAAgB,I,IAAoB,sDAClC,OAAO,EAAQ,YAAY,GAkC7B,IAAM,EAAS,IAAI,IAEnB,SAAgB,EAId,EACA,kBAAwC,OAAO,OAAO,OAEtD,IAAM,EAAQ,IAAI,EAChB,EAAQ,KAAO,KAAK,IAAI,EAAG,KAC3B,YAAS,SAAM,aAGX,IAAgB,EAAQ,WACxB,EAAe,EAAQ,cAAgB,EAE7C,SAAS,IACP,IAAI,GAAgB,EAAgB,WAApC,CASA,IAAM,EAAM,EAAa,MAAM,KAAM,WACrC,QAAY,IAAR,EACF,OAAO,EAAiB,MAAM,KAAM,WAGtC,IAAM,EAAO,MAAM,UAAU,MAAM,KAAK,WAEpC,EAAQ,EAAM,IAAI,GAClB,EACF,EAAM,KAAO,GAEb,EAAQ,IAAI,EAAsB,EAAkB,GACpD,EAAM,IAAI,EAAK,GACf,EAAM,UAAY,EAAQ,UACtB,IACF,EAAM,aAAe,WAAM,SAAM,OAAO,MAI5C,IAAM,EAAQ,EAAM,YAmBhB,OAfJ,EAAM,IAAI,EAAK,GAEf,EAAO,IAAI,GAKL,EAAgB,aACpB,EAAO,SAAQ,YAAS,SAAM,WAC9B,EAAO,SAMF,OAAa,EAAgB,GAWpC,OARA,EAAS,MAAQ,WACb,IAAE,EAAM,EAAa,MAAM,KAAM,WAC/B,OAAgB,IAAR,GAAkB,EAAM,IAAI,GACtC,GACF,EAAM,YAIH,E,gD0BnIT,IAAIoX,GAAa,EAEjB,SAASC,IACP,IAAMC,GAAUF,EAKhB,OAHK,gBACHA,GAAa,GAERE,EAMT,iBACE,cA6EF,OAzES,YAAAC,YAAP,WACE,OAAOp7B,QAAQC,WAGV,YAAAo7B,cAAP,WACE,OAAO,GAGF,YAAAtU,MAAP,SACEuU,EACAvsB,EACA1iB,GAEA,IAAMsY,EAAMtY,EAAQyf,MAAM3kB,IAAIm0C,EAAQvlB,IAChCwlB,EAA6B,eAAfD,EAAQvlB,GAE5B,IAAKpR,EAEH,OAAO42B,EAGD,QAAA9rB,kBAAA,mBAER,OAAKA,GAoBDA,IAAeV,IAnBbmsB,IAgBG,cAiCb,EA9EA,GCrBMM,G,WDyGJ,WAAYjlC,GAGNA,GAAWA,EAAQklC,8BACrBl2C,KAAKm2C,iBAAmBn2C,KAAKo2C,yBAC3BplC,EAAQklC,8BAEVl2C,KAAKq2C,SAAU,GAEfr2C,KAAKq2C,SAAU,EAGjBr2C,KAAKwhC,MAAQxhC,KAAKwhC,MAAM/sB,KAAKzU,MAGxB,YAAAwhC,MAAP,SACEuU,EACAvsB,EACA1iB,GAEA,4BAKA,IAAMsY,EAAMtY,EAAQyf,MAAM3kB,IAAIm0C,EAAQvlB,IAChCwlB,EAA6B,eAAfD,EAAQvlB,GAE5B,IAAKpR,EAEH,OAAO42B,EAGD,QAAA9rB,kBAAA,mBASR,GANY,iBAMRA,IAAeV,EACjB,OAAO,EAGT,IAAM8sB,EAAoBt2C,KAAKm2C,iBAAiB3sB,GAChD,SACEU,GACAosB,GACAA,EAAkBlwC,QAAQ8jB,IAAe,IAQrC,YAAAksB,yBAAR,SACEG,GAEA,IAAMC,EAA4B,GAQlC,OAPAD,EAAwBE,SAAS9G,MAAM70B,SAAQ,SAAA3T,GAC3B,UAAdA,EAAKY,MAAkC,cAAdZ,EAAKY,OAChCyuC,EAAQrvC,EAAK3I,MAAQ2I,EAAKuvC,cAAc1nC,KACtC,SAAA2nC,GAAoB,OAAAA,EAAiBn4C,YAIpCg4C,G,GC9KI72C,OAAOjB,UAAUmB,gBAEhC,aAKE,WAAoBmU,GAApB,gBAAoB,IAAAA,MAA8BrU,OAAOkG,OAAO,OAA5C,KAAAmO,OAClBhU,KAAK42C,OAASC,GAAK,SAACrlB,GAAmB,SAAKxd,KAAKwd,KAAS,CACxDslB,YAAY,EACZC,aAAA,SAAavlB,GACX,OAAOA,KAiDf,OA5CS,YAAAwlB,SAAP,WACE,OAAOh3C,KAAKgU,MAGP,YAAApS,IAAP,SAAW4vB,GAET,OADAxxB,KAAK42C,OAAOplB,GACLxxB,KAAKgU,KAAKwd,IAGZ,YAAA3gB,IAAP,SAAW2gB,EAAgBhwB,GAErBA,IADaxB,KAAKgU,KAAKwd,KAEzBxxB,KAAKgU,KAAKwd,GAAUhwB,EACpBxB,KAAK42C,OAAOpD,MAAMhiB,KAIf,YAAArO,OAAP,SAAcqO,GACRykB,EAAOv1C,KAAKV,KAAKgU,KAAMwd,YAClBxxB,KAAKgU,KAAKwd,GACjBxxB,KAAK42C,OAAOpD,MAAMhiB,KAIf,YAAA7gB,MAAP,WACE3Q,KAAKmO,QAAQ,OAGR,YAAAA,QAAP,SAAeggB,GAAf,WACMA,GACFxuB,OAAOmB,KAAKqtB,GAASrT,SAAQ,SAAA0W,GAC3B,EAAK3gB,IAAI2gB,EAAQrD,EAAQqD,OAE3B7xB,OAAOmB,KAAKd,KAAKgU,MAAM8G,SAAQ,SAAA0W,GACxBykB,EAAOv1C,KAAKytB,EAASqD,IACxB,EAAKrO,OAAOqO,OAIhB7xB,OAAOmB,KAAKd,KAAKgU,MAAM8G,SAAQ,SAAA0W,GAC7B,EAAKrO,OAAOqO,OAIpB,EA1DA,G,SA4DgBylB,EACd/e,GAEA,OAAO,IAAI,EAAiBA,G,iBC0C5B,WAAY,GAAZ,WAAY,kBACV,IAAAgf,oBAAA,IAAe,EAAf,aACA,IAAAC,qBAAA,IAAgB,GAAhB,EAGEC,EADI,KACJA,kBACAC,EAFI,KAEJA,oBACAC,EAHI,KAGJA,wBAGFt3C,KAAKm3C,cAAgBA,EAErBn3C,KAAKo3C,kBAAoBP,GAAK,SAAC7lC,GAC7B,OAAOomC,EAAkB12C,KAAK,EAAMsQ,KACnC,CACD+lC,aAAA,SAAa,G,IACXxkC,EAAA,EAAAA,MACAkW,EAAA,EAAAA,UACA8uB,EAAA,EAAAA,aACAC,EAAA,EAAAA,eACAzwB,EAAA,EAAAA,gBAKA,GAAIwwB,EAAahxB,iBAAiB,EAChC,OAAO2wB,EAAa/B,OAClBoC,EAAahxB,MACbhU,EACAwU,EACA5L,KAAKC,UAAUo8B,GACf/uB,EAAU+H,OAMlBxwB,KAAKq3C,oBAAsBR,GAAK,SAAC7lC,GAC/B,OAAOqmC,EAAoB32C,KAAK,EAAMsQ,KACrC,CACD+lC,aAAA,SAAa,G,IACX7tB,EAAA,EAAAA,aACAT,EAAA,EAAAA,UACAO,EAAA,EAAAA,YAEA,GAAIA,EAAYuuB,aAAahxB,iBAAiB,EAC5C,OAAO2wB,EAAa/B,OAClBnsB,EAAYuuB,aAAahxB,MACzB2C,EACAF,EAAYjC,gBACZ5L,KAAKC,UAAU4N,EAAYwuB,gBAC3B/uB,EAAU+H,OAMlBxwB,KAAKs3C,wBAA0BT,GAAK,SAAC7lC,GACnC,OAAOsmC,EAAwB52C,KAAK,EAAMsQ,KACzC,CACD+lC,aAAY,SAAC,G,IAAEptB,EAAA,EAAAA,MAAO/lB,EAAA,EAAAA,MAAOolB,EAAA,EAAAA,YAC3B,GAAIA,EAAYuuB,aAAahxB,iBAAiB,EAC5C,OAAO2wB,EAAa/B,OAClBnsB,EAAYuuB,aAAahxB,MACzBoD,EACA/lB,EACAuX,KAAKC,UAAU4N,EAAYwuB,oBAkXvC,OA5VS,YAAAC,mBAAP,SACEzmC,GAEA,OAAOhR,KAAK03C,sBAAqB,2BAC5B1mC,GAAO,CACVuX,mBAAmB,KAClBzb,QAWE,YAAA4qC,sBAAP,SAAgC,G,IAC9BnxB,EAAA,EAAAA,MACAhU,EAAA,EAAAA,MACA9K,EAAA,EAAAA,UACAuO,EAAA,EAAAA,eACA,IAAAuS,yBAAA,IAAoB,GAApB,EACA,IAAAovB,cAAA,IAAS,EAAT,eACAC,EAAA,EAAAA,wBACA9vB,EAAA,EAAAA,OAGM+vB,EAAkB,YAAmBtlC,GAE3C9K,EAAY,YAAO,GAAI,YAAiBowC,GAAkBpwC,GAE1D,IAAMX,EAA4B,CAEhCyf,MAAK,EACLwB,iBAAkBD,GAAUA,EAAOC,iBACnC+vB,eAAiBhwB,GAAUA,EAAOgwB,gBAAmB,IAGjDC,EAAa/3C,KAAKo3C,kBAAkB,CACxC7kC,MAAK,EACLkW,UAAW,CACTthB,KAAM,KACNqpB,GAAImnB,EACJ9X,WAAW,EACXG,SAAU,SAEZuX,aAAczwC,EACd0wC,eAAgB/vC,EAChBsf,gBAAiB6wB,IAGbI,EACJD,EAAWE,SAAWF,EAAWE,QAAQ73C,OAAS,EAqBpD,OAnBI43C,IAAsBzvB,GACxBwvB,EAAWE,QAASn9B,SAAQ,SAAAzZ,GAC1B,IAAIA,EAAK62C,UACT,MAAM,cAUNliC,GACE,YAAQA,EAAgB+hC,EAAWjrC,UACrCirC,EAAWjrC,OAASkJ,GAIjB,CACLlJ,OAAQirC,EAAWjrC,OACnB8M,UAAWo+B,IAsBP,YAAAZ,kBAAR,SAA0B,G,IACxB7kC,EAAA,EAAAA,MACAkW,EAAA,EAAAA,UACA8uB,EAAA,EAAAA,aACAC,EAAA,EAAAA,eAEA,IAAAzwB,uBAAA,IAAkB,EAAlB,IAEM2B,EAAiB,YAAkBnW,GACnC5K,EAAY,YAAuB4K,GAEnCyW,EAA2B,CAC/BzW,MAAK,EACLoW,YAHkB,YAAkBhhB,GAIpC4vC,aAAY,EACZC,eAAc,EACdzwB,gBAAe,GAGjB,OAAO/mB,KAAKq3C,oBAAoB,CAC9BnuB,aAAcR,EAAeQ,aAC7BT,UAAS,EACTO,YAAW,KAIP,YAAAquB,oBAAR,SAA4B,GAA5B,WACEnuB,EAAA,EAAAA,aACAT,EAAA,EAAAA,UACAO,EAAA,EAAAA,YAEQL,EAAA,EAAAA,YAAa4uB,EAAA,EAAAA,aAAc,IAAAC,eAC7BW,EAA0B,CAAErrC,OAAQ,MAEpCsrC,EAA2C,GAE3Cz4B,EAAsB43B,EAAahxB,MAAM3kB,IAAI6mB,EAAU+H,IAEvDwP,EACHrgB,GAAUA,EAAOuK,YACA,eAAjBzB,EAAU+H,IAAuB,cAClC,EAEF,SAAS6nB,EAAiBvrC,G,MAKxB,OAJIA,EAAOmrC,UACTE,EAAYF,QAAUE,EAAYF,SAAW,IAC7C,EAAAE,EAAYF,SAAQh2C,KAAI,QAAI6K,EAAOmrC,UAE9BnrC,EAAOA,OAsEhB,OAnEAoc,EAAaQ,WAAW5O,SAAQ,SAAAsO,G,MAC9B,GAAK,YAAcA,EAAW3hB,GAK9B,GAAI,YAAQ2hB,GAAY,CACtB,IAAME,EAAc+uB,EAClB,EAAKC,aAAa34B,EAAQqgB,EAAU5W,EAAWJ,IAGtB,qBAAhBM,GACT8uB,EAAen2C,OAAI,MAChB,YAAuBmnB,IAAaE,EACrC,QAGC,CACL,IAAIC,OAAQ,EAEZ,GAAI,YAAiBH,GACnBG,EAAWH,OAKX,KAFAG,EAAWZ,EAAYS,EAAU5qB,KAAKgD,QAGpC,MAAM,WAIV,IAAMgoB,EACJD,EAASC,eAAiBD,EAASC,cAAchrB,KAAKgD,MAElDggC,GACHhY,GACDR,EAAYjC,gBAAgB0B,EAAWe,EAAe+tB,GAExD,GAAI/V,EAAO,CACT,IAAI+W,EAAqB,EAAKlB,oBAAoB,CAChDnuB,aAAcK,EAASL,aACvBT,UAAS,EACTO,YAAW,IAGC,cAAVwY,GAAyB+W,EAAmBN,UAC9CM,EAAqB,OAAH,IAAG,CAAH,eACbA,GAAkB,CACrBN,QAASM,EAAmBN,QAAQjpC,KAAI,SAAA3N,GACtC,kCAAYA,GAAI,CAAE62C,WAAW,UAKnCE,EAAen2C,KAAKo2C,EAAcE,SAOxCJ,EAAYrrC,OAAS,YAAesrC,GAEhCp4C,KAAKm3C,cAIFgB,GAGD,YAAAG,aAAR,SACE34B,EACAqgB,EACArW,EACAX,GAEQ,QAAAwuB,eAA2BD,EAAA,EAAAA,aAS7BiB,EA4IV,SACE74B,EACAqgB,EACApW,EACA7lB,EACA+C,EACA,GAAE,EAAA2xC,U,IAAWruB,EAAA,EAAAA,WAETsuB,EAAe9uB,GACf7lB,GAAQqmB,KAKVsuB,EAAe,YAAgBA,EAAc30C,EAAMqmB,IAGrD,IAAIuuB,OAAgC,EAEpC,GAAIh5B,GAIsB,qBAHxBg5B,EAAah5B,EAAO+4B,KAIlB5xC,EAAQgxC,gBACY,kBAAb9X,EACP,CAEA,IAAM74B,EAAOL,EAAQgxC,eAAe9X,GACpC,GAAI74B,EAAM,CAER,IAAMyxC,EAAWzxC,EAAKyiB,GAClBgvB,IACFD,EAAaC,EAASj5B,EAAQ5b,EAAM,CAClC8jB,YAAA,SAAYgxB,GACV,IAAMroB,EAAK1pB,EAAQihB,iBAAkB8wB,GACrC,OAAOroB,GAAM,YAAU,CACrBA,GAAE,EACFwP,SAAU6Y,EAAS3uB,kBASjC,GAA0B,qBAAfyuB,EACT,MAAO,CACL7rC,OAAQ6rC,EACRV,QAAS,CAAC,CACRt4B,OAAM,EACNiK,UAAW8uB,EACXR,WAAW,KAKb,YAAYS,KACdA,EAAaA,EAAWG,MAG1B,MAAO,CACLhsC,OAAQ6rC,GA3MgBI,CACtBp5B,EACAqgB,EAVgBrW,EAAMnrB,KAAKgD,MAChB,YAAyBmoB,EAAOliB,GAY3C8vC,EAVqB,CACrBkB,UAAW,YAAuB9uB,GAClCS,WAAY,YAA0BT,EAAOliB,KAY/C,OAAIzD,MAAMyH,QAAQ+sC,EAAgB1rC,QACzB9M,KAAKg5C,mBACVR,EACAx4C,KAAKs3C,wBAAwB,CAC3B3tB,MAAK,EACL/lB,MAAO40C,EAAgB1rC,OACvBkc,YAAW,KAMZW,EAAMT,aAUmB,MAA1BsvB,EAAgB1rC,OAEX0rC,EAIFx4C,KAAKg5C,mBACVR,EACAx4C,KAAKq3C,oBAAoB,CACvBnuB,aAAcS,EAAMT,aACpBT,UAAW+vB,EAAgB1rC,OAC3Bkc,YAAW,MApBbiwB,EAA6BtvB,EAAO6uB,EAAgB1rC,QAChD9M,KAAKm3C,cAGFqB,IAqBH,YAAAQ,mBAAR,W,IACE,IAEIf,EAFJ,kDASA,OANAiB,EAAYp+B,SAAQ,SAAAi9B,GACdA,EAAWE,UACbA,EAAUA,GAAW,IACbh2C,KAAI,MAAZg2C,EAAgBF,EAAWE,YAGxB,CACLnrC,OAAQosC,EAAYh3C,MAAO4K,OAC3BmrC,QAAO,IAIH,YAAAX,wBAAR,SAAgC,GAAhC,IAKMW,EALN,OACEtuB,EAAA,EAAAA,MACA/lB,EAAA,EAAAA,MACAolB,EAAA,EAAAA,YAIA,SAASqvB,EAAiBc,GAMxB,OALIA,EAAYlB,UACdA,EAAUA,GAAW,IACbh2C,KAAI,MAAZg2C,EAAgBkB,EAAYlB,SAGvBkB,EAAYrsC,OAoCrB,OAjCAlJ,EAAQA,EAAMoL,KAAI,SAAAub,GAEhB,OAAa,OAATA,EACK,KAILvmB,MAAMyH,QAAQ8e,GACT8tB,EAAc,EAAKf,wBAAwB,CAChD3tB,MAAK,EACL/lB,MAAO2mB,EACPvB,YAAW,KAKXW,EAAMT,aACDmvB,EAAc,EAAKhB,oBAAoB,CAC5CnuB,aAAcS,EAAMT,aACpBT,UAAW8B,EACXvB,YAAW,MAIfiwB,EAA6BtvB,EAAOY,GAE7BA,MAGLvqB,KAAKm3C,cAIF,CAAErqC,OAAQlJ,EAAOq0C,QAAO,IAEnC,E,GAEA,SAASgB,EACPtvB,EACAnoB,GAEA,IAAKmoB,EAAMT,cAAgB,YAAU1nB,GACnC,MAAM,YAQV,SAAS43C,IACP,OAAO,E,iBC/iBP,WAAsBplC,QAAA,IAAAA,MAA8BrU,OAAOkG,OAAO,OAA5C,KAAAmO,OAyBxB,OAvBS,YAAAgjC,SAAP,WACE,OAAOh3C,KAAKgU,MAGP,YAAApS,IAAP,SAAW4vB,GACT,OAAOxxB,KAAKgU,KAAKwd,IAGZ,YAAA3gB,IAAP,SAAW2gB,EAAgBhwB,GACzBxB,KAAKgU,KAAKwd,GAAUhwB,GAGf,YAAA2hB,OAAP,SAAcqO,GACZxxB,KAAKgU,KAAKwd,QAAU,GAGf,YAAA7gB,MAAP,WACE3Q,KAAKgU,KAAOrU,OAAOkG,OAAO,OAGrB,YAAAsI,QAAP,SAAeggB,GACbnuB,KAAKgU,KAAOma,GAAWxuB,OAAOkG,OAAO,OAEzC,E,qBCaA,2D,OACS,EAAAsB,KAAO,a,EAChB,OAFgC,iBAEhC,E,CAFgCxI,OAuBhC,+BAoYA,OAlXS,YAAA06C,kBAAP,SAAyB,G,IACvB9mC,EAAA,EAAAA,MACAzF,EAAA,EAAAA,OACA,IAAAyZ,aAAA,IAAQ,EAAR,MACA9e,EAAA,EAAAA,UACAsgB,EAAA,EAAAA,iBACA6vB,EAAA,EAAAA,wBASA,OAAO53C,KAAKs5C,mBAAmB,CAC7B9nB,OAAQ,aACR1kB,OAAM,EACNtF,SAAU+K,EACVgU,MAAK,EACL9e,UAAS,EACTsgB,iBAAgB,EAChB6vB,wBAAuB,KAIpB,YAAA0B,mBAAP,SAA0B,G,IACxB9nB,EAAA,EAAAA,OACA1kB,EAAA,EAAAA,OACAtF,EAAA,EAAAA,SACA,IAAA+e,aAAA,IAAQ,EAAR,MACA9e,EAAA,EAAAA,UACAsgB,EAAA,EAAAA,iBACA6vB,EAAA,EAAAA,wBAWM2B,EAAsB,YAAuB/xC,GAEnD,IACE,OAAOxH,KAAKw5C,yBAAyB,CACnC1sC,OAAM,EACN0kB,OAAM,EACNtI,aAAcqwB,EAAoBrwB,aAClCpiB,QAAS,CACPyf,MAAK,EACLkzB,cAAe,GACfhyC,UAAW,YACT,GACA,YAAiB8xC,GACjB9xC,GAEFsgB,iBAAgB,EAChBY,YAAa,YAAkB,YAAuBnhB,IACtDowC,wBAAuB,KAG3B,MAAO/0C,GACP,M,SAtGmCzD,EAAcoI,GAErD,IAAMkyC,EAAgB,IAAI,EACxB,8CAA8Cv+B,KAAKC,UAAU5T,IAI/D,OAFAkyC,EAAcr7C,SAAW,KAAOe,EAAMf,QACtCq7C,EAAcnuC,MAAQnM,EAAMmM,MACrBmuC,EA+FGC,CAAyB92C,EAAG2E,KAI/B,YAAAgyC,yBAAP,SAAgC,GAAhC,WACE1sC,EAAA,EAAAA,OACA0kB,EAAA,EAAAA,OACAtI,EAAA,EAAAA,aACApiB,EAAA,EAAAA,QAOQW,EAAA,EAAAA,UAAW8e,EAAA,EAAAA,MAAOoC,EAAA,EAAAA,YAoG1B,OAlGAO,EAAaQ,WAAW5O,SAAQ,SAAAsO,G,MAC9B,GAAK,YAAcA,EAAW3hB,GAI9B,GAAI,YAAQ2hB,GAAY,CACtB,IAAMwwB,EAAyB,YAAuBxwB,GAChD5nB,EAAasL,EAAO8sC,GAE1B,GAAqB,qBAAVp4C,EACT,EAAKq4C,kBAAkB,CACrBroB,OAAM,EACNhwB,MAAK,EACLmoB,MAAOP,EACPtiB,QAAO,QAEJ,CACL,IAAIgzC,GAAY,EACZC,GAAW,EACX3wB,EAAUgB,YAAchB,EAAUgB,WAAWhqB,SAE/C05C,EAAY1wB,EAAUgB,WAAWhC,MAC/B,SAAAiC,GAAa,OAAAA,EAAU7rB,MAAiC,UAAzB6rB,EAAU7rB,KAAKgD,SAWhDu4C,EAAW3wB,EAAUgB,WAAWhC,MAC9B,SAAAiC,GAAa,OAAAA,EAAU7rB,MAAiC,WAAzB6rB,EAAU7rB,KAAKgD,WAI7Cs4C,IAAcC,GAAYjzC,EAAQ8wC,6BAapC,CAEL,IAAIruB,OAAQ,EAER,YAAiBH,GACnBG,EAAWH,GAGXG,GAAYZ,GAAe,IAAIS,EAAU5qB,KAAKgD,OAC1B,cAAoC,IAG1D,IAAIw4C,GAAU,EACd,GAAIlzC,EAAQ8wC,yBAA2BruB,EAASC,cAAe,CAI7D,IAAMgH,EAAKgB,GAAU,OACfukB,EAAU,YAAU,CAAEvlB,GAAE,EAAEwP,cAAU10B,IACpC2uC,EAAgC,CAGpC1zB,MAAO,IAAI2zB,GAAW,KAAG,EAAC1pB,GAAK1jB,EAAM,IACrCgrC,eAAgB,IAEZtW,EAAQ16B,EAAQ8wC,wBACpB7B,EACAxsB,EAASC,cAAchrB,KAAKgD,MAC5By4C,GAEG,cAGLD,IAAYxY,EAGVwY,GACF,EAAKR,yBAAyB,CAC5B1sC,OAAM,EACNoc,aAAcK,EAASL,aACvBsI,OAAM,EACN1qB,QAAO,QAMRyf,GAGD,YAAAszB,kBAAR,SAA0B,G,MAapBx2B,EACA82B,EAbJxwB,EAAA,EAAAA,MACAnoB,EAAA,EAAAA,MACAgwB,EAAA,EAAAA,OACA1qB,EAAA,EAAAA,QAOQW,EAAA,EAAAA,UAAWsgB,EAAA,EAAAA,iBAAkBxB,EAAA,EAAAA,MAK/B6zB,EAAyB,YAAsBzwB,EAAOliB,GAG5D,GAAKkiB,EAAMT,cAA0B,OAAV1nB,EAQpB,GAAIwC,MAAMyH,QAAQjK,GAAQ,CAC/B,IAAM64C,EAAiB7oB,EAAM,IAAI4oB,EAEjC/2B,EAAarjB,KAAKs6C,kBAChB94C,EACA64C,EACA1wB,EAAMT,aACNpiB,OAEG,CAEL,IAAIyzC,EAAiB/oB,EAAM,IAAI4oB,EAC3Bva,GAAY,EAQhB,GAJK2a,GAAcD,KACjBA,EAAc,IAAMA,GAGlBxyB,EAAkB,CACpB,IAAM0yB,EAAa1yB,EAAiBvmB,GAOJ,aAAW,cAKzCi5C,GACuB,kBAAfA,GAA0C,IAAfA,KAEnCF,EAAcE,EACd5a,GAAY,GAIX6a,GAAgBH,EAAa5wB,EAAO7iB,EAAQ2yC,gBAC/Cz5C,KAAKw5C,yBAAyB,CAC5BhoB,OAAQ+oB,EACRztC,OAAQtL,EACR0nB,aAAcS,EAAMT,aACpBpiB,QAAO,IAMX,IAAMk5B,EAAWx+B,EAAM0oB,WACvB7G,EAAa,YAAU,CAAEmN,GAAI+pB,EAAava,SAAQ,GAAIH,GAMtD,IAAM8a,GADNR,EAAc5zB,EAAM3kB,IAAI4vB,KAEN2oB,EAAYC,GAC9B,GAAIO,IAAct3B,GAAc,YAAUs3B,GAAY,CACpD,IAAMC,OAAqCtvC,IAAvBqvC,EAAU3a,SACxB6a,OAA2BvvC,IAAb00B,EACd8a,EACJF,GAAeC,GAAeF,EAAU3a,WAAaA,EAQ3C,gBACV,kBAS2B,qBAQzB2a,EAAU9a,YAGRib,EAIGjb,GACHtZ,EAAMpD,OAAOw3B,EAAUnqB,IAqErC,SAASuqB,EACPC,EACAC,EACAj0C,GAEA,GAAIg0C,IAAiBC,EACnB,OAAO,EAGT,IAAMpb,EAAY74B,EAAMpF,IAAIo5C,GACtBE,EAAOl0C,EAAMpF,IAAIq5C,GACnBE,GAAc,EAElBx7C,OAAOmB,KAAK++B,GAAW/kB,SAAQ,SAAA7Z,GAC7B,IAAMO,EAAQq+B,EAAU5+B,GAClBm6C,EAAYF,EAAKj6C,GAGrB,YAAUO,IACVg5C,GAAch5C,EAAMgvB,KACpB,YAAU4qB,KACT,YAAQ55C,EAAO45C,IAChBL,EAAmBv5C,EAAMgvB,GAAI4qB,EAAU5qB,GAAIxpB,KAE3Cm0C,GAAc,MAIlBn0C,EAAMmc,OAAO63B,GACb,IAAMK,EAAe,OAAH,IAAG,CAAH,eAAQxb,GAAcqb,GAExC,GAAI,YAAQG,EAAcH,GACxB,OAAOC,EAIT,OADAn0C,EAAM6J,IAAIoqC,EAASI,IACZ,EAtGGN,CAAmBJ,EAAUnqB,GAAKnN,EAAuBmN,GAAIjK,UA7GnElD,EACW,MAAT7hB,GAAkC,kBAAVA,EAGpB,CAAE2F,KAAM,OAAQ2xC,KAAMt3C,GAEtBA,GA6GR24C,EAAc5zB,EAAM3kB,IAAI4vB,KACH,YAAQnO,EAAY82B,EAAYC,KACnD7zB,EAAM1V,IAAI2gB,EAAM,2BACX2oB,KAAW,MACbC,GAAiB/2B,EAAU,MAK1B,YAAAi3B,kBAAR,SACE94C,EACA64C,EACAnxB,EACApiB,GAJF,WAME,OAAOtF,EAAMwN,KAAI,SAACub,EAAW7e,GAC3B,GAAa,OAAT6e,EACF,OAAO,KAGT,IAAI+wB,EAAgBjB,EAAW,IAAI3uC,EAEnC,GAAI1H,MAAMyH,QAAQ8e,GAChB,OAAO,EAAK+vB,kBAAkB/vB,EAAM+wB,EAAYpyB,EAAcpiB,GAGhE,IAAI+4B,GAAY,EAEhB,GAAI/4B,EAAQihB,iBAAkB,CAC5B,IAAM0yB,EAAa3zC,EAAQihB,iBAAiBwC,GAExCkwB,IACFa,EAAab,EACb5a,GAAY,GAahB,OATK6a,GAAgBY,EAAYpyB,EAAcpiB,EAAQ2yC,gBACrD,EAAKD,yBAAyB,CAC5BhoB,OAAQ8pB,EACRxuC,OAAQyd,EACRrB,aAAY,EACZpiB,QAAO,IAIJ,YACL,CAAE0pB,GAAI8qB,EAAYtb,SAAUzV,EAAKL,YACjC2V,OAIR,EApYA,GAwYA,SAAS2a,GAAchqB,GACrB,MAAiB,MAAVA,EAAG,GA0CZ,SAASkqB,GACPlpB,EACA7H,EACA8vB,GAEA,IAAKA,EACH,OAAO,EAGT,GAAIA,EAAcjoB,GAAS,CACzB,GAAIioB,EAAcjoB,GAAQprB,QAAQujB,IAAU,EAC1C,OAAO,EAEP8vB,EAAcjoB,GAAQvvB,KAAK0nB,QAG7B8vB,EAAcjoB,GAAU,CAAC7H,GAG3B,OAAO,ECveT,IAAM4xB,GAAqC,CACzCx0B,gBAAiB,IAAIy0B,EACrBzzB,iBAMF,SAAwCjb,GACtC,GAAIA,EAAOod,WAAY,CACrB,QAAkB5e,IAAdwB,EAAO0jB,GACT,OAAU1jB,EAAOod,WAAU,IAAIpd,EAAO0jB,GAExC,QAAmBllB,IAAfwB,EAAO2uC,IACT,OAAU3uC,EAAOod,WAAU,IAAIpd,EAAO2uC,IAG1C,OAAO,MAdPC,aAAa,EACbC,eAAe,EACfxE,eAAe,GAejB,IAAMlB,GAASt2C,OAAOjB,UAAUmB,eAEhC,eACE,WACkB+7C,EAGA/vC,EACAgwC,GALlB,MAOE,YAAMl8C,OAAOkG,OAAO,QAAM,K,OANV,EAAA+1C,eAGA,EAAA/vC,SACA,EAAAgwC,c,EAoBpB,OA1B0Cl8C,OAAA,IAAAA,CAAA,KAWjC,YAAAq3C,SAAP,WACE,kCACKh3C,KAAK6L,OAAOmrC,YACZh3C,KAAKgU,OAOL,YAAApS,IAAP,SAAW4vB,GACT,OAAOykB,GAAOv1C,KAAKV,KAAKgU,KAAMwd,GAC1BxxB,KAAKgU,KAAKwd,GACVxxB,KAAK6L,OAAOjK,IAAI4vB,IAExB,EA1BA,CAA0C0oB,G,eA4CxC,WAAYpyB,QAAA,IAAAA,MAAA,IAAZ,MACE,cAAO,KAZD,EAAAg0B,QAAU,IAAIhrC,IAEd,EAAAirC,sBAAwB,IAAI90C,IAG5B,EAAAiwC,aAAe,IAAIzB,EAAgB,KAInC,EAAAuG,kBAA4B,EAIlC,EAAKl0B,OAAM,2BAAQyzB,IAAkBzzB,GAGhC,EAAKA,OAAem0B,kBAIvB,EAAKn0B,OAAOgwB,eAAkB,EAAKhwB,OAAem0B,iBAG/C,EAAKn0B,OAAeo0B,iBAIvB,EAAKp0B,OAAOgwB,eAAkB,EAAKhwB,OAAeo0B,gBAGpD,EAAKR,cAAgB,EAAK5zB,OAAO4zB,YAKjC,EAAK1nC,KAAO,EAAK8T,OAAO6zB,cACpB,IAAI,EACJ,IAAIzB,EAOR,EAAKiC,eAAiB,EAAKnoC,KAE3B,EAAKooC,YAAc,IAAI,EACvB,EAAKC,YAAc,IAAI,EAAY,CACjCnF,aAAc,EAAKA,aACnBC,cAAervB,EAAOqvB,gBAGxB,IAAMnwC,EAAQ,EACNs1C,EAAA,EAAAA,oB,OACR,EAAKA,oBAAsBzF,GAAK,SAACnlB,GAC/B,OAAO4qB,EAAoB57C,KAAK,EAAMgxB,KACrC,CACDqlB,aAAA,SAAarlB,GACX,IAAIA,EAAElJ,aAMFkJ,EAAE1b,eAQN,OAAIhP,EAAMgN,gBAAgB,EAGjBhN,EAAMkwC,aAAa/B,OACxBzjB,EAAEnf,MACF4I,KAAKC,UAAUsW,EAAEjqB,iBALrB,K,EAoMR,OAjRmC,iBAyF1B,YAAAusB,QAAP,SAAehgB,GAEb,OADIA,GAAMhU,KAAKgU,KAAK7F,QAAQ6F,GACrBhU,MAGF,YAAAkzB,QAAP,SAAe1K,GACb,YADa,IAAAA,OAAA,IACLA,EAAaxoB,KAAKm8C,eAAiBn8C,KAAKgU,MAAMgjC,YAGjD,YAAAuF,KAAP,SAAevrC,GACb,GAA8B,kBAAnBA,EAAQ2mC,QAC0B,qBAAlC33C,KAAKgU,KAAKpS,IAAIoP,EAAQ2mC,QAC/B,OAAO,KAGD,IAAA5wB,EAAA,YAAAA,gBACF6wB,EAA0B7wB,GAAmBA,EAAgBya,MAEnE,OAAOxhC,KAAKq8C,YAAY5E,mBAAmB,CACzClxB,MAAOvV,EAAQwX,WAAaxoB,KAAKm8C,eAAiBn8C,KAAKgU,KACvDzB,MAAOvS,KAAK+uB,kBAAkB/d,EAAQuB,OACtC9K,UAAWuJ,EAAQvJ,UACnBkwC,OAAQ3mC,EAAQ2mC,OAChBC,wBAAuB,EACvB5hC,eAAgBhF,EAAQgF,eACxB8R,OAAQ9nB,KAAK8nB,UACT,MAGD,YAAAyJ,MAAP,SAAaA,GACH,IAAAxK,EAAA,YAAAA,gBACF6wB,EAA0B7wB,GAAmBA,EAAgBya,MAEnExhC,KAAKo8C,YAAY9C,mBAAmB,CAClC9nB,OAAQD,EAAMC,OACd1kB,OAAQykB,EAAMzkB,OACdrF,UAAW8pB,EAAM9pB,UACjBD,SAAUxH,KAAK+uB,kBAAkBwC,EAAMhf,OACvCgU,MAAOvmB,KAAKgU,KACZ+T,iBAAkB/nB,KAAK8nB,OAAOC,iBAC9B6vB,wBAAuB,IAGzB53C,KAAKw8C,oBAGA,YAAAl0B,KAAP,SAAe/V,GACL,IAAAwU,EAAA,YAAAA,gBACF6wB,EAA0B7wB,GAAmBA,EAAgBya,MAEnE,OAAOxhC,KAAKq8C,YAAY3E,sBAAsB,CAC5CnxB,MAAOhU,EAAMiW,WAAaxoB,KAAKm8C,eAAiBn8C,KAAKgU,KACrDzB,MAAOvS,KAAK+uB,kBAAkBxc,EAAMA,OACpC9K,UAAW8K,EAAM9K,UACjB8gB,kBAAmBhW,EAAMgW,kBACzBvS,eAAgBzD,EAAMyD,eACtB4hC,wBAAuB,EACvB9vB,OAAQ9nB,KAAK8nB,UAIV,YAAA4H,MAAP,SAAaA,GAAb,WAGE,OAFA1vB,KAAK87C,QAAQ/qC,IAAI2e,GAEV,WACL,EAAKosB,QAAQ34B,OAAOuM,KAIjB,YAAA+sB,MAAP,SAAalqC,GACX,MAAM,YAGD,YAAApS,MAAP,WAIE,OAHAH,KAAKgU,KAAKrD,QACV3Q,KAAKw8C,mBAEE/hC,QAAQC,WAGV,YAAAuX,iBAAP,SAAwByqB,GAKtB,IAJA,IAAMC,EAAoC,GACtCC,EAAe,EACfC,EAAQ78C,KAAKm8C,eAEVU,aAAiB,IAClBA,EAAMjB,eAAiBc,IACvBE,EAEFD,EAAU16C,KAAK46C,GAEjBA,EAAQA,EAAMhxC,OAGhB,GAAI+wC,EAAe,EAAG,CAMpB,IAHA58C,KAAKm8C,eAAiBU,EAGfF,EAAUv8C,OAAS,GAAG,CAC3B,IAAM,EAAQu8C,EAAUz6C,MACxBlC,KAAKgyB,mBAAmB,EAAM6pB,YAAa,EAAMD,cAGnD57C,KAAKw8C,qBAIF,YAAAxqB,mBAAP,SACE6pB,EAIAD,GAEM,IAAE5nC,EAAF,KAAEA,KAAMgoC,EAAR,KAAQA,iBACdh8C,KAAKg8C,kBAAmB,EAEI,kBAAjBJ,IAGT57C,KAAKgU,KAAOhU,KAAKm8C,eAAiB,IAAI,GAIpCP,EACA57C,KAAKm8C,eACLN,IAIJ,IACEA,EAAY77C,MADd,QAGEA,KAAKg8C,iBAAmBA,EACxBh8C,KAAKgU,KAAOA,EAIdhU,KAAKw8C,oBAGA,YAAA/qB,4BAAP,SACEoqB,EACArrB,GAEA,OAAOxwB,KAAKgyB,mBAAmB6pB,EAAarrB,IAGvC,YAAAzB,kBAAP,SAAyBvnB,GACvB,GAAIxH,KAAK07C,YAAa,CACpB,IAAI5uC,EAAS9M,KAAK+7C,sBAAsBn6C,IAAI4F,GAS5C,OARKsF,IACHA,EAAS,YAAsBtF,GAC/BxH,KAAK+7C,sBAAsBlrC,IAAIrJ,EAAUsF,GAIzC9M,KAAK+7C,sBAAsBlrC,IAAI/D,EAAQA,IAElCA,EAET,OAAOtF,GAGC,YAAAg1C,iBAAV,sBACOx8C,KAAKg8C,kBACRh8C,KAAK87C,QAAQhhC,SAAQ,SAAA4W,GAAK,SAAK4qB,oBAAoB5qB,OAM/C,YAAA4qB,oBAAR,SAA4B5qB,GAC1BA,EAAE7vB,SACA7B,KAAKsoB,KAAK,CACR/V,MAAOmf,EAAEnf,MACT9K,UAAWiqB,EAAEjqB,UACbuO,eAAgB0b,EAAE1b,gBAAkB0b,EAAE1b,iBACtCwS,WAAYkJ,EAAElJ,eAItB,E,CAjRmC,I,kFC1E5B,SAASs0B,EAAMztC,GACpB,OAAOnE,YAAMmE,EAAK,CAChB9B,MAAOwvC,IAIX,IAAIA,EAAqB,CACvB10C,KAAM,SAAcuD,GAClB,OAAOA,EAAKpK,OAEdiH,SAAU,SAAkBmD,GAC1B,MAAO,IAAMA,EAAKpN,MAGpB8J,SAAU,SAAkBsD,GAC1B,OAAOwU,EAAKxU,EAAKhE,YAAa,QAAU,MAE1CW,oBAAqB,SAA6BqD,GAChD,IAAIiR,EAAKjR,EAAK3D,UACVzJ,EAAOoN,EAAKpN,KACZw+C,EAAUnG,EAAK,IAAKz2B,EAAKxU,EAAKkwB,oBAAqB,MAAO,KAC1D1R,EAAahK,EAAKxU,EAAKwe,WAAY,KACnClB,EAAetd,EAAKsd,aAGxB,OAAQ1qB,GAAS4rB,GAAe4yB,GAAkB,UAAPngC,EAAgCuD,EAAK,CAACvD,EAAIuD,EAAK,CAAC5hB,EAAMw+C,IAAW5yB,EAAYlB,GAAe,KAA3EA,GAE9D1gB,mBAAoB,SAA4By6B,GAC9C,IAAIhH,EAAWgH,EAAKhH,SAChB90B,EAAO87B,EAAK97B,KACZ60B,EAAeiH,EAAKjH,aACpB5R,EAAa6Y,EAAK7Y,WACtB,OAAO6R,EAAW,KAAO90B,EAAO0vC,EAAK,MAAO7a,GAAgB6a,EAAK,IAAKz2B,EAAKgK,EAAY,OAEzF1hB,aAAc,SAAsB06B,GAElC,OAAOoL,EADUpL,EAAM1Z,aAGzB/gB,MAAO,SAAe06B,GACpB,IAAI5I,EAAQ4I,EAAM5I,MACdj8B,EAAO6kC,EAAM7kC,KACbuF,EAAOs/B,EAAMnkC,UACbkrB,EAAaiZ,EAAMjZ,WACnBlB,EAAema,EAAMna,aACzB,OAAO9I,EAAK,CAACy2B,EAAK,GAAIpc,EAAO,MAAQj8B,EAAOq4C,EAAK,IAAKz2B,EAAKrc,EAAM,MAAO,KAAMqc,EAAKgK,EAAY,KAAMlB,GAAe,MAEtHtgB,SAAU,SAAkBq0C,GAG1B,OAFWA,EAAMz+C,KAEH,KADFy+C,EAAMz7C,OAIpBqH,eAAgB,SAAwBq0C,GAGtC,MAAO,MAFIA,EAAM1+C,KAEKq4C,EAAK,IAAKz2B,EADf88B,EAAM9yB,WAC0B,OAEnDthB,eAAgB,SAAwBq0C,GACtC,IAAI3zB,EAAgB2zB,EAAM3zB,cACtBY,EAAa+yB,EAAM/yB,WACnBlB,EAAei0B,EAAMj0B,aACzB,OAAO9I,EAAK,CAAC,MAAOy2B,EAAK,MAAOrtB,GAAgBpJ,EAAKgK,EAAY,KAAMlB,GAAe,MAExFngB,mBAAoB,SAA4Bq0C,GAC9C,IAAI5+C,EAAO4+C,EAAM5+C,KACbgrB,EAAgB4zB,EAAM5zB,cACtBsS,EAAsBshB,EAAMthB,oBAC5B1R,EAAagzB,EAAMhzB,WACnBlB,EAAek0B,EAAMl0B,aACzB,OAEE,YAAY9lB,OAAO5E,GAAM4E,OAAOyzC,EAAK,IAAKz2B,EAAK0b,EAAqB,MAAO,KAAM,KAAO,MAAM14B,OAAOomB,EAAe,KAAKpmB,OAAOyzC,EAAK,GAAIz2B,EAAKgK,EAAY,KAAM,MAAQlB,IAI5KlgB,SAAU,SAAkBq0C,GAE1B,OADYA,EAAM77C,OAGpByH,WAAY,SAAoBq0C,GAE9B,OADYA,EAAM97C,OAGpB0H,YAAa,SAAqBq0C,EAAQt8C,GACxC,IAAIO,EAAQ+7C,EAAO/7C,MAEnB,OADoB+7C,EAAO/O,MACJltB,YAAiB9f,EAAe,gBAARP,EAAwB,GAAK,MAAQka,KAAKC,UAAU5Z,IAErG2H,aAAc,SAAsBq0C,GAElC,OADYA,EAAOh8C,MACJ,OAAS,SAE1B4H,UAAW,WACT,MAAO,QAETC,UAAW,SAAmBo0C,GAE5B,OADYA,EAAOj8C,OAGrB8H,UAAW,SAAmBo0C,GAE5B,MAAO,IAAMt9B,EADAs9B,EAAOxjB,OACM,MAAQ,KAEpC3wB,YAAa,SAAqBo0C,GAEhC,MAAO,IAAMv9B,EADAu9B,EAAO7jB,OACM,MAAQ,KAEpCtwB,YAAa,SAAqBo0C,GAGhC,OAFWA,EAAOp/C,KAEJ,KADFo/C,EAAOp8C,OAIrBiI,UAAW,SAAmBo0C,GAG5B,MAAO,IAFIA,EAAOr/C,KAEEq4C,EAAK,IAAKz2B,EADnBy9B,EAAO3+C,UACuB,MAAO,MAGlDwK,UAAW,SAAmBo0C,GAE5B,OADWA,EAAOt/C,MAGpBmL,SAAU,SAAkBo0C,GAE1B,MAAO,IADIA,EAAO52C,KACE,KAEtByC,YAAa,SAAqBo0C,GAEhC,OADWA,EAAO72C,KACJ,KAGhB0C,iBAAkB,SAA0Bo0C,GAC1C,IAAI7zB,EAAa6zB,EAAO7zB,WACpBklB,EAAiB2O,EAAO3O,eAC5B,OAAOlvB,EAAK,CAAC,SAAUA,EAAKgK,EAAY,KAAMokB,EAAMc,IAAkB,MAExExlC,wBAAyB,SAAiCo0C,GAGxD,OAFgBA,EAAOj2C,UAEJ,KADRi2C,EAAO/2C,MAGpB4C,qBAAsBo0C,GAAe,SAAUC,GAG7C,OAAOh+B,EAAK,CAAC,SAFFg+B,EAAO5/C,KAEW4hB,EADZg+B,EAAOh0B,WACsB,MAAO,QAEvDpgB,qBAAsBm0C,GAAe,SAAUE,GAC7C,IAAI7/C,EAAO6/C,EAAO7/C,KACdgxC,EAAa6O,EAAO7O,WACpBplB,EAAai0B,EAAOj0B,WACpB0P,EAASukB,EAAOvkB,OACpB,OAAO1Z,EAAK,CAAC,OAAQ5hB,EAAMq4C,EAAK,cAAez2B,EAAKovB,EAAY,QAASpvB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,QAElH7vB,gBAAiBk0C,GAAe,SAAUG,GACxC,IAAI9/C,EAAO8/C,EAAO9/C,KACduF,EAAOu6C,EAAOp/C,UACdiI,EAAOm3C,EAAOn3C,KACdijB,EAAak0B,EAAOl0B,WACxB,OAAO5rB,GAAQ+/C,EAAkBx6C,GAAQ8yC,EAAK,MAAO71B,EAAOZ,EAAKrc,EAAM,OAAQ,OAAS8yC,EAAK,IAAKz2B,EAAKrc,EAAM,MAAO,MAAQ,KAAOoD,EAAO0vC,EAAK,IAAKz2B,EAAKgK,EAAY,SAEvKlgB,qBAAsBi0C,GAAe,SAAUK,GAC7C,IAAIhgD,EAAOggD,EAAOhgD,KACd2I,EAAOq3C,EAAOr3C,KACd60B,EAAewiB,EAAOxiB,aACtB5R,EAAao0B,EAAOp0B,WACxB,OAAOhK,EAAK,CAAC5hB,EAAO,KAAO2I,EAAM0vC,EAAK,KAAM7a,GAAe5b,EAAKgK,EAAY,MAAO,QAErFjgB,wBAAyBg0C,GAAe,SAAUM,GAChD,IAAIjgD,EAAOigD,EAAOjgD,KACd4rB,EAAaq0B,EAAOr0B,WACpB0P,EAAS2kB,EAAO3kB,OACpB,OAAO1Z,EAAK,CAAC,YAAa5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,QAEzE1vB,oBAAqB+zC,GAAe,SAAUO,GAC5C,IAAIlgD,EAAOkgD,EAAOlgD,KACd4rB,EAAas0B,EAAOt0B,WACpBulB,EAAQ+O,EAAO/O,MACnB,OAAOvvB,EAAK,CAAC,QAAS5hB,EAAM4hB,EAAKgK,EAAY,KAAMulB,GAA0B,IAAjBA,EAAMvvC,OAAe,KAAOggB,EAAKuvB,EAAO,OAAS,IAAK,QAEpHtlC,mBAAoB8zC,GAAe,SAAUQ,GAC3C,IAAIngD,EAAOmgD,EAAOngD,KACd4rB,EAAau0B,EAAOv0B,WACpB8P,EAASykB,EAAOzkB,OACpB,OAAO9Z,EAAK,CAAC,OAAQ5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAMtU,IAAU,QAEpE5vB,oBAAqB6zC,GAAe,SAAUS,GAG5C,OAAOx+B,EAAK,CAFDw+B,EAAOpgD,KAEC4hB,EADFw+B,EAAOx0B,WACY,MAAO,QAE7C7f,0BAA2B4zC,GAAe,SAAUU,GAClD,IAAIrgD,EAAOqgD,EAAOrgD,KACd4rB,EAAay0B,EAAOz0B,WACpB0P,EAAS+kB,EAAO/kB,OACpB,OAAO1Z,EAAK,CAAC,QAAS5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,QAErEtvB,oBAAqB2zC,GAAe,SAAUW,GAC5C,IAAItgD,EAAOsgD,EAAOtgD,KACduF,EAAO+6C,EAAO5/C,UACd0xC,EAAakO,EAAOlO,WACpBzM,EAAY2a,EAAO3a,UACvB,MAAO,cAAgB3lC,GAAQ+/C,EAAkBx6C,GAAQ8yC,EAAK,MAAO71B,EAAOZ,EAAKrc,EAAM,OAAQ,OAAS8yC,EAAK,IAAKz2B,EAAKrc,EAAM,MAAO,OAAS6sC,EAAa,cAAgB,IAAM,OAASxwB,EAAK+jB,EAAW,UAE3M15B,gBAAiB,SAAyBs0C,GACxC,IAAI30B,EAAa20B,EAAO30B,WACpBklB,EAAiByP,EAAOzP,eAC5B,OAAOlvB,EAAK,CAAC,gBAAiBA,EAAKgK,EAAY,KAAMokB,EAAMc,IAAkB,MAE/E5kC,oBAAqB,SAA6Bs0C,GAGhD,OAAO5+B,EAAK,CAAC,gBAFF4+B,EAAOxgD,KAEkB4hB,EADnB4+B,EAAO50B,WAC6B,MAAO,MAE9Dzf,oBAAqB,SAA6Bs0C,GAChD,IAAIzgD,EAAOygD,EAAOzgD,KACdgxC,EAAayP,EAAOzP,WACpBplB,EAAa60B,EAAO70B,WACpB0P,EAASmlB,EAAOnlB,OACpB,OAAO1Z,EAAK,CAAC,cAAe5hB,EAAMq4C,EAAK,cAAez2B,EAAKovB,EAAY,QAASpvB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,MAEzHlvB,uBAAwB,SAAgCs0C,GACtD,IAAI1gD,EAAO0gD,EAAO1gD,KACd4rB,EAAa80B,EAAO90B,WACpB0P,EAASolB,EAAOplB,OACpB,OAAO1Z,EAAK,CAAC,mBAAoB5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,MAEhFjvB,mBAAoB,SAA4Bs0C,GAC9C,IAAI3gD,EAAO2gD,EAAO3gD,KACd4rB,EAAa+0B,EAAO/0B,WACpBulB,EAAQwP,EAAOxP,MACnB,OAAOvvB,EAAK,CAAC,eAAgB5hB,EAAM4hB,EAAKgK,EAAY,KAAMulB,GAA0B,IAAjBA,EAAMvvC,OAAe,KAAOggB,EAAKuvB,EAAO,OAAS,IAAK,MAE3H7kC,kBAAmB,SAA2Bs0C,GAC5C,IAAI5gD,EAAO4gD,EAAO5gD,KACd4rB,EAAag1B,EAAOh1B,WACpB8P,EAASklB,EAAOllB,OACpB,OAAO9Z,EAAK,CAAC,cAAe5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAMtU,IAAU,MAE3EnvB,yBAA0B,SAAkCs0C,GAC1D,IAAI7gD,EAAO6gD,EAAO7gD,KACd4rB,EAAai1B,EAAOj1B,WACpB0P,EAASulB,EAAOvlB,OACpB,OAAO1Z,EAAK,CAAC,eAAgB5hB,EAAM4hB,EAAKgK,EAAY,KAAMokB,EAAM1U,IAAU,OAI9E,SAASqkB,EAAe1qB,GACtB,OAAO,SAAU7nB,GACf,OAAOwU,EAAK,CAACxU,EAAK04B,YAAa7Q,EAAG7nB,IAAQ,OAS9C,SAASwU,EAAKk/B,EAAYC,GACxB,OAAOD,EAAaA,EAAWz3C,QAAO,SAAUC,GAC9C,OAAOA,KACNsY,KAAKm/B,GAAa,IAAM,GAQ7B,SAAS/Q,EAAM5qC,GACb,OAAOA,GAA0B,IAAjBA,EAAMxD,OAAe,MAAQ4gB,EAAOZ,EAAKxc,EAAO,OAAS,MAAQ,GAQnF,SAASizC,EAAKhnC,EAAO2vC,EAAa1vC,GAChC,OAAO0vC,EAAc3vC,EAAQ2vC,GAAe1vC,GAAO,IAAM,GAG3D,SAASkR,EAAOw+B,GACd,OAAOA,GAAe,KAAOA,EAAYrxC,QAAQ,MAAO,QAG1D,SAASsxC,EAAYvxC,GACnB,OAAiC,IAA1BA,EAAO9H,QAAQ,MAGxB,SAASm4C,EAAkBe,GACzB,OAAOA,GAAcA,EAAWl3B,KAAKq3B,G,ahChM1BC,EAAqB,CAChCC,KAhB2C,CAC3CC,cAAc,EACdC,mBAAmB,GAenBC,QAZqB,CAErBC,OAAQ,MACR,eAAgB,oBAUhB/uC,QAPqB,CACrBjS,OAAQ,SASGihD,EAAmB,SAAC7nC,EAAUrL,EAAQzO,GACjD,IAAMe,EAAQ,IAAIT,MAAMN,GAOxB,MALAe,EAAMZ,KAAO,cACbY,EAAM+Y,SAAWA,EACjB/Y,EAAM6gD,WAAa9nC,EAAS+nC,OAC5B9gD,EAAM0N,OAASA,EAET1N,GA8HK,EAA0B,SAACqG,EAAGqvB,GACzC,IAAIqrB,EACJ,IACEA,EAAahlC,KAAKC,UAAU3V,GAC5B,MAAO5C,GACP,IAAMu9C,EAAa,WAInB,MADAA,EAAWA,WAAav9C,EAClBu9C,EAER,OAAOD,G,sCiC/NI,EAAiB,SAACE,QAAA,IAAAA,MAAA,IAE3B,QAAAC,WAAA,mBAEA,IAAAC,MACAV,EAAA,EAAAA,kBACAW,EAAA,EAAAA,iBACA,yEjCoIwB,SAACC,GAC3B,IAAKA,GAA4B,qBAAVF,MAAuB,CAG5C,KADsB,qBAAX9tB,QAAkC,aACvC,YiCpIR,CAAaguB,GAKRA,IACHA,EAAUF,OAGZ,IAAMG,EAAa,CACjBf,KAAM,CAAEE,kBAAiB,GACzB7uC,QAAS2vC,EAAeC,aACxBC,YAAaF,EAAeE,YAC5Bf,QAASa,EAAeb,SAG1B,OAAO,IAAI,KAAW,SAAA73C,GACpB,IAAI64C,EjCuMiB,SACvB74C,EACA84C,GAEA,IACMC,EADU/4C,EAAUg5C,aACCX,IAE3B,OAAIU,IAE8B,oBAAhBD,EACTA,EAAY94C,GAEX84C,GAA0B,YiCnNlBG,CAAUj5C,EAAWq4C,GAE/Bx5C,EAAUmB,EAAUg5C,aAQpBE,EAAyB,GAC/B,GAAIr6C,EAAQ+jB,gBAAiB,CACrB,wBAAE,IAAArsB,KAAM6F,EAAA,EAAAA,QACV,IACF88C,EAAuB,6BAA+B,GAEpD98C,IACF88C,EAAuB,gCAAkC98C,GAI7D,IAiBI+8C,EAjBEC,EAAiB,OAAH,IAAG,CAAH,GAAQF,EAA2Br6C,EAAQg5C,SAEzDwB,EAAgB,CACpB3B,KAAM74C,EAAQ64C,KACd3uC,QAASlK,EAAQ85C,aACjBC,YAAa/5C,EAAQ+5C,YACrBf,QAASuB,GAIL,EjCyG8B,SACtCp5C,EACAs5C,G,IACA,wDAEA,IAAIvwC,EAAO,eACNuwC,EAAevwC,QAAO,CACzB8uC,QAASyB,EAAezB,QACxBe,YAAaU,EAAeV,cAE1BlB,EAAyB4B,EAAe5B,KAM5C6B,EAAQ1mC,SAAQ,SAAAgN,GACd9W,EAAU,OAAH,IAAG,CAAH,GACFA,EACA8W,EAAO9W,QAAO,CACjB8uC,QAAS,OAAF,IAAE,CAAF,GACF9uC,EAAQ8uC,QACRh4B,EAAOg4B,WAGVh4B,EAAO+4B,cAAa7vC,EAAQ6vC,YAAc/4B,EAAO+4B,aAErDlB,EAAO,OAAH,IAAG,CAAH,GACCA,EACA73B,EAAO63B,SAKN,IAAAz4C,EAAAe,EAAAf,cAAeiX,EAAA,EAAAA,WAAY1W,EAAA,EAAAA,UAAW8K,EAAA,EAAAA,MACxC5C,EAAa,CAAEzI,cAAa,EAAEO,UAAS,GAO7C,OALIk4C,EAAKE,oBAAoBlwC,EAAawO,WAAaA,GAGnDwhC,EAAKC,eAAejwC,EAAa4C,MAAQuqC,EAAMvqC,IAE5C,CACLvB,QAAO,EACPrB,KAAI,GiCrJE,UAAEqB,EAAA,EAAAA,QAASrB,EAAA,EAAAA,KAQjB,IAAMqB,EAAgBywC,OAAQ,CACtB,MjCuF2B,WACrC,GAA+B,qBAApBC,gBACT,MAAO,CAAEN,YAAY,EAAOK,QAAQ,GAEtC,IAAML,EAAa,IAAIM,gBAEvB,MAAO,CAAEN,WAAU,EAAEK,OADNL,EAAWK,QiC5FhB,GAAE,IAAAL,WAAyBK,EAAA,EAAAA,QACjCL,EAAaO,KACI3wC,EAAgBywC,OAASA,GAc5C,GANEjB,IACCv4C,EAAUsK,MAAM3K,YAAYwgB,MALF,SAAC7iB,GAC5B,MAAkB,wBAAXA,EAAEwC,MAAkD,aAAhBxC,EAAE0C,eAM7C+I,EAAQjS,OAAS,OAGI,QAAnBiS,EAAQjS,OAAkB,CACtB,MA8EZ,SAA0B+hD,EAAmBnxC,GAG3C,IAAMiyC,EAAc,GACdC,EAAgB,SAAC5gD,EAAaO,GAClCogD,EAAY3/C,KAAQhB,EAAG,IAAI6gD,mBAAmBtgD,KAG5C,UAAWmO,GACbkyC,EAAc,QAASlyC,EAAK4C,OAE1B5C,EAAKzI,eACP26C,EAAc,gBAAiBlyC,EAAKzI,eAEtC,GAAIyI,EAAKlI,UAAW,CAClB,IAAIs6C,OAAmB,EACvB,IACEA,EAAsB,EACpBpyC,EAAKlI,WAGP,MAAO24C,GACP,MAAO,CAAEA,WAAU,GAErByB,EAAc,YAAaE,GAE7B,GAAIpyC,EAAKwO,WAAY,CACnB,IAAI6jC,OAAoB,EACxB,IACEA,EAAuB,EACrBryC,EAAKwO,YAGP,MAAOiiC,GACP,MAAO,CAAEA,WAAU,GAErByB,EAAc,aAAcG,GAS9B,IAAIz4B,EAAW,GACb04B,EAAcnB,EACVoB,EAAgBpB,EAAU16C,QAAQ,MACjB,IAAnB87C,IACF34B,EAAWu3B,EAAUqB,OAAOD,GAC5BD,EAAcnB,EAAUqB,OAAO,EAAGD,IAEpC,IAAME,GAAkD,IAA9BH,EAAY77C,QAAQ,KAAc,IAAM,IAGlE,MAAO,CAAEi8C,OADPJ,EAAcG,EAAoBR,EAAYxhC,KAAK,KAAOmJ,GApIlD,MAAE84B,EAAA,EAAAA,OAAQjC,EAAA,EAAAA,WAChB,GAAIA,EACF,OAAO,YAAUA,GAEnBU,EAAYuB,OAEZ,IACGrxC,EAAgBrB,KAAO,EAAwBA,GAChD,MAAOywC,GACP,OAAO,YAAUA,GAIrB,OAAO,IAAI,KAAW,SAAA9jC,GjCRe,IAAAgf,EiC8DnC,OArDAmlB,EAAQK,EAAW9vC,GAChBkH,MAAK,SAAAC,GAEJ,OADAlQ,EAAUq6C,WAAW,CAAEnqC,SAAQ,IACxBA,KAERD,MjCdgCojB,EiCcDrzB,EjCde,SAACkQ,GACtD,OACEA,EACGoqC,OACArqC,MAAK,SAAAsqC,GACJ,IACE,OAAOrnC,KAAKpN,MAAMy0C,GAClB,MAAOngC,GACP,IAAM+9B,EAAa/9B,EAKnB,OAJA+9B,EAAW5hD,KAAO,mBAClB4hD,EAAWjoC,SAAWA,EACtBioC,EAAWH,WAAa9nC,EAAS+nC,OACjCE,EAAWoC,SAAWA,EACf/nC,QAAQyI,OAAOk9B,OAIzBloC,MAAK,SAACpL,GA2BL,OA1BIqL,EAAS+nC,QAAU,KAErBF,EACE7nC,EACArL,EACA,iDAAiDqL,EAAS+nC,QAM3Dl8C,MAAMyH,QAAQqB,IACdA,EAAOjN,eAAe,SACtBiN,EAAOjN,eAAe,WAGvBmgD,EACE7nC,EACArL,EACA,2CACE9I,MAAMyH,QAAQ6vB,GACVA,EAAWtsB,KAAI,SAAA6N,GAAM,OAAAA,EAAG3V,iBACxBo0B,EAAWp0B,eAAa,MAI3B4F,QiC7BNoL,MAAK,SAAApL,GAIJ,OAFAwP,EAAShb,KAAKwL,GACdwP,EAAS1C,WACF9M,KAER8I,OAAM,SAAAyM,GAEY,eAAbA,EAAI7jB,OAOJ6jB,EAAIvV,QAAUuV,EAAIvV,OAAO4J,QAAU2L,EAAIvV,OAAOkH,MA2BhDsI,EAAShb,KAAK+gB,EAAIvV,QAEpBwP,EAASld,MAAMijB,OAGZ,WAGD++B,GAAYA,EAAWqB,gBAkEnC,kBAEE,WAAYpnC,G,OACV,YAAM,EAAeA,GAAMc,UAAQ,KAEvC,OAL8B,iBAK9B,EALA,CAA8B","file":"static/js/29.7fd63f44.chunk.js","sourcesContent":["const genericMessage = \"Invariant Violation\";\nconst {\n  setPrototypeOf = function (obj: any, proto: any) {\n    obj.__proto__ = proto;\n    return obj;\n  },\n} = Object as any;\n\nexport class InvariantError extends Error {\n  framesToPop = 1;\n  name = genericMessage;\n  constructor(message: string | number = genericMessage) {\n    super(\n      typeof message === \"number\"\n        ? `${genericMessage}: ${message} (see https://github.com/apollographql/invariant-packages)`\n        : message\n    );\n    setPrototypeOf(this, InvariantError.prototype);\n  }\n}\n\nexport function invariant(condition: any, message?: string | number) {\n  if (!condition) {\n    throw new InvariantError(message);\n  }\n}\n\nfunction wrapConsoleMethod(method: \"warn\" | \"error\") {\n  return function () {\n    return console[method].apply(console, arguments as any);\n  } as (...args: any[]) => void;\n}\n\nexport namespace invariant {\n  export const warn = wrapConsoleMethod(\"warn\");\n  export const error = wrapConsoleMethod(\"error\");\n}\n\n// Code that uses ts-invariant with rollup-plugin-invariant may want to\n// import this process stub to avoid errors evaluating process.env.NODE_ENV.\n// However, because most ESM-to-CJS compilers will rewrite the process import\n// as tsInvariant.process, which prevents proper replacement by minifiers, we\n// also attempt to define the stub globally when it is not already defined.\nlet processStub: NodeJS.Process = { env: {} } as any;\nexport { processStub as process };\nif (typeof process === \"object\") {\n  processStub = process;\n} else try {\n  // Using Function to evaluate this assignment in global scope also escapes\n  // the strict mode of the current module, thereby allowing the assignment.\n  // Inspired by https://github.com/facebook/regenerator/pull/369.\n  Function(\"stub\", \"process = stub\")(processStub);\n} catch (atLeastWeTried) {\n  // The assignment can fail if a Content Security Policy heavy-handedly\n  // forbids Function usage. In those environments, developers should take\n  // extra care to replace process.env.NODE_ENV in their production builds,\n  // or define an appropriate global.process polyfill.\n}\n\nexport default invariant;\n","var _a = Object.prototype, toString = _a.toString, hasOwnProperty = _a.hasOwnProperty;\r\nvar Checker = /** @class */ (function () {\r\n    function Checker() {\r\n        this.aStack = [];\r\n        this.bStack = [];\r\n    }\r\n    Checker.prototype.reset = function () {\r\n        this.aStack.length = 0;\r\n        this.bStack.length = 0;\r\n        return this;\r\n    };\r\n    Checker.prototype.check = function (a, b) {\r\n        var _this = this;\r\n        // If the two values are strictly equal, our job is easy.\r\n        if (a === b) {\r\n            return true;\r\n        }\r\n        // Object.prototype.toString returns a representation of the runtime type of\r\n        // the given value that is considerably more precise than typeof.\r\n        var aTag = toString.call(a);\r\n        var bTag = toString.call(b);\r\n        // If the runtime types of a and b are different, they could maybe be equal\r\n        // under some interpretation of equality, but for simplicity and performance\r\n        // we just return false instead.\r\n        if (aTag !== bTag) {\r\n            return false;\r\n        }\r\n        switch (aTag) {\r\n            case '[object Array]':\r\n                // Arrays are a lot like other objects, but we can cheaply compare their\r\n                // lengths as a short-cut before comparing their elements.\r\n                if (a.length !== b.length) {\r\n                    return false;\r\n                }\r\n            // Fall through to object case...\r\n            case '[object Object]':\r\n                return this.withCycleGuard(a, b, function () {\r\n                    var aKeys = Object.keys(a);\r\n                    var bKeys = Object.keys(b);\r\n                    return (\r\n                    // If `a` and `b` have a different number of enumerable keys, they\r\n                    // must be different.\r\n                    aKeys.length === bKeys.length &&\r\n                        // Now make sure they have the same keys.\r\n                        bKeys.every(function (key) { return hasOwnProperty.call(a, key); }) &&\r\n                        // Finally, check deep equality of all child properties.\r\n                        aKeys.every(function (key) { return _this.check(a[key], b[key]); }));\r\n                });\r\n            case '[object Error]':\r\n                return a.name === b.name && a.message === b.message;\r\n            case '[object Number]':\r\n                // Handle NaN, which is !== itself.\r\n                if (a !== a)\r\n                    return b !== b;\r\n            // Fall through to shared +a === +b case...\r\n            case '[object Boolean]':\r\n            case '[object Date]':\r\n                return +a === +b;\r\n            case '[object RegExp]':\r\n            case '[object String]':\r\n                return a == \"\" + b;\r\n            case '[object Map]':\r\n            case '[object Set]': {\r\n                if (a.size !== b.size) {\r\n                    return false;\r\n                }\r\n                return this.withCycleGuard(a, b, function () {\r\n                    var aIterator = a.entries();\r\n                    while (true) {\r\n                        var info = aIterator.next();\r\n                        if (info.done)\r\n                            break;\r\n                        // If a instanceof Set, aValue === aKey.\r\n                        var _a = info.value, aKey = _a[0], aValue = _a[1];\r\n                        // So this works the same way for both Set and Map.\r\n                        if (!b.has(aKey)) {\r\n                            return false;\r\n                        }\r\n                        if (\r\n                        // However, we care about deep equality of values only when dealing\r\n                        // with Map structures.\r\n                        aTag === '[object Map]' &&\r\n                            !_this.check(aValue, b.get(aKey))) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                });\r\n            }\r\n        }\r\n        // Otherwise the values are not equal.\r\n        return false;\r\n    };\r\n    Checker.prototype.withCycleGuard = function (a, b, callback) {\r\n        // Although we may detect cycles at different depths along the same\r\n        // path, once the first object enters a cycle of length N, every nested\r\n        // child of that object will also be identical to its Nth ancestor, so\r\n        // we can safely keep recursing until the other object enters a cycle of\r\n        // length M. If the other object does not have a cycle in this subtree,\r\n        // the recursion will terminate normally, and equal(a, b) will return\r\n        // false. If the other object has a cycle, and N === M, we consider the\r\n        // cycles equivalent. If N !== M, there's a chance the cycles are\r\n        // somehow isomorphic, but as a matter of policy we say they are not the\r\n        // same because their structures are, in fact, different.\r\n        var aIndex = this.aStack.lastIndexOf(a);\r\n        if (aIndex >= 0) {\r\n            var bIndex = this.bStack.lastIndexOf(b);\r\n            if (bIndex >= 0) {\r\n                return aIndex === bIndex;\r\n            }\r\n        }\r\n        this.aStack.push(a);\r\n        this.bStack.push(b);\r\n        try {\r\n            return callback();\r\n        }\r\n        finally {\r\n            this.aStack.pop();\r\n            this.bStack.pop();\r\n        }\r\n    };\r\n    return Checker;\r\n}());\r\nvar checker = new Checker();\r\n/**\r\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\r\n */\r\nfunction equal(a, b) {\r\n    return checker.reset().check(a, b);\r\n}\n\nexport default equal;\nexport { equal };\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\n\nexport interface ApolloContextValue {\n  client?: ApolloClient<object>;\n  renderPromises?: Record<any, any>;\n}\n\nlet apolloContext: React.Context<ApolloContextValue>;\n\nexport function getApolloContext() {\n  if (!apolloContext) {\n    apolloContext = React.createContext<ApolloContextValue>({});\n  }\n  return apolloContext;\n}\n\nexport function resetApolloContext() {\n  apolloContext = React.createContext<ApolloContextValue>({});\n}\n","import {\n  DocumentNode,\n  DefinitionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode\n} from 'graphql';\nimport { invariant } from 'ts-invariant';\n\nexport enum DocumentType {\n  Query,\n  Mutation,\n  Subscription\n}\n\nexport interface IDocumentDefinition {\n  type: DocumentType;\n  name: string;\n  variables: ReadonlyArray<VariableDefinitionNode>;\n}\n\nconst cache = new Map();\n\nexport function operationName(type: DocumentType) {\n  let name;\n  switch (type) {\n    case DocumentType.Query:\n      name = 'Query';\n      break;\n    case DocumentType.Mutation:\n      name = 'Mutation';\n      break;\n    case DocumentType.Subscription:\n      name = 'Subscription';\n      break;\n  }\n  return name;\n}\n\n// This parser is mostly used to saftey check incoming documents.\nexport function parser(document: DocumentNode): IDocumentDefinition {\n  const cached = cache.get(document);\n  if (cached) return cached;\n\n  let variables, type, name;\n\n  invariant(\n    !!document && !!document.kind,\n    `Argument of ${document} passed to parser was not a valid GraphQL ` +\n      `DocumentNode. You may need to use 'graphql-tag' or another method ` +\n      `to convert your operation into a document`\n  );\n\n  const fragments = document.definitions.filter(\n    (x: DefinitionNode) => x.kind === 'FragmentDefinition'\n  );\n\n  const queries = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'query'\n  );\n\n  const mutations = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'mutation'\n  );\n\n  const subscriptions = document.definitions.filter(\n    (x: DefinitionNode) =>\n      x.kind === 'OperationDefinition' && x.operation === 'subscription'\n  );\n\n  invariant(\n    !fragments.length ||\n      (queries.length || mutations.length || subscriptions.length),\n    `Passing only a fragment to 'graphql' is not yet supported. ` +\n      `You must include a query, subscription or mutation as well`\n  );\n\n  invariant(\n    queries.length + mutations.length + subscriptions.length <= 1,\n    `react-apollo only supports a query, subscription, or a mutation per HOC. ` +\n      `${document} had ${queries.length} queries, ${subscriptions.length} ` +\n      `subscriptions and ${mutations.length} mutations. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  type = queries.length ? DocumentType.Query : DocumentType.Mutation;\n  if (!queries.length && !mutations.length) type = DocumentType.Subscription;\n\n  const definitions = queries.length\n    ? queries\n    : mutations.length\n    ? mutations\n    : subscriptions;\n\n  invariant(\n    definitions.length === 1,\n    `react-apollo only supports one definition per HOC. ${document} had ` +\n      `${definitions.length} definitions. ` +\n      `You can use 'compose' to join multiple operation types to a component`\n  );\n\n  const definition = definitions[0] as OperationDefinitionNode;\n  variables = definition.variableDefinitions || [];\n\n  if (definition.name && definition.name.kind === 'Name') {\n    name = definition.name.value;\n  } else {\n    name = 'data'; // fallback to using data if no name\n  }\n\n  const payload = { name, type, variables };\n  cache.set(document, payload);\n  return payload;\n}\n","import React from 'react';\nimport ApolloClient from 'apollo-client';\nimport { invariant } from 'ts-invariant';\n\nimport { getApolloContext } from './ApolloContext';\n\nexport interface ApolloProviderProps<TCache> {\n  client: ApolloClient<TCache>;\n  children: React.ReactNode | React.ReactNode[] | null;\n}\n\nexport const ApolloProvider: React.FC<ApolloProviderProps<any>> = ({\n  client,\n  children\n}) => {\n  const ApolloContext = getApolloContext();\n  return (\n    <ApolloContext.Consumer>\n      {(context = {}) => {\n        if (client && context.client !== client) {\n          context = Object.assign({}, context, { client });\n        }\n\n        invariant(\n          context.client,\n          'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.'\n        );\n\n        return (\n          <ApolloContext.Provider value={context}>\n            {children}\n          </ApolloContext.Provider>\n        );\n      }}\n    </ApolloContext.Consumer>\n  );\n};\n","import inspect from '../jsutils/inspect';\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error('Invalid AST Node: ' + inspect(node));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : visitorKeys[node.kind] || [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n\nfunction isNode(maybeNode) {\n  return Boolean(maybeNode && typeof maybeNode.kind === 'string');\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (!skipping[i]) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}","var parser = require('graphql/language/parser');\n\nvar parse = parser.parse;\n\n// Strip insignificant whitespace\n// Note that this could do a lot more, such as reorder fields etc.\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\n// A map docString -> graphql document\nvar docCache = {};\n\n// A map fragmentName -> [normalized source]\nvar fragmentSourceMap = {};\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\n// For testing.\nfunction resetCaches() {\n  docCache = {};\n  fragmentSourceMap = {};\n}\n\n// Take a unstripped parsed document (query/mutation or even fragment), and\n// check all fragment definitions, checking for name->source uniqueness.\n// We also want to make sure only unique fragments exist in the document.\nvar printFragmentWarnings = true;\nfunction processFragments(ast) {\n  var astFragmentMap = {};\n  var definitions = [];\n\n  for (var i = 0; i < ast.definitions.length; i++) {\n    var fragmentDefinition = ast.definitions[i];\n\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n\n      // We know something about this fragment\n      if (fragmentSourceMap.hasOwnProperty(fragmentName) && !fragmentSourceMap[fragmentName][sourceKey]) {\n\n        // this is a problem because the app developer is trying to register another fragment with\n        // the same name as one previously registered. So, we tell them about it.\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n            + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n            + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n\n      } else if (!fragmentSourceMap.hasOwnProperty(fragmentName)) {\n        fragmentSourceMap[fragmentName] = {};\n        fragmentSourceMap[fragmentName][sourceKey] = true;\n      }\n\n      if (!astFragmentMap[sourceKey]) {\n        astFragmentMap[sourceKey] = true;\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  }\n\n  ast.definitions = definitions;\n  return ast;\n}\n\nfunction disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\n\nfunction stripLoc(doc, removeLocAtThisLevel) {\n  var docType = Object.prototype.toString.call(doc);\n\n  if (docType === '[object Array]') {\n    return doc.map(function (d) {\n      return stripLoc(d, removeLocAtThisLevel);\n    });\n  }\n\n  if (docType !== '[object Object]') {\n    throw new Error('Unexpected input.');\n  }\n\n  // We don't want to remove the root loc field so we can use it\n  // for fragment substitution (see below)\n  if (removeLocAtThisLevel && doc.loc) {\n    delete doc.loc;\n  }\n\n  // https://github.com/apollographql/graphql-tag/issues/40\n  if (doc.loc) {\n    delete doc.loc.startToken;\n    delete doc.loc.endToken;\n  }\n\n  var keys = Object.keys(doc);\n  var key;\n  var value;\n  var valueType;\n\n  for (key in keys) {\n    if (keys.hasOwnProperty(key)) {\n      value = doc[keys[key]];\n      valueType = Object.prototype.toString.call(value);\n\n      if (valueType === '[object Object]' || valueType === '[object Array]') {\n        doc[keys[key]] = stripLoc(value, true);\n      }\n    }\n  }\n\n  return doc;\n}\n\nvar experimentalFragmentVariables = false;\nfunction parseDocument(doc) {\n  var cacheKey = normalize(doc);\n\n  if (docCache[cacheKey]) {\n    return docCache[cacheKey];\n  }\n\n  var parsed = parse(doc, { experimentalFragmentVariables: experimentalFragmentVariables });\n  if (!parsed || parsed.kind !== 'Document') {\n    throw new Error('Not a valid GraphQL document.');\n  }\n\n  // check that all \"new\" fragments inside the documents are consistent with\n  // existing fragments of the same name\n  parsed = processFragments(parsed);\n  parsed = stripLoc(parsed, false);\n  docCache[cacheKey] = parsed;\n\n  return parsed;\n}\n\nfunction enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\n\nfunction disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\n\n// XXX This should eventually disallow arbitrary string interpolation, like Relay does\nfunction gql(/* arguments */) {\n  var args = Array.prototype.slice.call(arguments);\n\n  var literals = args[0];\n\n  // We always get literals[0] and then matching post literals for each arg given\n  var result = (typeof(literals) === \"string\") ? literals : literals[0];\n\n  for (var i = 1; i < args.length; i++) {\n    if (args[i] && args[i].kind && args[i].kind === 'Document') {\n      result += args[i].loc.source.body;\n    } else {\n      result += args[i];\n    }\n\n    result += literals[i];\n  }\n\n  return parseDocument(result);\n}\n\n// Support typescript, which isn't as nice as Babel about default exports\ngql.default = gql;\ngql.resetCaches = resetCaches;\ngql.disableFragmentWarnings = disableFragmentWarnings;\ngql.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;\ngql.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;\n\nmodule.exports = gql;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","const { toString, hasOwnProperty } = Object.prototype;\nconst previousComparisons = new Map<object, Set<object>>();\n\n/**\n * Performs a deep equality check on two JavaScript values, tolerating cycles.\n */\nexport function equal(a: any, b: any): boolean {\n  try {\n    return check(a, b);\n  } finally {\n    previousComparisons.clear();\n  }\n}\n\n// Allow default imports as well.\nexport default equal;\n\nfunction check(a: any, b: any): boolean {\n  // If the two values are strictly equal, our job is easy.\n  if (a === b) {\n    return true;\n  }\n\n  // Object.prototype.toString returns a representation of the runtime type of\n  // the given value that is considerably more precise than typeof.\n  const aTag = toString.call(a);\n  const bTag = toString.call(b);\n\n  // If the runtime types of a and b are different, they could maybe be equal\n  // under some interpretation of equality, but for simplicity and performance\n  // we just return false instead.\n  if (aTag !== bTag) {\n    return false;\n  }\n\n  switch (aTag) {\n    case '[object Array]':\n      // Arrays are a lot like other objects, but we can cheaply compare their\n      // lengths as a short-cut before comparing their elements.\n      if (a.length !== b.length) return false;\n      // Fall through to object case...\n    case '[object Object]': {\n      if (previouslyCompared(a, b)) return true;\n\n      const aKeys = Object.keys(a);\n      const bKeys = Object.keys(b);\n\n      // If `a` and `b` have a different number of enumerable keys, they\n      // must be different.\n      const keyCount = aKeys.length;\n      if (keyCount !== bKeys.length) return false;\n\n      // Now make sure they have the same keys.\n      for (let k = 0; k < keyCount; ++k) {\n        if (!hasOwnProperty.call(b, aKeys[k])) {\n          return false;\n        }\n      }\n\n      // Finally, check deep equality of all child properties.\n      for (let k = 0; k < keyCount; ++k) {\n        const key = aKeys[k];\n        if (!check(a[key], b[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    case '[object Error]':\n      return a.name === b.name && a.message === b.message;\n\n    case '[object Number]':\n      // Handle NaN, which is !== itself.\n      if (a !== a) return b !== b;\n      // Fall through to shared +a === +b case...\n    case '[object Boolean]':\n    case '[object Date]':\n      return +a === +b;\n\n    case '[object RegExp]':\n    case '[object String]':\n      return a == `${b}`;\n\n    case '[object Map]':\n    case '[object Set]': {\n      if (a.size !== b.size) return false;\n      if (previouslyCompared(a, b)) return true;\n\n      const aIterator = a.entries();\n      const isMap = aTag === '[object Map]';\n\n      while (true) {\n        const info = aIterator.next();\n        if (info.done) break;\n\n        // If a instanceof Set, aValue === aKey.\n        const [aKey, aValue] = info.value;\n\n        // So this works the same way for both Set and Map.\n        if (!b.has(aKey)) {\n          return false;\n        }\n\n        // However, we care about deep equality of values only when dealing\n        // with Map structures.\n        if (isMap && !check(aValue, b.get(aKey))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  // Otherwise the values are not equal.\n  return false;\n}\n\nfunction previouslyCompared(a: object, b: object): boolean {\n  // Though cyclic references can make an object graph appear infinite from the\n  // perspective of a depth-first traversal, the graph still contains a finite\n  // number of distinct object references. We use the previousComparisons cache\n  // to avoid comparing the same pair of object references more than once, which\n  // guarantees termination (even if we end up comparing every object in one\n  // graph to every object in the other graph, which is extremely unlikely),\n  // while still allowing weird isomorphic structures (like rings with different\n  // lengths) a chance to pass the equality test.\n  let bSet = previousComparisons.get(a);\n  if (bSet) {\n    // Return true here because we can be sure false will be returned somewhere\n    // else if the objects are not equivalent.\n    if (bSet.has(b)) return true;\n  } else {\n    previousComparisons.set(a, bSet = new Set);\n  }\n  bSet.add(b);\n  return false;\n}\n","import { ApolloClient } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport { invariant } from 'ts-invariant';\nimport {\n  ApolloContextValue,\n  parser,\n  DocumentType,\n  operationName\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { CommonOptions } from '../types';\n\nexport abstract class OperationData<TOptions = any> {\n  public isMounted: boolean = false;\n  public previousOptions: CommonOptions<TOptions> = {} as CommonOptions<\n    TOptions\n  >;\n  public context: ApolloContextValue = {};\n  public client: ApolloClient<object> | undefined;\n\n  private options: CommonOptions<TOptions> = {} as CommonOptions<TOptions>;\n\n  constructor(options?: CommonOptions<TOptions>, context?: ApolloContextValue) {\n    this.options = options || ({} as CommonOptions<TOptions>);\n    this.context = context || {};\n  }\n\n  public getOptions(): CommonOptions<TOptions> {\n    return this.options;\n  }\n\n  public setOptions(\n    newOptions: CommonOptions<TOptions>,\n    storePrevious: boolean = false\n  ) {\n    if (storePrevious && !isEqual(this.options, newOptions)) {\n      this.previousOptions = this.options;\n    }\n    this.options = newOptions;\n  }\n\n  public abstract execute(...args: any): any;\n  public abstract afterExecute(...args: any): void | (() => void);\n  public abstract cleanup(): void;\n\n  protected unmount() {\n    this.isMounted = false;\n  }\n\n  protected refreshClient() {\n    const client =\n      (this.options && this.options.client) ||\n      (this.context && this.context.client);\n\n    invariant(\n      !!client,\n      'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ' +\n        'ApolloClient instance in via options.'\n    );\n\n    let isNew = false;\n    if (client !== this.client) {\n      isNew = true;\n      this.client = client;\n      this.cleanup();\n    }\n    return {\n      client: this.client as ApolloClient<object>,\n      isNew\n    };\n  }\n\n  protected verifyDocumentType(document: DocumentNode, type: DocumentType) {\n    const operation = parser(document);\n    const requiredOperationName = operationName(type);\n    const usedOperationName = operationName(operation.type);\n    invariant(\n      operation.type === type,\n      `Running a ${requiredOperationName} requires a graphql ` +\n        `${requiredOperationName}, but a ${usedOperationName} was used instead.`\n    );\n  }\n}\n","import {\n  ApolloQueryResult,\n  ApolloError,\n  NetworkStatus,\n  FetchMoreOptions,\n  FetchMoreQueryOptions,\n  UpdateQueryOptions,\n  SubscribeToMoreOptions\n} from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  QueryResult,\n  ObservableQueryFields\n} from '@apollo/react-common';\n\nimport {\n  QueryPreviousData,\n  QueryOptions,\n  QueryCurrentObservable,\n  QueryTuple,\n  QueryLazyOptions\n} from '../types';\nimport { OperationData } from './OperationData';\n\nexport class QueryData<TData, TVariables> extends OperationData {\n  private previousData: QueryPreviousData<TData, TVariables> = {};\n  private currentObservable: QueryCurrentObservable<TData, TVariables> = {};\n  private forceUpdate: any;\n\n  private runLazy: boolean = false;\n  private lazyOptions?: QueryLazyOptions<TVariables>;\n\n  constructor({\n    options,\n    context,\n    forceUpdate\n  }: {\n    options: QueryOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    forceUpdate: any;\n  }) {\n    super(options, context);\n    this.forceUpdate = forceUpdate;\n  }\n\n  public execute(): QueryResult<TData, TVariables> {\n    this.refreshClient();\n\n    const { skip, query } = this.getOptions();\n    if (skip || query !== this.previousData.query) {\n      this.removeQuerySubscription();\n      this.previousData.query = query;\n    }\n\n    this.updateObservableQuery();\n\n    if (this.isMounted) this.startQuerySubscription();\n\n    return this.getExecuteSsrResult() || this.getExecuteResult();\n  }\n\n  public executeLazy(): QueryTuple<TData, TVariables> {\n    return !this.runLazy\n      ? [\n          this.runLazyQuery,\n          {\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            called: false,\n            data: undefined\n          } as QueryResult<TData, TVariables>\n        ]\n      : [this.runLazyQuery, this.execute()];\n  }\n\n  // For server-side rendering\n  public fetchData(): Promise<ApolloQueryResult<any>> | boolean {\n    const options = this.getOptions();\n    if (options.skip || options.ssr === false) return false;\n\n    // currentObservable.query is already assigned the registered SSR observable in initializeObservableQuery.\n    const obs = this.currentObservable.query!;\n    const currentResult = obs.getCurrentResult();\n    return currentResult.loading ? obs.result() : false;\n  }\n\n  public afterExecute({ lazy = false }: { lazy?: boolean } = {}) {\n    this.isMounted = true;\n\n    if (!lazy || this.runLazy) {\n      this.handleErrorOrCompleted();\n\n      // When the component is done rendering stored query errors, we'll\n      // remove those errors from the `ObservableQuery` query store, so they\n      // aren't re-displayed on subsequent (potentially error free)\n      // requests/responses.\n      setTimeout(() => {\n        this.currentObservable.query &&\n          this.currentObservable.query.resetQueryStoreErrors();\n      });\n    }\n\n    this.previousOptions = this.getOptions();\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    this.removeQuerySubscription();\n    delete this.currentObservable.query;\n    delete this.previousData.result;\n  }\n\n  public getOptions() {\n    const options = super.getOptions();\n\n    if (this.lazyOptions) {\n      options.variables = {\n        ...options.variables,\n        ...this.lazyOptions.variables\n      };\n      options.context = {\n        ...options.context,\n        ...this.lazyOptions.context\n      };\n    }\n\n    // skip is not supported when using lazy query execution.\n    if (this.runLazy) {\n      delete options.skip;\n    }\n\n    return options;\n  }\n\n  private runLazyQuery = (options?: QueryLazyOptions<TVariables>) => {\n    this.cleanup();\n\n    this.runLazy = true;\n    this.lazyOptions = options;\n    this.forceUpdate();\n  };\n\n  private getExecuteResult = (): QueryResult<TData, TVariables> => {\n    const result = this.getQueryResult();\n    this.startQuerySubscription();\n    return result;\n  };\n\n  private getExecuteSsrResult() {\n    const treeRenderingInitiated = this.context && this.context.renderPromises;\n    const ssrDisabled = this.getOptions().ssr === false;\n    const fetchDisabled = this.refreshClient().client.disableNetworkFetches;\n\n    const ssrLoading = {\n      loading: true,\n      networkStatus: NetworkStatus.loading,\n      called: true,\n      data: undefined\n    } as QueryResult<TData, TVariables>;\n\n    // If SSR has been explicitly disabled, and this function has been called\n    // on the server side, return the default loading state.\n    if (ssrDisabled && (treeRenderingInitiated || fetchDisabled)) {\n      return ssrLoading;\n    }\n\n    let result;\n    if (treeRenderingInitiated) {\n      result =\n        this.context.renderPromises!.addQueryPromise(\n          this,\n          this.getExecuteResult\n        ) || ssrLoading;\n    }\n\n    return result;\n  }\n\n  private prepareObservableQueryOptions() {\n    const options = this.getOptions();\n    this.verifyDocumentType(options.query, DocumentType.Query);\n    const displayName = options.displayName || 'Query';\n\n    // Set the fetchPolicy to cache-first for network-only and cache-and-network\n    // fetches for server side renders.\n    if (\n      this.context &&\n      this.context.renderPromises &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options.fetchPolicy = 'cache-first';\n    }\n\n    return {\n      ...options,\n      displayName,\n      context: options.context,\n      metadata: { reactComponent: { displayName } }\n    };\n  }\n\n  private initializeObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    if (this.context && this.context.renderPromises) {\n      this.currentObservable.query = this.context.renderPromises.getSSRObservable(\n        this.getOptions()\n      );\n    }\n\n    if (!this.currentObservable.query) {\n      const observableQueryOptions = this.prepareObservableQueryOptions();\n\n      this.previousData.observableQueryOptions = {\n        ...observableQueryOptions,\n        children: null\n      };\n      this.currentObservable.query = this.refreshClient().client.watchQuery({\n        ...observableQueryOptions\n      });\n\n      if (this.context && this.context.renderPromises) {\n        this.context.renderPromises.registerSSRObservable(\n          this.currentObservable.query,\n          observableQueryOptions\n        );\n      }\n    }\n  }\n\n  private updateObservableQuery() {\n    // If we skipped initially, we may not have yet created the observable\n    if (!this.currentObservable.query) {\n      this.initializeObservableQuery();\n      return;\n    }\n\n    const newObservableQueryOptions = {\n      ...this.prepareObservableQueryOptions(),\n      children: null\n    };\n\n    if (\n      !isEqual(\n        newObservableQueryOptions,\n        this.previousData.observableQueryOptions\n      )\n    ) {\n      this.previousData.observableQueryOptions = newObservableQueryOptions;\n      this.currentObservable\n        .query!.setOptions(newObservableQueryOptions)\n        // The error will be passed to the child container, so we don't\n        // need to log it here. We could conceivably log something if\n        // an option was set. OTOH we don't log errors w/ the original\n        // query. See https://github.com/apollostack/react-apollo/issues/404\n        .catch(() => {});\n    }\n  }\n\n  private startQuerySubscription() {\n    if (this.currentObservable.subscription || this.getOptions().skip) return;\n\n    const obsQuery = this.currentObservable.query!;\n    this.currentObservable.subscription = obsQuery.subscribe({\n      next: ({ loading, networkStatus, data }) => {\n        const previousResult = this.previousData.result;\n\n        // Make sure we're not attempting to re-render similar results\n        if (\n          previousResult &&\n          previousResult.loading === loading &&\n          previousResult.networkStatus === networkStatus &&\n          isEqual(previousResult.data, data)\n        ) {\n          return;\n        }\n\n        this.forceUpdate();\n      },\n      error: error => {\n        this.resubscribeToQuery();\n        if (!error.hasOwnProperty('graphQLErrors')) throw error;\n\n        const previousResult = this.previousData.result;\n        if (\n          (previousResult && previousResult.loading) ||\n          !isEqual(error, this.previousData.error)\n        ) {\n          this.previousData.error = error;\n          this.forceUpdate();\n        }\n      }\n    });\n  }\n\n  private resubscribeToQuery() {\n    this.removeQuerySubscription();\n\n    // Unfortunately, if `lastError` is set in the current\n    // `observableQuery` when the subscription is re-created,\n    // the subscription will immediately receive the error, which will\n    // cause it to terminate again. To avoid this, we first clear\n    // the last error/result from the `observableQuery` before re-starting\n    // the subscription, and restore it afterwards (so the subscription\n    // has a chance to stay open).\n    const lastError = this.currentObservable.query!.getLastError();\n    const lastResult = this.currentObservable.query!.getLastResult();\n    this.currentObservable.query!.resetLastResults();\n    this.startQuerySubscription();\n    Object.assign(this.currentObservable.query!, {\n      lastError,\n      lastResult\n    });\n  }\n\n  private getQueryResult(): QueryResult<TData, TVariables> {\n    let result: any = this.observableQueryFields();\n    const options = this.getOptions();\n\n    // When skipping a query (ie. we're not querying for data but still want\n    // to render children), make sure the `data` is cleared out and\n    // `loading` is set to `false` (since we aren't loading anything).\n    if (options.skip) {\n      result = {\n        ...result,\n        data: undefined,\n        error: undefined,\n        loading: false,\n        called: true\n      };\n    } else {\n      // Fetch the current result (if any) from the store.\n      const currentResult = this.currentObservable.query!.getCurrentResult();\n      const { loading, partial, networkStatus, errors } = currentResult;\n      let { error, data } = currentResult;\n\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      if (errors && errors.length > 0) {\n        error = new ApolloError({ graphQLErrors: errors });\n      }\n\n      result = {\n        ...result,\n        loading,\n        networkStatus,\n        error,\n        called: true\n      };\n\n      if (loading) {\n        const previousData =\n          this.previousData.result && this.previousData.result.data;\n        result.data =\n          previousData && data\n            ? {\n                ...previousData,\n                ...data\n              }\n            : previousData || data;\n      } else if (error) {\n        Object.assign(result, {\n          data: (this.currentObservable.query!.getLastResult() || ({} as any))\n            .data\n        });\n      } else {\n        const { fetchPolicy } = this.currentObservable.query!.options;\n        const { partialRefetch } = options;\n        if (\n          partialRefetch &&\n          !data &&\n          partial &&\n          fetchPolicy !== 'cache-only'\n        ) {\n          // When a `Query` component is mounted, and a mutation is executed\n          // that returns the same ID as the mounted `Query`, but has less\n          // fields in its result, Apollo Client's `QueryManager` returns the\n          // data as `undefined` since a hit can't be found in the cache.\n          // This can lead to application errors when the UI elements rendered by\n          // the original `Query` component are expecting certain data values to\n          // exist, and they're all of a sudden stripped away. To help avoid\n          // this we'll attempt to refetch the `Query` data.\n          Object.assign(result, {\n            loading: true,\n            networkStatus: NetworkStatus.loading\n          });\n          result.refetch();\n          return result;\n        }\n\n        result.data = data;\n      }\n    }\n\n    result.client = this.client;\n    this.previousData.loading =\n      (this.previousData.result && this.previousData.result.loading) || false;\n    this.previousData.result = result;\n    return result;\n  }\n\n  private handleErrorOrCompleted() {\n    const obsQuery = this.currentObservable.query;\n    if (!obsQuery) return;\n\n    const { data, loading, error } = obsQuery.getCurrentResult();\n\n    if (!loading) {\n      const { query, variables, onCompleted, onError } = this.getOptions();\n\n      // No changes, so we won't call onError/onCompleted.\n      if (\n        this.previousOptions &&\n        !this.previousData.loading &&\n        isEqual(this.previousOptions.query, query) &&\n        isEqual(this.previousOptions.variables, variables)\n      ) {\n        return;\n      }\n\n      if (onCompleted && !error) {\n        onCompleted(data);\n      } else if (onError && error) {\n        onError(error);\n      }\n    }\n  }\n\n  private removeQuerySubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n\n  private obsRefetch = (variables?: TVariables) =>\n    this.currentObservable.query!.refetch(variables);\n\n  private obsFetchMore = <K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>\n  ) => this.currentObservable.query!.fetchMore(fetchMoreOptions);\n\n  private obsUpdateQuery = <TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>\n    ) => TData\n  ) => this.currentObservable.query!.updateQuery(mapFn);\n\n  private obsStartPolling = (pollInterval: number) => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.startPolling(pollInterval);\n  };\n\n  private obsStopPolling = () => {\n    this.currentObservable &&\n      this.currentObservable.query! &&\n      this.currentObservable.query!.stopPolling();\n  };\n\n  private obsSubscribeToMore = <\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >\n  ) => this.currentObservable.query!.subscribeToMore(options);\n\n  private observableQueryFields() {\n    const observable = this.currentObservable.query!;\n    return {\n      variables: observable.variables,\n      refetch: this.obsRefetch,\n      fetchMore: this.obsFetchMore,\n      updateQuery: this.obsUpdateQuery,\n      startPolling: this.obsStartPolling,\n      stopPolling: this.obsStopPolling,\n      subscribeToMore: this.obsSubscribeToMore\n    } as ObservableQueryFields<TData, TVariables>;\n  }\n}\n","import { useContext, useEffect, useReducer, useRef } from 'react';\nimport {\n  getApolloContext,\n  OperationVariables,\n  QueryResult\n} from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions, QueryOptions, QueryTuple } from '../types';\nimport { QueryData } from '../data/QueryData';\nimport { useDeepMemo } from './useDeepMemo';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n\n  if (!queryDataRef.current) {\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryOptions<TData, TVariables>,\n      context,\n      forceUpdate\n    });\n  }\n\n  const queryData = queryDataRef.current;\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: { ...updatedOptions, onError: undefined, onCompleted: undefined },\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data\n  ]);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  return result;\n}\n","import { useRef } from 'react';\nimport { equal as isEqual } from '@wry/equality';\n\n/**\n * Memoize a result using deep equality. This hook has two advantages over\n * React.useMemo: it uses deep equality to compare memo keys, and it guarantees\n * that the memo function will only be called if the keys are unequal.\n * React.useMemo cannot be relied on to do this, since it is only a performance\n * optimization (see https://reactjs.org/docs/hooks-reference.html#usememo).\n */\nexport function useDeepMemo<TKey, TValue>(\n  memoFn: () => TValue,\n  key: TKey\n): TValue {\n  const ref = useRef<{ key: TKey; value: TValue }>();\n\n  if (!ref.current || !isEqual(key, ref.current.key)) {\n    ref.current = { key, value: memoFn() };\n  }\n\n  return ref.current.value;\n}\n","import { OperationVariables, QueryResult } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { QueryHookOptions } from './types';\nimport { useBaseQuery } from './utils/useBaseQuery';\n\nexport function useQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode,\n  options?: QueryHookOptions<TData, TVariables>\n) {\n  return useBaseQuery<TData, TVariables>(query, options, false) as QueryResult<\n    TData,\n    TVariables\n  >;\n}\n","import { ApolloError } from 'apollo-client';\nimport { equal as isEqual } from '@wry/equality';\nimport {\n  ApolloContextValue,\n  DocumentType,\n  OperationVariables,\n  ExecutionResult,\n  MutationFunctionOptions,\n  MutationResult\n} from '@apollo/react-common';\n\nimport { MutationOptions, MutationTuple } from '../types';\nimport { OperationData } from './OperationData';\n\nexport class MutationData<\n  TData = any,\n  TVariables = OperationVariables\n> extends OperationData {\n  private mostRecentMutationId: number;\n  private result: MutationResult<TData>;\n  private previousResult?: MutationResult<TData>;\n  private setResult: (result: MutationResult<TData>) => any;\n\n  constructor({\n    options,\n    context,\n    result,\n    setResult\n  }: {\n    options: MutationOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    result: MutationResult<TData>;\n    setResult: (result: MutationResult<TData>) => any;\n  }) {\n    super(options, context);\n    this.verifyDocumentType(options.mutation, DocumentType.Mutation);\n    this.result = result;\n    this.setResult = setResult;\n    this.mostRecentMutationId = 0;\n  }\n\n  public execute(result: MutationResult<TData>) {\n    this.isMounted = true;\n    this.verifyDocumentType(this.getOptions().mutation, DocumentType.Mutation);\n    result.client = this.refreshClient().client;\n    return [this.runMutation, result] as MutationTuple<TData, TVariables>;\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n    return this.unmount.bind(this);\n  }\n\n  public cleanup() {\n    // No cleanup required.\n  }\n\n  private runMutation = (\n    mutationFunctionOptions: MutationFunctionOptions<\n      TData,\n      TVariables\n    > = {} as MutationFunctionOptions<TData, TVariables>\n  ) => {\n    this.onMutationStart();\n    const mutationId = this.generateNewMutationId();\n\n    return this.mutate(mutationFunctionOptions)\n      .then((response: ExecutionResult<TData>) => {\n        this.onMutationCompleted(response, mutationId);\n        return response;\n      })\n      .catch((error: ApolloError) => {\n        this.onMutationError(error, mutationId);\n        if (!this.getOptions().onError) throw error;\n      });\n  };\n\n  private mutate(\n    mutationFunctionOptions: MutationFunctionOptions<TData, TVariables>\n  ) {\n    const {\n      mutation,\n      variables,\n      optimisticResponse,\n      update,\n      context: mutationContext = {},\n      awaitRefetchQueries = false,\n      fetchPolicy\n    } = this.getOptions();\n    const mutateOptions = { ...mutationFunctionOptions };\n\n    const mutateVariables = Object.assign(\n      {},\n      variables,\n      mutateOptions.variables\n    );\n    delete mutateOptions.variables;\n\n    return this.refreshClient().client.mutate({\n      mutation,\n      optimisticResponse,\n      refetchQueries:\n        mutateOptions.refetchQueries || this.getOptions().refetchQueries,\n      awaitRefetchQueries,\n      update,\n      context: mutationContext,\n      fetchPolicy,\n      variables: mutateVariables,\n      ...mutateOptions\n    });\n  }\n\n  private onMutationStart() {\n    if (!this.result.loading && !this.getOptions().ignoreResults) {\n      this.updateResult({\n        loading: true,\n        error: undefined,\n        data: undefined,\n        called: true\n      });\n    }\n  }\n\n  private onMutationCompleted(\n    response: ExecutionResult<TData>,\n    mutationId: number\n  ) {\n    const { onCompleted, ignoreResults } = this.getOptions();\n\n    const { data, errors } = response;\n    const error =\n      errors && errors.length > 0\n        ? new ApolloError({ graphQLErrors: errors })\n        : undefined;\n\n    const callOncomplete = () =>\n      onCompleted ? onCompleted(data as TData) : null;\n\n    if (this.isMostRecentMutation(mutationId) && !ignoreResults) {\n      this.updateResult({\n        called: true,\n        loading: false,\n        data,\n        error\n      });\n    }\n    callOncomplete();\n  }\n\n  private onMutationError(error: ApolloError, mutationId: number) {\n    const { onError } = this.getOptions();\n\n    if (this.isMostRecentMutation(mutationId)) {\n      this.updateResult({\n        loading: false,\n        error,\n        data: undefined,\n        called: true\n      });\n    }\n\n    if (onError) {\n      onError(error);\n    }\n  }\n\n  private generateNewMutationId(): number {\n    return ++this.mostRecentMutationId;\n  }\n\n  private isMostRecentMutation(mutationId: number) {\n    return this.mostRecentMutationId === mutationId;\n  }\n\n  private updateResult(result: MutationResult<TData>) {\n    if (\n      this.isMounted &&\n      (!this.previousResult || !isEqual(this.previousResult, result))\n    ) {\n      this.setResult(result);\n      this.previousResult = result;\n    }\n  }\n}\n","import { useContext, useState, useRef, useEffect } from 'react';\nimport { getApolloContext, OperationVariables } from '@apollo/react-common';\nimport { DocumentNode } from 'graphql';\n\nimport { MutationHookOptions, MutationTuple } from './types';\nimport { MutationData } from './data/MutationData';\n\nexport function useMutation<TData = any, TVariables = OperationVariables>(\n  mutation: DocumentNode,\n  options?: MutationHookOptions<TData, TVariables>\n): MutationTuple<TData, TVariables> {\n  const context = useContext(getApolloContext());\n  const [result, setResult] = useState({ called: false, loading: false });\n  const updatedOptions = options ? { ...options, mutation } : { mutation };\n\n  const mutationDataRef = useRef<MutationData<TData, TVariables>>();\n  function getMutationDataRef() {\n    if (!mutationDataRef.current) {\n      mutationDataRef.current = new MutationData<TData, TVariables>({\n        options: updatedOptions,\n        context,\n        result,\n        setResult\n      });\n    }\n    return mutationDataRef.current;\n  }\n\n  const mutationData = getMutationDataRef();\n  mutationData.setOptions(updatedOptions);\n  mutationData.context = context;\n\n  useEffect(() => mutationData.afterExecute());\n\n  return mutationData.execute(result);\n}\n","import { equal as isEqual } from '@wry/equality';\nimport { ApolloContextValue, SubscriptionResult } from '@apollo/react-common';\n\nimport { OperationData } from './OperationData';\nimport { SubscriptionCurrentObservable, SubscriptionOptions } from '../types';\n\nexport class SubscriptionData<\n  TData = any,\n  TVariables = any\n> extends OperationData<SubscriptionOptions<TData, TVariables>> {\n  private setResult: any;\n  private currentObservable: SubscriptionCurrentObservable = {};\n\n  constructor({\n    options,\n    context,\n    setResult\n  }: {\n    options: SubscriptionOptions<TData, TVariables>;\n    context: ApolloContextValue;\n    setResult: any;\n  }) {\n    super(options, context);\n    this.setResult = setResult;\n    this.initialize(options);\n  }\n\n  public execute(result: SubscriptionResult<TData>) {\n    if (this.getOptions().skip === true) {\n      this.cleanup();\n      return {\n        loading: false,\n        error: undefined,\n        data: undefined,\n        variables: this.getOptions().variables\n      };\n    }\n\n    let currentResult = result;\n    if (this.refreshClient().isNew) {\n      currentResult = this.getLoadingResult();\n    }\n\n    let { shouldResubscribe } = this.getOptions();\n    if (typeof shouldResubscribe === 'function') {\n      shouldResubscribe = !!shouldResubscribe(this.getOptions());\n    }\n\n    if (\n      shouldResubscribe !== false &&\n      this.previousOptions &&\n      Object.keys(this.previousOptions).length > 0 &&\n      (this.previousOptions.subscription !== this.getOptions().subscription ||\n        !isEqual(this.previousOptions.variables, this.getOptions().variables) ||\n        this.previousOptions.skip !== this.getOptions().skip)\n    ) {\n      this.cleanup();\n      currentResult = this.getLoadingResult();\n    }\n\n    this.initialize(this.getOptions());\n    this.startSubscription();\n\n    this.previousOptions = this.getOptions();\n    return { ...currentResult, variables: this.getOptions().variables };\n  }\n\n  public afterExecute() {\n    this.isMounted = true;\n  }\n\n  public cleanup() {\n    this.endSubscription();\n    delete this.currentObservable.query;\n  }\n\n  private initialize(options: SubscriptionOptions<TData, TVariables>) {\n    if (this.currentObservable.query || this.getOptions().skip === true) return;\n    this.currentObservable.query = this.refreshClient().client.subscribe({\n      query: options.subscription,\n      variables: options.variables,\n      fetchPolicy: options.fetchPolicy\n    });\n  }\n\n  private startSubscription() {\n    if (this.currentObservable.subscription) return;\n    this.currentObservable.subscription = this.currentObservable.query!.subscribe(\n      {\n        next: this.updateCurrentData.bind(this),\n        error: this.updateError.bind(this),\n        complete: this.completeSubscription.bind(this)\n      }\n    );\n  }\n\n  private getLoadingResult() {\n    return {\n      loading: true,\n      error: undefined,\n      data: undefined\n    };\n  }\n\n  private updateResult(result: SubscriptionResult) {\n    if (this.isMounted) {\n      this.setResult(result);\n    }\n  }\n\n  private updateCurrentData(result: SubscriptionResult<TData>) {\n    const { onSubscriptionData } = this.getOptions();\n\n    this.updateResult({\n      data: result.data,\n      loading: false,\n      error: undefined\n    });\n\n    if (onSubscriptionData) {\n      onSubscriptionData({\n        client: this.refreshClient().client,\n        subscriptionData: result\n      });\n    }\n  }\n\n  private updateError(error: any) {\n    this.updateResult({\n      error,\n      loading: false\n    });\n  }\n\n  private completeSubscription() {\n    const { onSubscriptionComplete } = this.getOptions();\n    if (onSubscriptionComplete) onSubscriptionComplete();\n    this.endSubscription();\n  }\n\n  private endSubscription() {\n    if (this.currentObservable.subscription) {\n      this.currentObservable.subscription.unsubscribe();\n      delete this.currentObservable.subscription;\n    }\n  }\n}\n","import { ObservableQuery } from 'apollo-client';\nimport { QueryOptions } from '../types';\nimport { DocumentNode } from 'graphql';\nimport { QueryData } from '../data/QueryData';\n\ntype QueryInfo = {\n  seen: boolean;\n  observable: ObservableQuery<any, any> | null;\n};\n\nfunction makeDefaultQueryInfo(): QueryInfo {\n  return {\n    seen: false,\n    observable: null\n  };\n}\n\nexport class RenderPromises {\n  // Map from Query component instances to pending fetchData promises.\n  private queryPromises = new Map<QueryOptions<any, any>, Promise<any>>();\n\n  // Two-layered map from (query document, stringified variables) to QueryInfo\n  // objects. These QueryInfo objects are intended to survive through the whole\n  // getMarkupFromTree process, whereas specific Query instances do not survive\n  // beyond a single call to renderToStaticMarkup.\n  private queryInfoTrie = new Map<DocumentNode, Map<string, QueryInfo>>();\n\n  // Registers the server side rendered observable.\n  public registerSSRObservable<TData, TVariables>(\n    observable: ObservableQuery<any, TVariables>,\n    props: QueryOptions<TData, TVariables>\n  ) {\n    this.lookupQueryInfo(props).observable = observable;\n  }\n\n  // Get's the cached observable that matches the SSR Query instances query and variables.\n  public getSSRObservable<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ) {\n    return this.lookupQueryInfo(props).observable;\n  }\n\n  public addQueryPromise<TData, TVariables>(\n    queryInstance: QueryData<TData, TVariables>,\n    finish: () => React.ReactNode\n  ): React.ReactNode {\n    const info = this.lookupQueryInfo(queryInstance.getOptions());\n    if (!info.seen) {\n      this.queryPromises.set(\n        queryInstance.getOptions(),\n        new Promise(resolve => {\n          resolve(queryInstance.fetchData());\n        })\n      );\n      // Render null to abandon this subtree for this rendering, so that we\n      // can wait for the data to arrive.\n      return null;\n    }\n    return finish();\n  }\n\n  public hasPromises() {\n    return this.queryPromises.size > 0;\n  }\n\n  public consumeAndAwaitPromises() {\n    const promises: Promise<any>[] = [];\n    this.queryPromises.forEach((promise, queryInstance) => {\n      // Make sure we never try to call fetchData for this query document and\n      // these variables again. Since the queryInstance objects change with\n      // every rendering, deduplicating them by query and variables is the\n      // best we can do. If a different Query component happens to have the\n      // same query document and variables, it will be immediately rendered\n      // by calling finish() in addQueryPromise, which could result in the\n      // rendering of an unwanted loading state, but that's not nearly as bad\n      // as getting stuck in an infinite rendering loop because we kept calling\n      // queryInstance.fetchData for the same Query component indefinitely.\n      this.lookupQueryInfo(queryInstance).seen = true;\n      promises.push(promise);\n    });\n    this.queryPromises.clear();\n    return Promise.all(promises);\n  }\n\n  private lookupQueryInfo<TData, TVariables>(\n    props: QueryOptions<TData, TVariables>\n  ): QueryInfo {\n    const { queryInfoTrie } = this;\n    const { query, variables } = props;\n    const varMap = queryInfoTrie.get(query) || new Map<string, QueryInfo>();\n    if (!queryInfoTrie.has(query)) queryInfoTrie.set(query, varMap);\n    const variablesString = JSON.stringify(variables);\n    const info = varMap.get(variablesString) || makeDefaultQueryInfo();\n    if (!varMap.has(variablesString)) varMap.set(variablesString, info);\n    return info;\n  }\n}\n","'use strict';\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n","import Observable from 'zen-observable-ts';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nimport { getOperationName } from 'apollo-utilities';\nimport { invariant, InvariantError } from 'ts-invariant';\nexport { getOperationName };\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX We're assuming here that query and variables will be serialized in\n  // the same order, which might not always be true.\n  const { query, variables, operationName } = operation;\n  return JSON.stringify([operationName, query, variables]);\n}\n","import Observable from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nexport function empty(): ApolloLink {\n  return new ApolloLink(() => Observable.of());\n}\n\nexport function from(links: ApolloLink[]): ApolloLink {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n}\n\nexport function split(\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right?: ApolloLink | RequestHandler,\n): ApolloLink {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    invariant.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n","/* tslint:disable */\n\nimport zenObservable from 'zen-observable';\n\nnamespace Observable {\n\n}\n\nimport { ZenObservable } from './types';\n\nexport { ZenObservable };\n\nexport type Observer<T> = ZenObservable.Observer<T>;\nexport type Subscriber<T> = ZenObservable.Subscriber<T>;\nexport type ObservableLike<T> = ZenObservable.ObservableLike<T>;\n\nexport const Observable: {\n  new <T>(subscriber: Subscriber<T>): Observable<T>;\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n} = <any>zenObservable;\n\nexport interface Observable<T> {\n  subscribe(\n    observerOrNext: ((value: T) => void) | ZenObservable.Observer<T>,\n    error?: (error: any) => void,\n    complete?: () => void,\n  ): ZenObservable.Subscription;\n\n  forEach(fn: (value: T) => void): Promise<void>;\n\n  map<R>(fn: (value: T) => R): Observable<R>;\n\n  filter(fn: (value: T) => boolean): Observable<T>;\n\n  reduce<R = T>(\n    fn: (previousValue: R | T, currentValue: T) => R | T,\n    initialValue?: R | T,\n  ): Observable<R | T>;\n\n  flatMap<R>(fn: (value: T) => ZenObservable.ObservableLike<R>): Observable<R>;\n\n  from<R>(\n    observable: Observable<R> | ZenObservable.ObservableLike<R> | ArrayLike<R>,\n  ): Observable<R>;\n  of<R>(...args: Array<R>): Observable<R>;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { assign } from './util/assign';\n\nimport { valueToObjectRepresentation, JsonValue } from './storeUtils';\n\nexport function getMutationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode {\n  checkDocument(doc);\n\n  let mutationDef: OperationDefinitionNode | null = doc.definitions.filter(\n    definition =>\n      definition.kind === 'OperationDefinition' &&\n      definition.operation === 'mutation',\n  )[0] as OperationDefinitionNode;\n\n  invariant(mutationDef, 'Must contain a mutation definition.');\n\n  return mutationDef;\n}\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationDefinitionOrDie(\n  document: DocumentNode,\n): OperationDefinitionNode {\n  const def = getOperationDefinition(document);\n  invariant(def, `GraphQL document is missing an operation`);\n  return def;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x.name.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\n/**\n * This is an interface that describes a map from fragment names to fragment definitions.\n */\nexport interface FragmentMap {\n  [fragmentName: string]: FragmentDefinitionNode;\n}\n\n// Utility function that takes a list of fragment definitions and makes a hash out of them\n// that maps the name of the fragment to the fragment definition.\nexport function createFragmentMap(\n  fragments: FragmentDefinitionNode[] = [],\n): FragmentMap {\n  const symTable: FragmentMap = {};\n  fragments.forEach(fragment => {\n    symTable[fragment.name.value] = fragment;\n  });\n\n  return symTable;\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): { [key: string]: JsonValue } {\n  if (\n    definition &&\n    definition.variableDefinitions &&\n    definition.variableDefinitions.length\n  ) {\n    const defaultValues = definition.variableDefinitions\n      .filter(({ defaultValue }) => defaultValue)\n      .map(\n        ({ variable, defaultValue }): { [key: string]: JsonValue } => {\n          const defaultValueObj: { [key: string]: JsonValue } = {};\n          valueToObjectRepresentation(\n            defaultValueObj,\n            variable.name,\n            defaultValue as ValueNode,\n          );\n\n          return defaultValueObj;\n        },\n      );\n\n    return assign({}, ...defaultValues);\n  }\n\n  return {};\n}\n\n/**\n * Returns the names of all variables declared by the operation.\n */\nexport function variablesInOperation(\n  operation: OperationDefinitionNode,\n): Set<string> {\n  const names = new Set<string>();\n  if (operation.variableDefinitions) {\n    for (const definition of operation.variableDefinitions) {\n      names.add(definition.variable.name.value);\n    }\n  }\n\n  return names;\n}\n","export const canUseWeakMap = typeof WeakMap === 'function' && !(\n  typeof navigator === 'object' &&\n  navigator.product === 'ReactNative'\n);\n","const { toString } = Object.prototype;\n\n/**\n * Deeply clones a value to create a new instance.\n */\nexport function cloneDeep<T>(value: T): T {\n  return cloneDeepHelper(value, new Map());\n}\n\nfunction cloneDeepHelper<T>(val: T, seen: Map<any, any>): T {\n  switch (toString.call(val)) {\n  case \"[object Array]\": {\n    if (seen.has(val)) return seen.get(val);\n    const copy: T & any[] = (val as any).slice(0);\n    seen.set(val, copy);\n    copy.forEach(function (child, i) {\n      copy[i] = cloneDeepHelper(child, seen);\n    });\n    return copy;\n  }\n\n  case \"[object Object]\": {\n    if (seen.has(val)) return seen.get(val);\n    // High fidelity polyfills of Object.create and Object.getPrototypeOf are\n    // possible in all JS environments, so we will assume they exist/work.\n    const copy = Object.create(Object.getPrototypeOf(val));\n    seen.set(val, copy);\n    Object.keys(val).forEach(key => {\n      copy[key] = cloneDeepHelper((val as any)[key], seen);\n    });\n    return copy;\n  }\n\n  default:\n    return val;\n  }\n}\n","const { hasOwnProperty } = Object.prototype;\n\n// These mergeDeep and mergeDeepArray utilities merge any number of objects\n// together, sharing as much memory as possible with the source objects, while\n// remaining careful to avoid modifying any source objects.\n\n// Logically, the return type of mergeDeep should be the intersection of\n// all the argument types. The binary call signature is by far the most\n// common, but we support 0- through 5-ary as well. After that, the\n// resulting type is just the inferred array element type. Note to nerds:\n// there is a more clever way of doing this that converts the tuple type\n// first to a union type (easy enough: T[number]) and then converts the\n// union to an intersection type using distributive conditional type\n// inference, but that approach has several fatal flaws (boolean becomes\n// true & false, and the inferred type ends up as unknown in many cases),\n// in addition to being nearly impossible to explain/understand.\nexport type TupleToIntersection<T extends any[]> =\n  T extends [infer A] ? A :\n  T extends [infer A, infer B] ? A & B :\n  T extends [infer A, infer B, infer C] ? A & B & C :\n  T extends [infer A, infer B, infer C, infer D] ? A & B & C & D :\n  T extends [infer A, infer B, infer C, infer D, infer E] ? A & B & C & D & E :\n  T extends (infer U)[] ? U : any;\n\nexport function mergeDeep<T extends any[]>(\n  ...sources: T\n): TupleToIntersection<T> {\n  return mergeDeepArray(sources);\n}\n\n// In almost any situation where you could succeed in getting the\n// TypeScript compiler to infer a tuple type for the sources array, you\n// could just use mergeDeep instead of mergeDeepArray, so instead of\n// trying to convert T[] to an intersection type we just infer the array\n// element type, which works perfectly when the sources array has a\n// consistent element type.\nexport function mergeDeepArray<T>(sources: T[]): T {\n  let target = sources[0] || {} as T;\n  const count = sources.length;\n  if (count > 1) {\n    const pastCopies: any[] = [];\n    target = shallowCopyForMerge(target, pastCopies);\n    for (let i = 1; i < count; ++i) {\n      target = mergeHelper(target, sources[i], pastCopies);\n    }\n  }\n  return target;\n}\n\nfunction isObject(obj: any): obj is Record<string | number, any> {\n  return obj !== null && typeof obj === 'object';\n}\n\nfunction mergeHelper(\n  target: any,\n  source: any,\n  pastCopies: any[],\n) {\n  if (isObject(source) && isObject(target)) {\n    // In case the target has been frozen, make an extensible copy so that\n    // we can merge properties into the copy.\n    if (Object.isExtensible && !Object.isExtensible(target)) {\n      target = shallowCopyForMerge(target, pastCopies);\n    }\n\n    Object.keys(source).forEach(sourceKey => {\n      const sourceValue = source[sourceKey];\n      if (hasOwnProperty.call(target, sourceKey)) {\n        const targetValue = target[sourceKey];\n        if (sourceValue !== targetValue) {\n          // When there is a key collision, we need to make a shallow copy of\n          // target[sourceKey] so the merge does not modify any source objects.\n          // To avoid making unnecessary copies, we use a simple array to track\n          // past copies, since it's safe to modify copies created earlier in\n          // the merge. We use an array for pastCopies instead of a Map or Set,\n          // since the number of copies should be relatively small, and some\n          // Map/Set polyfills modify their keys.\n          target[sourceKey] = mergeHelper(\n            shallowCopyForMerge(targetValue, pastCopies),\n            sourceValue,\n            pastCopies,\n          );\n        }\n      } else {\n        // If there is no collision, the target can safely share memory with\n        // the source, and the recursion can terminate here.\n        target[sourceKey] = sourceValue;\n      }\n    });\n\n    return target;\n  }\n\n  // If source (or target) is not an object, let source replace target.\n  return source;\n}\n\nfunction shallowCopyForMerge<T>(value: T, pastCopies: any[]): T {\n  if (\n    value !== null &&\n    typeof value === 'object' &&\n    pastCopies.indexOf(value) < 0\n  ) {\n    if (Array.isArray(value)) {\n      value = (value as any).slice(0);\n    } else {\n      value = {\n        __proto__: Object.getPrototypeOf(value),\n        ...value,\n      };\n    }\n    pastCopies.push(value);\n  }\n  return value;\n}\n","import { isProduction, isTest } from './environment';\n\nconst haveWarned = Object.create({});\n\n/**\n * Print a warning only once in development.\n * In production no warnings are printed.\n * In test all warnings are printed.\n *\n * @param msg The warning message\n * @param type warn or error (will call console.warn or console.error)\n */\nexport function warnOnceInDevelopment(msg: string, type = 'warn') {\n  if (!isProduction() && !haveWarned[msg]) {\n    if (!isTest()) {\n      haveWarned[msg] = true;\n    }\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.warn(msg);\n    }\n  }\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nexport default function inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \".concat(value.name, \"]\") : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = [].concat(previouslySeenValues, [value]);\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    // $FlowFixMe(>=0.90.0)\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \".concat(remaining, \" more items\"));\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(object) {\n  var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n  if (typeof customInspectFn === 'function') {\n    return customInspectFn;\n  }\n\n  if (typeof object.inspect === 'function') {\n    return object.inspect;\n  }\n}\n\nfunction getObjectTag(object) {\n  var tag = Object.prototype.toString.call(object).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof object.constructor === 'function') {\n    var name = object.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","var nodejsCustomInspectSymbol = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('nodejs.util.inspect.custom') : undefined;\nexport default nodejsCustomInspectSymbol;\n","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","/**\n * The current status of a query’s execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","import {\n  ExecutionResult,\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: ExecutionResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<ExecutionResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: ExecutionResult) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result as FetchResult<T>;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult as ExecutionResult);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: ExecutionResult) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. You’ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n","export const version = \"2.6.8\"","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","module.exports = require('./lib/Observable.js').Observable;\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// === Symbol Support ===\n\nvar hasSymbols = function () {\n  return typeof Symbol === 'function';\n};\nvar hasSymbol = function (name) {\n  return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function (name) {\n  return hasSymbol(name) ? Symbol[name] : '@@' + name;\n};\n\nif (hasSymbols() && !hasSymbol('observable')) {\n  Symbol.observable = Symbol('observable');\n}\n\nvar SymbolIterator = getSymbol('iterator');\nvar SymbolObservable = getSymbol('observable');\nvar SymbolSpecies = getSymbol('species');\n\n// === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  var value = obj[key];\n\n  if (value == null) return undefined;\n\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  var ctor = obj.constructor;\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(function () {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  var cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      var unsubscribe = getMethod(cleanup, 'unsubscribe');\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  var queue = subscription._queue;\n  if (!queue) {\n    return;\n  }\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n  for (var i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n\n  var observer = subscription._observer;\n\n  try {\n    var m = getMethod(observer, type);\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({ type: type, value: value });\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{ type: type, value: value }];\n    enqueue(function () {\n      return flushSubscription(subscription);\n    });\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nvar Subscription = function () {\n  function Subscription(observer, subscriber) {\n    _classCallCheck(this, Subscription);\n\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n\n    var subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  _createClass(Subscription, [{\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      if (this._state !== 'closed') {\n        closeSubscription(this);\n        cleanupSubscription(this);\n      }\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._state === 'closed';\n    }\n  }]);\n\n  return Subscription;\n}();\n\nvar SubscriptionObserver = function () {\n  function SubscriptionObserver(subscription) {\n    _classCallCheck(this, SubscriptionObserver);\n\n    this._subscription = subscription;\n  }\n\n  _createClass(SubscriptionObserver, [{\n    key: 'next',\n    value: function next(value) {\n      onNotify(this._subscription, 'next', value);\n    }\n  }, {\n    key: 'error',\n    value: function error(value) {\n      onNotify(this._subscription, 'error', value);\n    }\n  }, {\n    key: 'complete',\n    value: function complete() {\n      onNotify(this._subscription, 'complete');\n    }\n  }, {\n    key: 'closed',\n    get: function () {\n      return this._subscription._state === 'closed';\n    }\n  }]);\n\n  return SubscriptionObserver;\n}();\n\nvar Observable = exports.Observable = function () {\n  function Observable(subscriber) {\n    _classCallCheck(this, Observable);\n\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n\n    this._subscriber = subscriber;\n  }\n\n  _createClass(Observable, [{\n    key: 'subscribe',\n    value: function subscribe(observer) {\n      if (typeof observer !== 'object' || observer === null) {\n        observer = {\n          next: observer,\n          error: arguments[1],\n          complete: arguments[2]\n        };\n      }\n      return new Subscription(observer, this._subscriber);\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(fn) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof fn !== 'function') {\n          reject(new TypeError(fn + ' is not a function'));\n          return;\n        }\n\n        function done() {\n          subscription.unsubscribe();\n          resolve();\n        }\n\n        var subscription = _this.subscribe({\n          next: function (value) {\n            try {\n              fn(value, done);\n            } catch (e) {\n              reject(e);\n              subscription.unsubscribe();\n            }\n          },\n\n          error: reject,\n          complete: resolve\n        });\n      });\n    }\n  }, {\n    key: 'map',\n    value: function map(fn) {\n      var _this2 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this2.subscribe({\n          next: function (value) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'filter',\n    value: function filter(fn) {\n      var _this3 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        return _this3.subscribe({\n          next: function (value) {\n            try {\n              if (!fn(value)) return;\n            } catch (e) {\n              return observer.error(e);\n            }\n            observer.next(value);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(fn) {\n      var _this4 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n      var hasSeed = arguments.length > 1;\n      var hasValue = false;\n      var seed = arguments[1];\n      var acc = seed;\n\n      return new C(function (observer) {\n        return _this4.subscribe({\n          next: function (value) {\n            var first = !hasValue;\n            hasValue = true;\n\n            if (!first || hasSeed) {\n              try {\n                acc = fn(acc, value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            } else {\n              acc = value;\n            }\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n\n            observer.next(acc);\n            observer.complete();\n          }\n        });\n      });\n    }\n  }, {\n    key: 'concat',\n    value: function concat() {\n      var _this5 = this;\n\n      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscription = void 0;\n        var index = 0;\n\n        function startNext(next) {\n          subscription = next.subscribe({\n            next: function (v) {\n              observer.next(v);\n            },\n            error: function (e) {\n              observer.error(e);\n            },\n            complete: function () {\n              if (index === sources.length) {\n                subscription = undefined;\n                observer.complete();\n              } else {\n                startNext(C.from(sources[index++]));\n              }\n            }\n          });\n        }\n\n        startNext(_this5);\n\n        return function () {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = undefined;\n          }\n        };\n      });\n    }\n  }, {\n    key: 'flatMap',\n    value: function flatMap(fn) {\n      var _this6 = this;\n\n      if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n\n      var C = getSpecies(this);\n\n      return new C(function (observer) {\n        var subscriptions = [];\n\n        var outer = _this6.subscribe({\n          next: function (value) {\n            if (fn) {\n              try {\n                value = fn(value);\n              } catch (e) {\n                return observer.error(e);\n              }\n            }\n\n            var inner = C.from(value).subscribe({\n              next: function (value) {\n                observer.next(value);\n              },\n              error: function (e) {\n                observer.error(e);\n              },\n              complete: function () {\n                var i = subscriptions.indexOf(inner);\n                if (i >= 0) subscriptions.splice(i, 1);\n                completeIfDone();\n              }\n            });\n\n            subscriptions.push(inner);\n          },\n          error: function (e) {\n            observer.error(e);\n          },\n          complete: function () {\n            completeIfDone();\n          }\n        });\n\n        function completeIfDone() {\n          if (outer.closed && subscriptions.length === 0) observer.complete();\n        }\n\n        return function () {\n          subscriptions.forEach(function (s) {\n            return s.unsubscribe();\n          });\n          outer.unsubscribe();\n        };\n      });\n    }\n  }, {\n    key: SymbolObservable,\n    value: function () {\n      return this;\n    }\n  }], [{\n    key: 'from',\n    value: function from(x) {\n      var C = typeof this === 'function' ? this : Observable;\n\n      if (x == null) throw new TypeError(x + ' is not an object');\n\n      var method = getMethod(x, SymbolObservable);\n      if (method) {\n        var observable = method.call(x);\n\n        if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n\n        if (isObservable(observable) && observable.constructor === C) return observable;\n\n        return new C(function (observer) {\n          return observable.subscribe(observer);\n        });\n      }\n\n      if (hasSymbol('iterator')) {\n        method = getMethod(x, SymbolIterator);\n        if (method) {\n          return new C(function (observer) {\n            enqueue(function () {\n              if (observer.closed) return;\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = method.call(x)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var item = _step.value;\n\n                  observer.next(item);\n                  if (observer.closed) return;\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              observer.complete();\n            });\n          });\n        }\n      }\n\n      if (Array.isArray(x)) {\n        return new C(function (observer) {\n          enqueue(function () {\n            if (observer.closed) return;\n            for (var i = 0; i < x.length; ++i) {\n              observer.next(x[i]);\n              if (observer.closed) return;\n            }\n            observer.complete();\n          });\n        });\n      }\n\n      throw new TypeError(x + ' is not observable');\n    }\n  }, {\n    key: 'of',\n    value: function of() {\n      for (var _len2 = arguments.length, items = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n\n      var C = typeof this === 'function' ? this : Observable;\n\n      return new C(function (observer) {\n        enqueue(function () {\n          if (observer.closed) return;\n          for (var i = 0; i < items.length; ++i) {\n            observer.next(items[i]);\n            if (observer.closed) return;\n          }\n          observer.complete();\n        });\n      });\n    }\n  }, {\n    key: SymbolSpecies,\n    get: function () {\n      return this;\n    }\n  }]);\n\n  return Observable;\n}();\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol('extensions'), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError: hostReportError\n    },\n    configurable: true\n  });\n}","import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\n\nexport interface IdValue {\n  type: 'id';\n  id: string;\n  generated: boolean;\n  typename: string | undefined;\n}\n\nexport interface JsonValue {\n  type: 'json';\n  json: any;\n}\n\nexport type ListValue = Array<null | IdValue>;\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | IdValue\n  | ListValue\n  | JsonValue\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport type ScalarValue = StringValueNode | BooleanValueNode | EnumValueNode;\n\nexport function isScalarValue(value: ValueNode): value is ScalarValue {\n  return ['StringValue', 'BooleanValue', 'EnumValue'].indexOf(value.kind) > -1;\n}\n\nexport type NumberValue = IntValueNode | FloatValueNode;\n\nexport function isNumberValue(value: ValueNode): value is NumberValue {\n  return ['IntValue', 'FloatValue'].indexOf(value.kind) > -1;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Object,\n  directives?: Directives,\n): string {\n  if (\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const queryArgs = args as { [key: string]: any };\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = queryArgs[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables: Object,\n): Object {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport function isIdValue(idObject: StoreValue): idObject is IdValue {\n  return idObject &&\n    (idObject as IdValue | JsonValue).type === 'id' &&\n    typeof (idObject as IdValue).generated === 'boolean';\n}\n\nexport type IdConfig = {\n  id: string;\n  typename: string | undefined;\n};\n\nexport function toIdValue(\n  idConfig: string | IdConfig,\n  generated = false,\n): IdValue {\n  return {\n    type: 'id',\n    generated,\n    ...(typeof idConfig === 'string'\n      ? { id: idConfig, typename: undefined }\n      : idConfig),\n  };\n}\n\nexport function isJsonValue(jsonObject: StoreValue): jsonObject is JsonValue {\n  return (\n    jsonObject != null &&\n    typeof jsonObject === 'object' &&\n    (jsonObject as IdValue | JsonValue).type === 'json'\n  );\n}\n\nfunction defaultValueFromVariable(node: VariableNode) {\n  throw new InvariantError(`Variable nodes are not supported by valueFromNode`);\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n\n/**\n * Evaluate a ValueNode and yield its value in its natural JS form.\n */\nexport function valueFromNode(\n  node: ValueNode,\n  onVariable: VariableValue = defaultValueFromVariable,\n): any {\n  switch (node.kind) {\n    case 'Variable':\n      return onVariable(node);\n    case 'NullValue':\n      return null;\n    case 'IntValue':\n      return parseInt(node.value, 10);\n    case 'FloatValue':\n      return parseFloat(node.value);\n    case 'ListValue':\n      return node.values.map(v => valueFromNode(v, onVariable));\n    case 'ObjectValue': {\n      const value: { [key: string]: any } = {};\n      for (const field of node.fields) {\n        value[field.name.value] = valueFromNode(field.value, onVariable);\n      }\n      return value;\n    }\n    default:\n      return node.value;\n  }\n}\n","// Provides the methods that allow QueryManager to handle the `skip` and\n// `include` directives within GraphQL.\nimport {\n  FieldNode,\n  SelectionNode,\n  VariableNode,\n  BooleanValueNode,\n  DirectiveNode,\n  DocumentNode,\n  ArgumentNode,\n  ValueNode,\n} from 'graphql';\n\nimport { visit } from 'graphql/language/visitor';\n\nimport { invariant } from 'ts-invariant';\n\nimport { argumentsObjectFromField } from './storeUtils';\n\nexport type DirectiveInfo = {\n  [fieldName: string]: { [argName: string]: any };\n};\n\nexport function getDirectiveInfoFromField(\n  field: FieldNode,\n  variables: Object,\n): DirectiveInfo {\n  if (field.directives && field.directives.length) {\n    const directiveObj: DirectiveInfo = {};\n    field.directives.forEach((directive: DirectiveNode) => {\n      directiveObj[directive.name.value] = argumentsObjectFromField(\n        directive,\n        variables,\n      );\n    });\n    return directiveObj;\n  }\n  return null;\n}\n\nexport function shouldInclude(\n  selection: SelectionNode,\n  variables: { [name: string]: any } = {},\n): boolean {\n  return getInclusionDirectives(\n    selection.directives,\n  ).every(({ directive, ifArgument }) => {\n    let evaledValue: boolean = false;\n    if (ifArgument.value.kind === 'Variable') {\n      evaledValue = variables[(ifArgument.value as VariableNode).name.value];\n      invariant(\n        evaledValue !== void 0,\n        `Invalid variable referenced in @${directive.name.value} directive.`,\n      );\n    } else {\n      evaledValue = (ifArgument.value as BooleanValueNode).value;\n    }\n    return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n  });\n}\n\nexport function getDirectiveNames(doc: DocumentNode) {\n  const names: string[] = [];\n\n  visit(doc, {\n    Directive(node) {\n      names.push(node.name.value);\n    },\n  });\n\n  return names;\n}\n\nexport function hasDirectives(names: string[], doc: DocumentNode) {\n  return getDirectiveNames(doc).some(\n    (name: string) => names.indexOf(name) > -1,\n  );\n}\n\nexport function hasClientExports(document: DocumentNode) {\n  return (\n    document &&\n    hasDirectives(['client'], document) &&\n    hasDirectives(['export'], document)\n  );\n}\n\nexport type InclusionDirectives = Array<{\n  directive: DirectiveNode;\n  ifArgument: ArgumentNode;\n}>;\n\nfunction isInclusionDirective({ name: { value } }: DirectiveNode): boolean {\n  return value === 'skip' || value === 'include';\n}\n\nexport function getInclusionDirectives(\n  directives: ReadonlyArray<DirectiveNode>,\n): InclusionDirectives {\n  return directives ? directives.filter(isInclusionDirective).map(directive => {\n    const directiveArguments = directive.arguments;\n    const directiveName = directive.name.value;\n\n    invariant(\n      directiveArguments && directiveArguments.length === 1,\n      `Incorrect number of arguments for the @${directiveName} directive.`,\n    );\n\n    const ifArgument = directiveArguments[0];\n    invariant(\n      ifArgument.name && ifArgument.name.value === 'if',\n      `Invalid argument for the @${directiveName} directive.`,\n    );\n\n    const ifValue: ValueNode = ifArgument.value;\n\n    // means it has to be a variable value if this is a valid @skip or @include directive\n    invariant(\n      ifValue &&\n        (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'),\n      `Argument for the @${directiveName} directive must be a variable or a boolean value.`,\n    );\n\n    return { directive, ifArgument };\n  }) : [];\n}\n\n","/**\n * Adds the properties of one or more source objects to a target object. Works exactly like\n * `Object.assign`, but as a utility to maintain support for IE 11.\n *\n * @see https://github.com/apollostack/apollo-client/pull/1009\n */\nexport function assign<A, B>(a: A, b: B): A & B;\nexport function assign<A, B, C>(a: A, b: B, c: C): A & B & C;\nexport function assign<A, B, C, D>(a: A, b: B, c: C, d: D): A & B & C & D;\nexport function assign<A, B, C, D, E>(\n  a: A,\n  b: B,\n  c: C,\n  d: D,\n  e: E,\n): A & B & C & D & E;\nexport function assign(target: any, ...sources: Array<any>): any;\nexport function assign(\n  target: { [key: string]: any },\n  ...sources: Array<{ [key: string]: any }>\n): { [key: string]: any } {\n  sources.forEach(source => {\n    if (typeof source === 'undefined' || source === null) {\n      return;\n    }\n    Object.keys(source).forEach(key => {\n      target[key] = source[key];\n    });\n  });\n  return target;\n}\n","export function filterInPlace<T>(\n  array: T[],\n  test: (elem: T) => boolean,\n  context?: any,\n): T[] {\n  let target = 0;\n  array.forEach(function (elem, i) {\n    if (test.call(this, elem, i, array)) {\n      array[target++] = elem;\n    }\n  }, context);\n  array.length = target;\n  return array;\n}\n","import {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from 'graphql';\nimport { visit } from 'graphql/language/visitor';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  createFragmentMap,\n  FragmentMap,\n  getMainDefinition,\n} from './getFromAST';\nimport { filterInPlace } from './util/filterInPlace';\nimport { invariant } from 'ts-invariant';\nimport { isField, isInlineFragment } from './storeUtils';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: 'Field',\n  name: {\n    kind: 'Name',\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragments: FragmentMap,\n): boolean {\n  return op.selectionSet.selections.every(\n    selection =>\n      selection.kind === 'FragmentSpread' &&\n      isEmpty(fragments[selection.name.value], fragments),\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  return function directiveMatcher(directive: DirectiveNode) {\n    return directives.some(\n      dir =>\n        (dir.name && dir.name === directive.name.value) ||\n        (dir.test && dir.test(directive)),\n    );\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const variablesInUse: Record<string, boolean> = Object.create(null);\n  let variablesToRemove: RemoveArgumentsConfig[] = [];\n\n  const fragmentSpreadsInUse: Record<string, boolean> = Object.create(null);\n  let fragmentSpreadsToRemove: RemoveFragmentSpreadConfig[] = [];\n\n  let modifiedDoc = nullIfDocIsEmpty(\n    visit(doc, {\n      Variable: {\n        enter(node, _key, parent) {\n          // Store each variable that's referenced as part of an argument\n          // (excluding operation definition variables), so we know which\n          // variables are being used. If we later want to remove a variable\n          // we'll fist check to see if it's being used, before continuing with\n          // the removal.\n          if (\n            (parent as VariableDefinitionNode).kind !== 'VariableDefinition'\n          ) {\n            variablesInUse[node.name.value] = true;\n          }\n        },\n      },\n\n      Field: {\n        enter(node) {\n          if (directives && node.directives) {\n            // If `remove` is set to true for a directive, and a directive match\n            // is found for a field, remove the field as well.\n            const shouldRemoveField = directives.some(\n              directive => directive.remove,\n            );\n\n            if (\n              shouldRemoveField &&\n              node.directives &&\n              node.directives.some(getDirectiveMatcher(directives))\n            ) {\n              if (node.arguments) {\n                // Store field argument variables so they can be removed\n                // from the operation definition.\n                node.arguments.forEach(arg => {\n                  if (arg.value.kind === 'Variable') {\n                    variablesToRemove.push({\n                      name: (arg.value as VariableNode).name.value,\n                    });\n                  }\n                });\n              }\n\n              if (node.selectionSet) {\n                // Store fragment spread names so they can be removed from the\n                // docuemnt.\n                getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(\n                  frag => {\n                    fragmentSpreadsToRemove.push({\n                      name: frag.name.value,\n                    });\n                  },\n                );\n              }\n\n              // Remove the field.\n              return null;\n            }\n          }\n        },\n      },\n\n      FragmentSpread: {\n        enter(node) {\n          // Keep track of referenced fragment spreads. This is used to\n          // determine if top level fragment definitions should be removed.\n          fragmentSpreadsInUse[node.name.value] = true;\n        },\n      },\n\n      Directive: {\n        enter(node) {\n          // If a matching directive is found, remove it.\n          if (getDirectiveMatcher(directives)(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n\n  // If we've removed fields with arguments, make sure the associated\n  // variables are also removed from the rest of the document, as long as they\n  // aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(variablesToRemove, v => !variablesInUse[v.name]).length\n  ) {\n    modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n  }\n\n  // If we've removed selection sets with fragment spreads, make sure the\n  // associated fragment definitions are also removed from the rest of the\n  // document, as long as they aren't being used elsewhere.\n  if (\n    modifiedDoc &&\n    filterInPlace(fragmentSpreadsToRemove, fs => !fragmentSpreadsInUse[fs.name])\n      .length\n  ) {\n    modifiedDoc = removeFragmentSpreadFromDocument(\n      fragmentSpreadsToRemove,\n      modifiedDoc,\n    );\n  }\n\n  return modifiedDoc;\n}\n\nexport function addTypenameToDocument(doc: DocumentNode): DocumentNode {\n  return visit(checkDocument(doc), {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === 'OperationDefinition'\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode,\n  nestedCheck = true,\n): boolean {\n  return (\n    selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nexport function getDirectivesFromDocument(\n  directives: GetDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  checkDocument(doc);\n\n  let parentPath: string;\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      SelectionSet: {\n        enter(node, _key, _parent, path) {\n          const currentPath = path.join('-');\n\n          if (\n            !parentPath ||\n            currentPath === parentPath ||\n            !currentPath.startsWith(parentPath)\n          ) {\n            if (node.selections) {\n              const selectionsWithDirectives = node.selections.filter(\n                selection => hasDirectivesInSelection(directives, selection),\n              );\n\n              if (hasDirectivesInSelectionSet(directives, node, false)) {\n                parentPath = currentPath;\n              }\n\n              return {\n                ...node,\n                selections: selectionsWithDirectives,\n              };\n            } else {\n              return null;\n            }\n          }\n        },\n      },\n    }),\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === 'Variable' &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ),\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            node.arguments.forEach(arg => {\n              if (argMatcher(arg)) {\n                argMatchCount += 1;\n              }\n            });\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\nfunction getAllFragmentSpreadsFromSelectionSet(\n  selectionSet: SelectionSetNode,\n): FragmentSpreadNode[] {\n  const allFragments: FragmentSpreadNode[] = [];\n\n  selectionSet.selections.forEach(selection => {\n    if (\n      (isField(selection) || isInlineFragment(selection)) &&\n      selection.selectionSet\n    ) {\n      getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(\n        frag => allFragments.push(frag),\n      );\n    } else if (selection.kind === 'FragmentSpread') {\n      allFragments.push(selection);\n    }\n  });\n\n  return allFragments;\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  // After a fragment definition has had its @client related document\n  // sets removed, if the only field it has left is a __typename field,\n  // remove the entire fragment operation to prevent it from being fired\n  // on the server.\n  if (modifiedDoc) {\n    modifiedDoc = visit(modifiedDoc, {\n      FragmentDefinition: {\n        enter(node) {\n          if (node.selectionSet) {\n            const isTypenameOnly = node.selectionSet.selections.every(\n              selection =>\n                isField(selection) && selection.name.value === '__typename',\n            );\n            if (isTypenameOnly) {\n              return null;\n            }\n          }\n        },\n      },\n    });\n  }\n\n  return modifiedDoc;\n}\n","import { ExecutionResult } from 'graphql';\n\nexport function tryFunctionOrLogError(f: Function) {\n  try {\n    return f();\n  } catch (e) {\n    if (console.error) {\n      console.error(e);\n    }\n  }\n}\n\nexport function graphQLResultHasError(result: ExecutionResult) {\n  return result.errors && result.errors.length;\n}\n","import { Operation } from 'apollo-link';\nimport { print } from 'graphql/language/printer';\nimport { InvariantError } from 'ts-invariant';\n\n/*\n * Http Utilities: shared across links that make http requests\n */\n\n// XXX replace with actual typings when available\ndeclare var AbortController: any;\n\n//Used for any Error for data from the server\n//on a request with a Status >= 300\n//response contains no data or errors\nexport type ServerError = Error & {\n  response: Response;\n  result: Record<string, any>;\n  statusCode: number;\n};\n\n//Thrown when server's resonse is cannot be parsed\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport type ClientParseError = InvariantError & {\n  parseError: Error;\n};\n\nexport interface HttpQueryOptions {\n  includeQuery?: boolean;\n  includeExtensions?: boolean;\n}\n\nexport interface HttpConfig {\n  http?: HttpQueryOptions;\n  options?: any;\n  headers?: any; //overrides headers in options\n  credentials?: any;\n}\n\nexport interface UriFunction {\n  (operation: Operation): string;\n}\n\n// The body of a GraphQL-over-HTTP-POST request.\nexport interface Body {\n  query?: string;\n  operationName?: string;\n  variables?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface HttpOptions {\n  /**\n   * The URI to use when fetching operations.\n   *\n   * Defaults to '/graphql'.\n   */\n  uri?: string | UriFunction;\n\n  /**\n   * Passes the extensions field to your graphql server.\n   *\n   * Defaults to false.\n   */\n  includeExtensions?: boolean;\n\n  /**\n   * A `fetch`-compatible API to use when making requests.\n   */\n  fetch?: WindowOrWorkerGlobalScope['fetch'];\n\n  /**\n   * An object representing values to be sent as headers on the request.\n   */\n  headers?: any;\n\n  /**\n   * The credentials policy you want to use for the fetch call.\n   */\n  credentials?: string;\n\n  /**\n   * Any overrides of the fetch options argument to pass to the fetch call.\n   */\n  fetchOptions?: any;\n}\n\nconst defaultHttpOptions: HttpQueryOptions = {\n  includeQuery: true,\n  includeExtensions: false,\n};\n\nconst defaultHeaders = {\n  // headers are case insensitive (https://stackoverflow.com/a/5259004)\n  accept: '*/*',\n  'content-type': 'application/json',\n};\n\nconst defaultOptions = {\n  method: 'POST',\n};\n\nexport const fallbackHttpConfig = {\n  http: defaultHttpOptions,\n  headers: defaultHeaders,\n  options: defaultOptions,\n};\n\nexport const throwServerError = (response, result, message) => {\n  const error = new Error(message) as ServerError;\n\n  error.name = 'ServerError';\n  error.response = response;\n  error.statusCode = response.status;\n  error.result = result;\n\n  throw error;\n};\n\n//TODO: when conditional types come in ts 2.8, operations should be a generic type that extends Operation | Array<Operation>\nexport const parseAndCheckHttpResponse = operations => (response: Response) => {\n  return (\n    response\n      .text()\n      .then(bodyText => {\n        try {\n          return JSON.parse(bodyText);\n        } catch (err) {\n          const parseError = err as ServerParseError;\n          parseError.name = 'ServerParseError';\n          parseError.response = response;\n          parseError.statusCode = response.status;\n          parseError.bodyText = bodyText;\n          return Promise.reject(parseError);\n        }\n      })\n      //TODO: when conditional types come out then result should be T extends Array ? Array<FetchResult> : FetchResult\n      .then((result: any) => {\n        if (response.status >= 300) {\n          //Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`,\n          );\n        }\n        //TODO should really error per response in a Batch based on properties\n        //    - could be done in a validation link\n        if (\n          !Array.isArray(result) &&\n          !result.hasOwnProperty('data') &&\n          !result.hasOwnProperty('errors')\n        ) {\n          //Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map(op => op.operationName)\n                : operations.operationName\n            }'.`,\n          );\n        }\n        return result;\n      })\n  );\n};\n\nexport const checkFetcher = (fetcher: WindowOrWorkerGlobalScope['fetch']) => {\n  if (!fetcher && typeof fetch === 'undefined') {\n    let library: string = 'unfetch';\n    if (typeof window === 'undefined') library = 'node-fetch';\n    throw new InvariantError(`\nfetch is not found globally and no fetcher passed, to fix pass a fetch for\nyour environment like https://www.npmjs.com/package/${library}.\n\nFor example:\nimport fetch from '${library}';\nimport { createHttpLink } from 'apollo-link-http';\n\nconst link = createHttpLink({ uri: '/graphql', fetch: fetch });`);\n  }\n};\n\nexport const createSignalIfSupported = () => {\n  if (typeof AbortController === 'undefined')\n    return { controller: false, signal: false };\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n  return { controller, signal };\n};\n\nexport const selectHttpOptionsAndBody = (\n  operation: Operation,\n  fallbackConfig: HttpConfig,\n  ...configs: Array<HttpConfig>\n) => {\n  let options: HttpConfig & Record<string, any> = {\n    ...fallbackConfig.options,\n    headers: fallbackConfig.headers,\n    credentials: fallbackConfig.credentials,\n  };\n  let http: HttpQueryOptions = fallbackConfig.http;\n\n  /*\n   * use the rest of the configs to populate the options\n   * configs later in the list will overwrite earlier fields\n   */\n  configs.forEach(config => {\n    options = {\n      ...options,\n      ...config.options,\n      headers: {\n        ...options.headers,\n        ...config.headers,\n      },\n    };\n    if (config.credentials) options.credentials = config.credentials;\n\n    http = {\n      ...http,\n      ...config.http,\n    };\n  });\n\n  //The body depends on the http options\n  const { operationName, extensions, variables, query } = operation;\n  const body: Body = { operationName, variables };\n\n  if (http.includeExtensions) (body as any).extensions = extensions;\n\n  // not sending the query (i.e persisted queries)\n  if (http.includeQuery) (body as any).query = print(query);\n\n  return {\n    options,\n    body,\n  };\n};\n\nexport const serializeFetchParameter = (p, label) => {\n  let serialized;\n  try {\n    serialized = JSON.stringify(p);\n  } catch (e) {\n    const parseError = new InvariantError(\n      `Network request failed. ${label} is not serializable: ${e.message}`,\n    ) as ClientParseError;\n    parseError.parseError = e;\n    throw parseError;\n  }\n  return serialized;\n};\n\n//selects \"/graphql\" by default\nexport const selectURI = (\n  operation,\n  fallbackURI?: string | ((operation: Operation) => string),\n) => {\n  const context = operation.getContext();\n  const contextURI = context.uri;\n\n  if (contextURI) {\n    return contextURI;\n  } else if (typeof fallbackURI === 'function') {\n    return fallbackURI(operation);\n  } else {\n    return (fallbackURI as string) || '/graphql';\n  }\n};\n","export function getEnv(): string | undefined {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV) {\n    return process.env.NODE_ENV;\n  }\n\n  // default environment\n  return 'development';\n}\n\nexport function isEnv(env: string): boolean {\n  return getEnv() === env;\n}\n\nexport function isProduction(): boolean {\n  return isEnv('production') === true;\n}\n\nexport function isDevelopment(): boolean {\n  return isEnv('development') === true;\n}\n\nexport function isTest(): boolean {\n  return isEnv('test') === true;\n}\n","import { isDevelopment, isTest } from './environment';\n\n// Taken (mostly) from https://github.com/substack/deep-freeze to avoid\n// import hassles with rollup.\nfunction deepFreeze(o: any) {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n\nexport function maybeDeepFreeze(obj: any) {\n  if (isDevelopment() || isTest()) {\n    // Polyfilled Symbols potentially cause infinite / very deep recursion while deep freezing\n    // which is known to crash IE11 (https://github.com/apollographql/apollo-client/issues/3043).\n    const symbolIsPolyfilled =\n      typeof Symbol === 'function' && typeof Symbol('') === 'string';\n\n    if (!symbolIsPolyfilled) {\n      return deepFreeze(obj);\n    }\n  }\n  return obj;\n}\n","import { DocumentNode, FragmentDefinitionNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\n/**\n * Returns a query document which adds a single query operation that only\n * spreads the target fragment inside of it.\n *\n * So for example a document of:\n *\n * ```graphql\n * fragment foo on Foo { a b c }\n * ```\n *\n * Turns into:\n *\n * ```graphql\n * { ...foo }\n *\n * fragment foo on Foo { a b c }\n * ```\n *\n * The target fragment will either be the only fragment in the document, or a\n * fragment specified by the provided `fragmentName`. If there is more than one\n * fragment, but a `fragmentName` was not defined then an error will be thrown.\n */\nexport function getFragmentQueryDocument(\n  document: DocumentNode,\n  fragmentName?: string,\n): DocumentNode {\n  let actualFragmentName = fragmentName;\n\n  // Build an array of all our fragment definitions that will be used for\n  // validations. We also do some validations on the other definitions in the\n  // document while building this list.\n  const fragments: Array<FragmentDefinitionNode> = [];\n  document.definitions.forEach(definition => {\n    // Throw an error if we encounter an operation definition because we will\n    // define our own operation definition later on.\n    if (definition.kind === 'OperationDefinition') {\n      throw new InvariantError(\n        `Found a ${definition.operation} operation${\n          definition.name ? ` named '${definition.name.value}'` : ''\n        }. ` +\n          'No operations are allowed when using a fragment as a query. Only fragments are allowed.',\n      );\n    }\n    // Add our definition to the fragments array if it is a fragment\n    // definition.\n    if (definition.kind === 'FragmentDefinition') {\n      fragments.push(definition);\n    }\n  });\n\n  // If the user did not give us a fragment name then let us try to get a\n  // name from a single fragment in the definition.\n  if (typeof actualFragmentName === 'undefined') {\n    invariant(\n      fragments.length === 1,\n      `Found ${\n        fragments.length\n      } fragments. \\`fragmentName\\` must be provided when there is not exactly 1 fragment.`,\n    );\n    actualFragmentName = fragments[0].name.value;\n  }\n\n  // Generate a query document with an operation that simply spreads the\n  // fragment inside of it.\n  const query: DocumentNode = {\n    ...document,\n    definitions: [\n      {\n        kind: 'OperationDefinition',\n        operation: 'query',\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: [\n            {\n              kind: 'FragmentSpread',\n              name: {\n                kind: 'Name',\n                value: actualFragmentName,\n              },\n            },\n          ],\n        },\n      },\n      ...document.definitions,\n    ],\n  };\n\n  return query;\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export default function devAssert(condition, message) {\n  var booleanCondition = Boolean(condition);\n\n  if (!booleanCondition) {\n    throw new Error(message);\n  }\n}\n","import nodejsCustomInspectSymbol from './nodejsCustomInspectSymbol';\n/**\n * The `defineToJSON()` function defines toJSON() and inspect() prototype\n * methods, if no function provided they become aliases for toString().\n */\n\nexport default function defineToJSON(classObject) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n","function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Return true if `value` is object-like. A value is object-like if it's not\n * `null` and has a `typeof` result of \"object\".\n */\nexport default function isObjectLike(value) {\n  return _typeof(value) == 'object' && value !== null;\n}\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from '../language/location';\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return ['', subline];\n    }), [[' ', whitespace(sublineColumnNum - 1) + '^'], ['', sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return lpad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction lpad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","import isObjectLike from '../jsutils/isObjectLike';\nimport { getLocation } from '../language/location';\nimport { printLocation, printSourceLocation } from '../language/printLocation';\n/**\n * A GraphQLError describes an Error found during the parse, validate, or\n * execute phases of performing a GraphQL operation. In addition to a message\n * and stack trace, it also includes information about the locations in a\n * GraphQL document and/or execution result that correspond to the Error.\n */\n\nexport function GraphQLError( // eslint-disable-line no-redeclare\nmessage, nodes, source, positions, path, originalError, extensions) {\n  // Compute list of blame nodes.\n  var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : undefined : nodes ? [nodes] : undefined; // Compute locations in the source for the given nodes/positions.\n\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && _positions.length === 0) {\n    _positions = undefined;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (_extensions == null && originalError != null) {\n    var originalExtensions = originalError.extensions;\n\n    if (isObjectLike(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      // By being enumerable, JSON.stringify will include `message` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: true,\n      writable: true\n    },\n    locations: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _locations || undefined,\n      // By being enumerable, JSON.stringify will include `locations` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: path || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || undefined\n    },\n    source: {\n      value: _source || undefined\n    },\n    positions: {\n      value: _positions || undefined\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      // Coercing falsey values to undefined ensures they will not be included\n      // in JSON.stringify() when not provided.\n      value: _extensions || undefined,\n      // By being enumerable, JSON.stringify will include `path` in the\n      // resulting output. This ensures that the simplest possible GraphQL\n      // service adheres to the spec.\n      enumerable: Boolean(_extensions)\n    }\n  }); // Include (non-enumerable) stack trace.\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, 'stack', {\n      value: originalError.stack,\n      writable: true,\n      configurable: true\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, 'stack', {\n      value: Error().stack,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: 'GraphQLError'\n  },\n  toString: {\n    value: function toString() {\n      return printError(this);\n    }\n  }\n});\n/**\n * Prints a GraphQLError to a string, representing useful location information\n * about the error's position in the source.\n */\n\nexport function printError(error) {\n  var output = error.message;\n\n  if (error.nodes) {\n    for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n      var node = _error$nodes2[_i2];\n\n      if (node.loc) {\n        output += '\\n\\n' + printLocation(node.loc);\n      }\n    }\n  } else if (error.source && error.locations) {\n    for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n      var location = _error$locations2[_i4];\n      output += '\\n\\n' + printSourceLocation(error.source, location);\n    }\n  }\n\n  return output;\n}\n","import { GraphQLError } from './GraphQLError';\n/**\n * Produces a GraphQLError representing a syntax error, containing useful\n * descriptive information about the syntax error's position in the source.\n */\n\nexport function syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), undefined, source, [position]);\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","import devAssert from '../jsutils/devAssert';\nimport defineToStringTag from '../jsutils/defineToStringTag';\n\n/**\n * A representation of source input to GraphQL.\n * `name` and `locationOffset` are optional. They are useful for clients who\n * store GraphQL documents in source files; for example, if the GraphQL input\n * starts at line 40 in a file named Foo.graphql, it might be useful for name to\n * be \"Foo.graphql\" and location to be `{ line: 40, column: 0 }`.\n * line and column in locationOffset are 1-indexed\n */\nexport var Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || 'GraphQL request';\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive');\n  this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive');\n}; // Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\n\ndefineToStringTag(Source);\n","/**\n * The `defineToStringTag()` function checks first to see if the runtime\n * supports the `Symbol` class and then if the `Symbol.toStringTag` constant\n * is defined as a `Symbol` instance. If both conditions are met, the\n * Symbol.toStringTag property is defined as a getter that returns the\n * supplied class constructor's name.\n *\n * @method defineToStringTag\n *\n * @param {Class<any>} classObject a class such as Object, String, Number but\n * typically one of your own creation through the class keyword; `class A {}`,\n * for example.\n */\nexport default function defineToStringTag(classObject) {\n  if (typeof Symbol === 'function' && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n","import defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { dedentBlockStringValue } from './blockString';\nimport { TokenKind } from './tokenKind';\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport function createLexer(source, options) {\n  var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n  var lexer = {\n    source: source,\n    options: options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer,\n    lookahead: lookahead\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  var token = this.token = this.lookahead();\n  return token;\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      // Note: next is only mutable during parsing, so we cast to allow this.\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n/**\n * The return type of createLexer.\n */\n\n\n// @internal\nexport function isPunctuatorToken(token) {\n  var kind = token.kind;\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n/**\n * Helper function for constructing the Token object.\n */\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = positionAfterWhitespace(body, prev.end, lexer);\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos); // SourceCharacter\n\n  switch (code) {\n    // !\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n    // #\n\n    case 35:\n      return readComment(source, pos, line, col, prev);\n    // $\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n    // &\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n    // (\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n    // )\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n    // .\n\n    case 46:\n      if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n    // :\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n    // =\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n    // @\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n    // [\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n    // ]\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n    // {\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n    // |\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n    // }\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n    // A-Z _ a-z\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return readName(source, pos, line, col, prev);\n    // - 0-9\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return readNumber(source, pos, code, line, col, prev);\n    // \"\n\n    case 34:\n      if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n        return readBlockString(source, pos, line, col, prev, lexer);\n      }\n\n      return readString(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */\n\n\nfunction positionAfterWhitespace(body, startPosition, lexer) {\n  var bodyLength = body.length;\n  var position = startPosition;\n\n  while (position < bodyLength) {\n    var code = body.charCodeAt(position); // tab | space | comma | BOM\n\n    if (code === 9 || code === 32 || code === 44 || code === 0xfeff) {\n      ++position;\n    } else if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n\n  return position;\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or e\n\n\n  if (code === 46 || code === 69 || code === 101) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n}\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","import inspect from '../jsutils/inspect';\nimport devAssert from '../jsutils/devAssert';\nimport defineToJSON from '../jsutils/defineToJSON';\nimport { syntaxError } from '../error/syntaxError';\nimport { Kind } from './kinds';\nimport { Source } from './source';\nimport { createLexer } from './lexer';\nimport { DirectiveLocation } from './directiveLocation';\nimport { TokenKind } from './tokenKind';\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\nvar Parser =\n/*#__PURE__*/\nfunction () {\n  function Parser(source, options) {\n    var sourceObj = typeof source === 'string' ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(inspect(sourceObj)));\n    this._lexer = createLexer(sourceObj);\n    this._options = options || {};\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        if (token.value === 'true' || token.value === 'false') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.BOOLEAN,\n            value: token.value === 'true',\n            loc: this.loc(token)\n          };\n        } else if (token.value === 'null') {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword('implements')) {\n      // Optional leading ampersand\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || // Legacy support for the SDL?\n      this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    // Legacy support for the SDL?\n    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      // Optional leading pipe\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    // Optional leading pipe\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token)));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n} // Print a simplified form when appearing in JSON/util.inspect.\n\n\ndefineToJSON(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n/**\n * A helper function to describe a token as a string for debugging\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, \" \\\"\").concat(value, \"\\\"\") : token.kind;\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n  FragmentDefinitionNode,\n} from 'graphql';\n\nexport function queryFromPojo(obj: any): DocumentNode {\n  const op: OperationDefinitionNode = {\n    kind: 'OperationDefinition',\n    operation: 'query',\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [op],\n  };\n\n  return out;\n}\n\nexport function fragmentFromPojo(obj: any, typename?: string): DocumentNode {\n  const frag: FragmentDefinitionNode = {\n    kind: 'FragmentDefinition',\n    typeCondition: {\n      kind: 'NamedType',\n      name: {\n        kind: 'Name',\n        value: typename || '__FakeType',\n      },\n    },\n    name: {\n      kind: 'Name',\n      value: 'GeneratedClientQuery',\n    },\n    selectionSet: selectionSetFromObj(obj),\n  };\n\n  const out: DocumentNode = {\n    kind: 'Document',\n    definitions: [frag],\n  };\n\n  return out;\n}\n\nfunction selectionSetFromObj(obj: any): SelectionSetNode {\n  if (\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    typeof obj === 'string' ||\n    typeof obj === 'undefined' ||\n    obj === null\n  ) {\n    // No selection set here\n    return null;\n  }\n\n  if (Array.isArray(obj)) {\n    // GraphQL queries don't include arrays\n    return selectionSetFromObj(obj[0]);\n  }\n\n  // Now we know it's an object\n  const selections: FieldNode[] = [];\n\n  Object.keys(obj).forEach(key => {\n    const nestedSelSet: SelectionSetNode = selectionSetFromObj(obj[key]);\n\n    const field: FieldNode = {\n      kind: 'Field',\n      name: {\n        kind: 'Name',\n        value: key,\n      },\n      selectionSet: nestedSelSet || undefined,\n    };\n\n    selections.push(field);\n  });\n\n  const selectionSet: SelectionSetNode = {\n    kind: 'SelectionSet',\n    selections,\n  };\n\n  return selectionSet;\n}\n\nexport const justTypenameQuery: DocumentNode = {\n  kind: 'Document',\n  definitions: [\n    {\n      kind: 'OperationDefinition',\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: {\n        kind: 'SelectionSet',\n        selections: [\n          {\n            kind: 'Field',\n            alias: null,\n            name: {\n              kind: 'Name',\n              value: '__typename',\n            },\n            arguments: [],\n            directives: [],\n            selectionSet: null,\n          },\n        ],\n      },\n    },\n  ],\n};\n","import { DataProxy } from './DataProxy';\n\nexport namespace Cache {\n  export type WatchCallback = (newData: any) => void;\n  export interface EvictionResult {\n    success: Boolean;\n  }\n\n  export interface ReadOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n    previousResult?: any;\n    optimistic: boolean;\n  }\n\n  export interface WriteOptions<TResult = any, TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    dataId: string;\n    result: TResult;\n  }\n\n  export interface DiffOptions extends ReadOptions {\n    returnPartialData?: boolean;\n  }\n\n  export interface WatchOptions extends ReadOptions {\n    callback: WatchCallback;\n  }\n\n  export interface EvictOptions<TVariables = any>\n    extends DataProxy.Query<TVariables> {\n    rootId?: string;\n  }\n\n  export import DiffResult = DataProxy.DiffResult;\n  export import WriteQueryOptions = DataProxy.WriteQueryOptions;\n  export import WriteFragmentOptions = DataProxy.WriteFragmentOptions;\n  export import WriteDataOptions = DataProxy.WriteDataOptions;\n  export import Fragment = DataProxy.Fragment;\n}\n","interface Node<K, V> {\n  key: K;\n  value: V;\n  newer: Node<K, V> | null;\n  older: Node<K, V> | null;\n}\n\nfunction defaultDispose() {}\n\nexport class Cache<K = any, V = any> {\n  private map = new Map<K, Node<K, V>>();\n  private newest: Node<K, V> | null = null;\n  private oldest: Node<K, V> | null = null;\n\n  constructor(\n    private max = Infinity,\n    public dispose: (value: V, key: K) => void = defaultDispose,\n  ) {}\n\n  public has(key: K) {\n    return this.map.has(key);\n  }\n\n  public get(key: K) {\n    const entry = this.getEntry(key);\n    return entry && entry.value;\n  }\n\n  private getEntry(key: K): Node<K, V> | void {\n    const entry = this.map.get(key);\n\n    if (entry && entry !== this.newest) {\n      const { older, newer } = entry;\n\n      if (newer) {\n        newer.older = older;\n      }\n\n      if (older) {\n        older.newer = newer;\n      }\n\n      entry.older = this.newest;\n      entry.older!.newer = entry;\n\n      entry.newer = null;\n      this.newest = entry;\n\n      if (entry === this.oldest) {\n        this.oldest = newer;\n      }\n    }\n\n    return entry;\n  }\n\n  public set(key: K, value: V) {\n    let entry = this.getEntry(key);\n    if (entry) {\n      return entry.value = value;\n    }\n\n    entry = {\n      key: key,\n      value: value,\n      newer: null,\n      older: this.newest\n    };\n\n    if (this.newest) {\n      this.newest.newer = entry;\n    }\n\n    this.newest = entry;\n    this.oldest = this.oldest || entry;\n\n    this.map.set(key, entry);\n\n    return entry.value;\n  }\n\n  public clean() {\n    while (this.oldest && this.map.size > this.max) {\n      this.delete(this.oldest.key);\n    }\n  }\n\n  public delete(key: K) {\n    const entry = this.map.get(key);\n    if (entry) {\n      if (entry === this.newest) {\n        this.newest = entry.older;\n      }\n\n      if (entry === this.oldest) {\n        this.oldest = entry.newer;\n      }\n\n      if (entry.newer) {\n        entry.newer.older = entry.older;\n      }\n\n      if (entry.older) {\n        entry.older.newer = entry.newer;\n      }\n\n      this.map.delete(key);\n      this.dispose(entry.value, key);\n\n      return true;\n    }\n\n    return false;\n  }\n}\n","type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult>(\n    callback: (...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: any) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\nconst host = Array as any;\n\nexport const Slot: ReturnType<typeof makeSlotClass> = host[globalKey] || function () {\n  const Slot = makeSlotClass();\n  try {\n    Object.defineProperty(host, globalKey, {\n      value: host[globalKey] = Slot,\n      enumerable: false,\n      writable: false,\n      configurable: false,\n    });\n  } finally {\n    return Slot;\n  }\n}();\n","import { AnyEntry } from \"./entry\";\nimport { Slot } from \"@wry/context\";\n\nexport const parentEntrySlot = new Slot<AnyEntry>();\n\nexport {\n  bind as bindContext,\n  noContext,\n  setTimeout,\n  asyncFromGen,\n} from \"@wry/context\";\n","import { parentEntrySlot } from \"./context\";\nimport { OptimisticWrapOptions } from \"./index\";\n\nconst reusableEmptyArray: AnyEntry[] = [];\nconst emptySetPool: Set<AnyEntry>[] = [];\nconst POOL_TARGET_SIZE = 100;\n\n// Since this package might be used browsers, we should avoid using the\n// Node built-in assert module.\nfunction assert(condition: any, optionalMessage?: string) {\n  if (! condition) {\n    throw new Error(optionalMessage || \"assertion failure\");\n  }\n}\n\n// Since exceptions are cached just like normal values, we need an efficient\n// way of representing unknown, ordinary, and exceptional values.\ntype Value<T> =\n  | []           // unknown\n  | [T]          // known value\n  | [void, any]; // known exception\n\nfunction valueIs(a: Value<any>, b: Value<any>) {\n  const len = a.length;\n  return (\n    // Unknown values are not equal to each other.\n    len > 0 &&\n    // Both values must be ordinary (or both exceptional) to be equal.\n    len === b.length &&\n    // The underlying value or exception must be the same.\n    a[len - 1] === b[len - 1]\n  );\n}\n\nfunction valueGet<T>(value: Value<T>): T {\n  switch (value.length) {\n    case 0: throw new Error(\"unknown value\");\n    case 1: return value[0];\n    case 2: throw value[1];\n  }\n}\n\nfunction valueCopy<T>(value: Value<T>): Value<T> {\n  return value.slice(0) as Value<T>;\n}\n\nexport type AnyEntry = Entry<any, any>;\n\nexport class Entry<TArgs extends any[], TValue> {\n  public static count = 0;\n\n  public subscribe: OptimisticWrapOptions<TArgs>[\"subscribe\"];\n  public unsubscribe?: () => any;\n  public reportOrphan?: (this: Entry<TArgs, TValue>) => any;\n\n  public readonly parents = new Set<AnyEntry>();\n  public readonly childValues = new Map<AnyEntry, Value<any>>();\n\n  // When this Entry has children that are dirty, this property becomes\n  // a Set containing other Entry objects, borrowed from emptySetPool.\n  // When the set becomes empty, it gets recycled back to emptySetPool.\n  public dirtyChildren: Set<AnyEntry> | null = null;\n\n  public dirty = true;\n  public recomputing = false;\n  public readonly value: Value<TValue> = [];\n\n  constructor(\n    public readonly fn: (...args: TArgs) => TValue,\n    public args: TArgs,\n  ) {\n    ++Entry.count;\n  }\n\n  // This is the most important method of the Entry API, because it\n  // determines whether the cached this.value can be returned immediately,\n  // or must be recomputed. The overall performance of the caching system\n  // depends on the truth of the following observations: (1) this.dirty is\n  // usually false, (2) this.dirtyChildren is usually null/empty, and thus\n  // (3) valueGet(this.value) is usually returned without recomputation.\n  public recompute(): TValue {\n    assert(! this.recomputing, \"already recomputing\");\n\n    if (! rememberParent(this) && maybeReportOrphan(this)) {\n      // The recipient of the entry.reportOrphan callback decided to dispose\n      // of this orphan entry by calling entry.dispose(), so we don't need to\n      // (and should not) proceed with the recomputation.\n      return void 0 as any;\n    }\n\n    return mightBeDirty(this)\n      ? reallyRecompute(this)\n      : valueGet(this.value);\n  }\n\n  public setDirty() {\n    if (this.dirty) return;\n    this.dirty = true;\n    this.value.length = 0;\n    reportDirty(this);\n    // We can go ahead and unsubscribe here, since any further dirty\n    // notifications we receive will be redundant, and unsubscribing may\n    // free up some resources, e.g. file watchers.\n    maybeUnsubscribe(this);\n  }\n\n  public dispose() {\n    forgetChildren(this).forEach(maybeReportOrphan);\n    maybeUnsubscribe(this);\n\n    // Because this entry has been kicked out of the cache (in index.js),\n    // we've lost the ability to find out if/when this entry becomes dirty,\n    // whether that happens through a subscription, because of a direct call\n    // to entry.setDirty(), or because one of its children becomes dirty.\n    // Because of this loss of future information, we have to assume the\n    // worst (that this entry might have become dirty very soon), so we must\n    // immediately mark this entry's parents as dirty. Normally we could\n    // just call entry.setDirty() rather than calling parent.setDirty() for\n    // each parent, but that would leave this entry in parent.childValues\n    // and parent.dirtyChildren, which would prevent the child from being\n    // truly forgotten.\n    this.parents.forEach(parent => {\n      parent.setDirty();\n      forgetChild(parent, this);\n    });\n  }\n}\n\nfunction rememberParent(child: AnyEntry) {\n  const parent = parentEntrySlot.getValue();\n  if (parent) {\n    child.parents.add(parent);\n\n    if (! parent.childValues.has(child)) {\n      parent.childValues.set(child, []);\n    }\n\n    if (mightBeDirty(child)) {\n      reportDirtyChild(parent, child);\n    } else {\n      reportCleanChild(parent, child);\n    }\n\n    return parent;\n  }\n}\n\nfunction reallyRecompute(entry: AnyEntry) {\n  // Since this recomputation is likely to re-remember some of this\n  // entry's children, we forget our children here but do not call\n  // maybeReportOrphan until after the recomputation finishes.\n  const originalChildren = forgetChildren(entry);\n\n  // Set entry as the parent entry while calling recomputeNewValue(entry).\n  parentEntrySlot.withValue(entry, recomputeNewValue, [entry]);\n\n  if (maybeSubscribe(entry)) {\n    // If we successfully recomputed entry.value and did not fail to\n    // (re)subscribe, then this Entry is no longer explicitly dirty.\n    setClean(entry);\n  }\n\n  // Now that we've had a chance to re-remember any children that were\n  // involved in the recomputation, we can safely report any orphan\n  // children that remain.\n  originalChildren.forEach(maybeReportOrphan);\n\n  return valueGet(entry.value);\n}\n\nfunction recomputeNewValue(entry: AnyEntry) {\n  entry.recomputing = true;\n  // Set entry.value as unknown.\n  entry.value.length = 0;\n  try {\n    // If entry.fn succeeds, entry.value will become a normal Value.\n    entry.value[0] = entry.fn.apply(null, entry.args);\n  } catch (e) {\n    // If entry.fn throws, entry.value will become exceptional.\n    entry.value[1] = e;\n  }\n  // Either way, this line is always reached.\n  entry.recomputing = false;\n}\n\nfunction mightBeDirty(entry: AnyEntry) {\n  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);\n}\n\nfunction setClean(entry: AnyEntry) {\n  entry.dirty = false;\n\n  if (mightBeDirty(entry)) {\n    // This Entry may still have dirty children, in which case we can't\n    // let our parents know we're clean just yet.\n    return;\n  }\n\n  reportClean(entry);\n}\n\nfunction reportDirty(child: AnyEntry) {\n  child.parents.forEach(parent => reportDirtyChild(parent, child));\n}\n\nfunction reportClean(child: AnyEntry) {\n  child.parents.forEach(parent => reportCleanChild(parent, child));\n}\n\n// Let a parent Entry know that one of its children may be dirty.\nfunction reportDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberParent(child) before calling\n  // reportDirtyChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(mightBeDirty(child));\n\n  if (! parent.dirtyChildren) {\n    parent.dirtyChildren = emptySetPool.pop() || new Set;\n\n  } else if (parent.dirtyChildren.has(child)) {\n    // If we already know this child is dirty, then we must have already\n    // informed our own parents that we are dirty, so we can terminate\n    // the recursion early.\n    return;\n  }\n\n  parent.dirtyChildren.add(child);\n  reportDirty(parent);\n}\n\n// Let a parent Entry know that one of its children is no longer dirty.\nfunction reportCleanChild(parent: AnyEntry, child: AnyEntry) {\n  // Must have called rememberChild(child) before calling\n  // reportCleanChild(parent, child).\n  assert(parent.childValues.has(child));\n  assert(! mightBeDirty(child));\n\n  const childValue = parent.childValues.get(child)!;\n  if (childValue.length === 0) {\n    parent.childValues.set(child, valueCopy(child.value));\n  } else if (! valueIs(childValue, child.value)) {\n    parent.setDirty();\n  }\n\n  removeDirtyChild(parent, child);\n\n  if (mightBeDirty(parent)) {\n    return;\n  }\n\n  reportClean(parent);\n}\n\nfunction removeDirtyChild(parent: AnyEntry, child: AnyEntry) {\n  const dc = parent.dirtyChildren;\n  if (dc) {\n    dc.delete(child);\n    if (dc.size === 0) {\n      if (emptySetPool.length < POOL_TARGET_SIZE) {\n        emptySetPool.push(dc);\n      }\n      parent.dirtyChildren = null;\n    }\n  }\n}\n\n// If the given entry has a reportOrphan method, and no remaining parents,\n// call entry.reportOrphan and return true iff it returns true. The\n// reportOrphan function should return true to indicate entry.dispose()\n// has been called, and the entry has been removed from any other caches\n// (see index.js for the only current example).\nfunction maybeReportOrphan(entry: AnyEntry) {\n  return entry.parents.size === 0 &&\n    typeof entry.reportOrphan === \"function\" &&\n    entry.reportOrphan() === true;\n}\n\n// Removes all children from this entry and returns an array of the\n// removed children.\nfunction forgetChildren(parent: AnyEntry) {\n  let children = reusableEmptyArray;\n\n  if (parent.childValues.size > 0) {\n    children = [];\n    parent.childValues.forEach((_value, child) => {\n      forgetChild(parent, child);\n      children.push(child);\n    });\n  }\n\n  // After we forget all our children, this.dirtyChildren must be empty\n  // and therefore must have been reset to null.\n  assert(parent.dirtyChildren === null);\n\n  return children;\n}\n\nfunction forgetChild(parent: AnyEntry, child: AnyEntry) {\n  child.parents.delete(parent);\n  parent.childValues.delete(child);\n  removeDirtyChild(parent, child);\n}\n\nfunction maybeSubscribe(entry: AnyEntry) {\n  if (typeof entry.subscribe === \"function\") {\n    try {\n      maybeUnsubscribe(entry); // Prevent double subscriptions.\n      entry.unsubscribe = entry.subscribe.apply(null, entry.args);\n    } catch (e) {\n      // If this Entry has a subscribe function and it threw an exception\n      // (or an unsubscribe function it previously returned now throws),\n      // return false to indicate that we were not able to subscribe (or\n      // unsubscribe), and this Entry should remain dirty.\n      entry.setDirty();\n      return false;\n    }\n  }\n\n  // Returning true indicates either that there was no entry.subscribe\n  // function or that it succeeded.\n  return true;\n}\n\nfunction maybeUnsubscribe(entry: AnyEntry) {\n  const { unsubscribe } = entry;\n  if (typeof unsubscribe === \"function\") {\n    entry.unsubscribe = void 0;\n    unsubscribe();\n  }\n}\n","// A trie data structure that holds object keys weakly, yet can also hold\n// non-object keys, unlike the native `WeakMap`.\nexport class KeyTrie<K> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, KeyTrie<K>>;\n  private strong?: Map<any, KeyTrie<K>>;\n  private data?: K;\n\n  constructor(private readonly weakness: boolean) {}\n\n  public lookup<T extends any[]>(...array: T): K {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends any[]>(array: T): K {\n    let node: KeyTrie<K> = this;\n    array.forEach(key => node = node.getChildTrie(key));\n    return node.data || (node.data = Object.create(null));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, KeyTrie<K>>())\n      : this.strong || (this.strong = new Map<any, KeyTrie<K>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new KeyTrie<K>(this.weakness));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n","import { isTest, IdValue } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\n\nimport {\n  ReadStoreContext,\n  FragmentMatcherInterface,\n  PossibleTypesMap,\n  IntrospectionResultData,\n} from './types';\n\nlet haveWarned = false;\n\nfunction shouldWarn() {\n  const answer = !haveWarned;\n  /* istanbul ignore if */\n  if (!isTest()) {\n    haveWarned = true;\n  }\n  return answer;\n}\n\n/**\n * This fragment matcher is very basic and unable to match union or interface type conditions\n */\nexport class HeuristicFragmentMatcher implements FragmentMatcherInterface {\n  constructor() {\n    // do nothing\n  }\n\n  public ensureReady() {\n    return Promise.resolve();\n  }\n\n  public canBypassInit() {\n    return true; // we don't need to initialize this fragment matcher.\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ): boolean | 'heuristic' {\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/3507\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    if (!__typename) {\n      if (shouldWarn()) {\n        invariant.warn(`You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.`);\n        invariant.warn(\n          'Could not find __typename on Fragment ',\n          typeCondition,\n          obj,\n        );\n        invariant.warn(\n          `DEPRECATION WARNING: using fragments without __typename is unsupported behavior ` +\n            `and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.`,\n        );\n      }\n\n      return 'heuristic';\n    }\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    // At this point we don't know if this fragment should match or not. It's\n    // either:\n    //\n    // 1. (GOOD) A fragment on a matching interface or union.\n    // 2. (BAD) A fragment on a non-matching concrete type or interface or union.\n    //\n    // If it's 2, we don't want it to match. If it's 1, we want it to match. We\n    // can't tell the difference, so we warn the user, but still try to match\n    // it (for backwards compatibility reasons). This unfortunately means that\n    // using the `HeuristicFragmentMatcher` with unions and interfaces is\n    // very unreliable. This will be addressed in a future major version of\n    // Apollo Client, but for now the recommendation is to use the\n    // `IntrospectionFragmentMatcher` when working with unions/interfaces.\n\n    if (shouldWarn()) {\n      invariant.error(\n        'You are using the simple (heuristic) fragment matcher, but your ' +\n          'queries contain union or interface types. Apollo Client will not be ' +\n          'able to accurately map fragments. To make this error go away, use ' +\n          'the `IntrospectionFragmentMatcher` as described in the docs: ' +\n          'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher',\n      );\n    }\n\n    return 'heuristic';\n  }\n}\n\nexport class IntrospectionFragmentMatcher implements FragmentMatcherInterface {\n  private isReady: boolean;\n  private possibleTypesMap: PossibleTypesMap;\n\n  constructor(options?: {\n    introspectionQueryResultData?: IntrospectionResultData;\n  }) {\n    if (options && options.introspectionQueryResultData) {\n      this.possibleTypesMap = this.parseIntrospectionResult(\n        options.introspectionQueryResultData,\n      );\n      this.isReady = true;\n    } else {\n      this.isReady = false;\n    }\n\n    this.match = this.match.bind(this);\n  }\n\n  public match(\n    idValue: IdValue,\n    typeCondition: string,\n    context: ReadStoreContext,\n  ) {\n    invariant(\n      this.isReady,\n      'FragmentMatcher.match() was called before FragmentMatcher.init()',\n    );\n\n    const obj = context.store.get(idValue.id);\n    const isRootQuery = idValue.id === 'ROOT_QUERY';\n\n    if (!obj) {\n      // https://github.com/apollographql/apollo-client/pull/4620\n      return isRootQuery;\n    }\n\n    const { __typename = isRootQuery && 'Query' } = obj;\n\n    invariant(\n      __typename,\n      `Cannot match fragment because __typename property is missing: ${JSON.stringify(\n        obj,\n      )}`,\n    );\n\n    if (__typename === typeCondition) {\n      return true;\n    }\n\n    const implementingTypes = this.possibleTypesMap[typeCondition];\n    if (\n      __typename &&\n      implementingTypes &&\n      implementingTypes.indexOf(__typename) > -1\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n\n  private parseIntrospectionResult(\n    introspectionResultData: IntrospectionResultData,\n  ): PossibleTypesMap {\n    const typeMap: PossibleTypesMap = {};\n    introspectionResultData.__schema.types.forEach(type => {\n      if (type.kind === 'UNION' || type.kind === 'INTERFACE') {\n        typeMap[type.name] = type.possibleTypes.map(\n          implementingType => implementingType.name,\n        );\n      }\n    });\n    return typeMap;\n  }\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class DepTrackingCache implements NormalizedCache {\n  // Wrapper function produced by the optimism library, used to depend on\n  // dataId strings, for easy invalidation of specific IDs.\n  private depend: OptimisticWrapperFunction<[string], StoreObject | undefined>;\n\n  constructor(private data: NormalizedCacheObject = Object.create(null)) {\n    this.depend = wrap((dataId: string) => this.data[dataId], {\n      disposable: true,\n      makeCacheKey(dataId: string) {\n        return dataId;\n      },\n    });\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return this.data;\n  }\n\n  public get(dataId: string): StoreObject {\n    this.depend(dataId);\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value?: StoreObject) {\n    const oldValue = this.data[dataId];\n    if (value !== oldValue) {\n      this.data[dataId] = value;\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public delete(dataId: string): void {\n    if (hasOwn.call(this.data, dataId)) {\n      delete this.data[dataId];\n      this.depend.dirty(dataId);\n    }\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    if (newData) {\n      Object.keys(newData).forEach(dataId => {\n        this.set(dataId, newData[dataId]);\n      });\n      Object.keys(this.data).forEach(dataId => {\n        if (!hasOwn.call(newData, dataId)) {\n          this.delete(dataId);\n        }\n      });\n    } else {\n      Object.keys(this.data).forEach(dataId => {\n        this.delete(dataId);\n      });\n    }\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new DepTrackingCache(seed);\n}\n","import {\n  argumentsObjectFromField,\n  assign,\n  canUseWeakMap,\n  createFragmentMap,\n  DirectiveInfo,\n  FragmentMap,\n  getDefaultValues,\n  getDirectiveInfoFromField,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  getStoreKeyName,\n  IdValue,\n  isEqual,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isJsonValue,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  resultKeyNameFromField,\n  shouldInclude,\n  StoreValue,\n  toIdValue,\n} from 'apollo-utilities';\n\nimport { Cache } from 'apollo-cache';\n\nimport {\n  ReadStoreContext,\n  DiffQueryAgainstStoreOptions,\n  ReadQueryOptions,\n  StoreObject,\n} from './types';\n\nimport {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { wrap, KeyTrie } from 'optimism';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: ReadStoreContext,\n) => boolean | 'heuristic';\n\ntype ExecContext = {\n  query: DocumentNode;\n  fragmentMap: FragmentMap;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n};\n\ntype ExecInfo = {\n  resultKey: string;\n  directives: DirectiveInfo;\n};\n\nexport type ExecResultMissingField = {\n  object: StoreObject;\n  fieldName: string;\n  tolerable: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  // Empty array if no missing fields encountered while computing result.\n  missing?: ExecResultMissingField[];\n};\n\ntype ExecStoreQueryOptions = {\n  query: DocumentNode;\n  rootValue: IdValue;\n  contextValue: ReadStoreContext;\n  variableValues: VariableMap;\n  // Default matcher always matches all fragments\n  fragmentMatcher?: FragmentMatcher;\n};\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  rootValue: any;\n  execContext: ExecContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  execContext: ExecContext;\n};\n\nexport interface StoreReaderConfig {\n  cacheKeyRoot?: KeyTrie<object>;\n  freezeResults?: boolean;\n}\n\nexport class StoreReader {\n  private freezeResults: boolean;\n\n  constructor({\n    cacheKeyRoot = new KeyTrie<object>(canUseWeakMap),\n    freezeResults = false,\n  }: StoreReaderConfig = {}) {\n    const {\n      executeStoreQuery,\n      executeSelectionSet,\n      executeSubSelectedArray,\n    } = this;\n\n    this.freezeResults = freezeResults;\n\n    this.executeStoreQuery = wrap((options: ExecStoreQueryOptions) => {\n      return executeStoreQuery.call(this, options);\n    }, {\n      makeCacheKey({\n        query,\n        rootValue,\n        contextValue,\n        variableValues,\n        fragmentMatcher,\n      }: ExecStoreQueryOptions) {\n        // The result of executeStoreQuery can be safely cached only if the\n        // underlying store is capable of tracking dependencies and invalidating\n        // the cache when relevant data have changed.\n        if (contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            contextValue.store,\n            query,\n            fragmentMatcher,\n            JSON.stringify(variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSelectionSet = wrap((options: ExecSelectionSetOptions) => {\n      return executeSelectionSet.call(this, options);\n    }, {\n      makeCacheKey({\n        selectionSet,\n        rootValue,\n        execContext,\n      }: ExecSelectionSetOptions) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            selectionSet,\n            execContext.fragmentMatcher,\n            JSON.stringify(execContext.variableValues),\n            rootValue.id,\n          );\n        }\n      }\n    });\n\n    this.executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n      return executeSubSelectedArray.call(this, options);\n    }, {\n      makeCacheKey({ field, array, execContext }) {\n        if (execContext.contextValue.store instanceof DepTrackingCache) {\n          return cacheKeyRoot.lookup(\n            execContext.contextValue.store,\n            field,\n            array,\n            JSON.stringify(execContext.variableValues),\n          );\n        }\n      }\n    });\n  }\n\n  /**\n   * Resolves the result of a query solely from the store (i.e. never hits the server).\n   *\n   * @param {Store} store The {@link NormalizedCache} used by Apollo for the `data` portion of the\n   * store.\n   *\n   * @param {DocumentNode} query The query document to resolve from the data available in the store.\n   *\n   * @param {Object} [variables] A map from the name of a variable to its value. These variables can\n   * be referenced by the query document.\n   *\n   * @param {any} previousResult The previous result returned by this function for the same query.\n   * If nothing in the store changed since that previous result then values from the previous result\n   * will be returned to preserve referential equality.\n   */\n  public readQueryFromStore<QueryType>(\n    options: ReadQueryOptions,\n  ): QueryType | undefined {\n    return this.diffQueryAgainstStore<QueryType>({\n      ...options,\n      returnPartialData: false,\n    }).result;\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @param  {any} previousResult The previous result returned by this function for the same query\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    variables,\n    previousResult,\n    returnPartialData = true,\n    rootId = 'ROOT_QUERY',\n    fragmentMatcherFunction,\n    config,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    // Throw the right validation error by trying to find a query in the document\n    const queryDefinition = getQueryDefinition(query);\n\n    variables = assign({}, getDefaultValues(queryDefinition), variables);\n\n    const context: ReadStoreContext = {\n      // Global settings\n      store,\n      dataIdFromObject: config && config.dataIdFromObject,\n      cacheRedirects: (config && config.cacheRedirects) || {},\n    };\n\n    const execResult = this.executeStoreQuery({\n      query,\n      rootValue: {\n        type: 'id',\n        id: rootId,\n        generated: true,\n        typename: 'Query',\n      },\n      contextValue: context,\n      variableValues: variables,\n      fragmentMatcher: fragmentMatcherFunction,\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && ! returnPartialData) {\n      execResult.missing!.forEach(info => {\n        if (info.tolerable) return;\n        throw new InvariantError(\n          `Can't find field ${info.fieldName} on object ${JSON.stringify(\n            info.object,\n            null,\n            2,\n          )}.`,\n        );\n      });\n    }\n\n    if (previousResult) {\n      if (isEqual(previousResult, execResult.result)) {\n        execResult.result = previousResult;\n      }\n    }\n\n    return {\n      result: execResult.result,\n      complete: !hasMissingFields,\n    };\n  }\n\n  /**\n   * Based on graphql function from graphql-js:\n   *\n   * graphql(\n   *   schema: GraphQLSchema,\n   *   requestString: string,\n   *   rootValue?: ?any,\n   *   contextValue?: ?any,\n   *   variableValues?: ?{[key: string]: any},\n   *   operationName?: ?string\n   * ): Promise<GraphQLResult>\n   *\n   * The default export as of graphql-anywhere is sync as of 4.0,\n   * but below is an exported alternative that is async.\n   * In the 5.0 version, this will be the only export again\n   * and it will be async\n   *\n   */\n  private executeStoreQuery({\n    query,\n    rootValue,\n    contextValue,\n    variableValues,\n    // Default matcher always matches all fragments\n    fragmentMatcher = defaultFragmentMatcher,\n  }: ExecStoreQueryOptions): ExecResult {\n    const mainDefinition = getMainDefinition(query);\n    const fragments = getFragmentDefinitions(query);\n    const fragmentMap = createFragmentMap(fragments);\n    const execContext: ExecContext = {\n      query,\n      fragmentMap,\n      contextValue,\n      variableValues,\n      fragmentMatcher,\n    };\n\n    return this.executeSelectionSet({\n      selectionSet: mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    });\n  }\n\n  private executeSelectionSet({\n    selectionSet,\n    rootValue,\n    execContext,\n  }: ExecSelectionSetOptions): ExecResult {\n    const { fragmentMap, contextValue, variableValues: variables } = execContext;\n    const finalResult: ExecResult = { result: null };\n\n    const objectsToMerge: { [key: string]: any }[] = [];\n\n    const object: StoreObject = contextValue.store.get(rootValue.id);\n\n    const typename =\n      (object && object.__typename) ||\n      (rootValue.id === 'ROOT_QUERY' && 'Query') ||\n      void 0;\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) {\n        finalResult.missing = finalResult.missing || [];\n        finalResult.missing.push(...result.missing);\n      }\n      return result.result;\n    }\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely\n        return;\n      }\n\n      if (isField(selection)) {\n        const fieldResult = handleMissing(\n          this.executeField(object, typename, selection, execContext),\n        );\n\n        if (typeof fieldResult !== 'undefined') {\n          objectsToMerge.push({\n            [resultKeyNameFromField(selection)]: fieldResult,\n          });\n        }\n\n      } else {\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // This is a named fragment\n          fragment = fragmentMap[selection.name.value];\n\n          if (!fragment) {\n            throw new InvariantError(`No fragment named ${selection.name.value}`);\n          }\n        }\n\n        const typeCondition =\n          fragment.typeCondition && fragment.typeCondition.name.value;\n\n        const match =\n          !typeCondition ||\n          execContext.fragmentMatcher(rootValue, typeCondition, contextValue);\n\n        if (match) {\n          let fragmentExecResult = this.executeSelectionSet({\n            selectionSet: fragment.selectionSet,\n            rootValue,\n            execContext,\n          });\n\n          if (match === 'heuristic' && fragmentExecResult.missing) {\n            fragmentExecResult = {\n              ...fragmentExecResult,\n              missing: fragmentExecResult.missing.map(info => {\n                return { ...info, tolerable: true };\n              }),\n            };\n          }\n\n          objectsToMerge.push(handleMissing(fragmentExecResult));\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    return finalResult;\n  }\n\n  private executeField(\n    object: StoreObject,\n    typename: string | void,\n    field: FieldNode,\n    execContext: ExecContext,\n  ): ExecResult {\n    const { variableValues: variables, contextValue } = execContext;\n    const fieldName = field.name.value;\n    const args = argumentsObjectFromField(field, variables);\n\n    const info: ExecInfo = {\n      resultKey: resultKeyNameFromField(field),\n      directives: getDirectiveInfoFromField(field, variables),\n    };\n\n    const readStoreResult = readStoreResolver(\n      object,\n      typename,\n      fieldName,\n      args,\n      contextValue,\n      info,\n    );\n\n    if (Array.isArray(readStoreResult.result)) {\n      return this.combineExecResults(\n        readStoreResult,\n        this.executeSubSelectedArray({\n          field,\n          array: readStoreResult.result,\n          execContext,\n        }),\n      );\n    }\n\n    // Handle all scalar types here\n    if (!field.selectionSet) {\n      assertSelectionSetForIdValue(field, readStoreResult.result);\n      if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n        maybeDeepFreeze(readStoreResult);\n      }\n      return readStoreResult;\n    }\n\n    // From here down, the field has a selection set, which means it's trying to\n    // query a GraphQLObjectType\n    if (readStoreResult.result == null) {\n      // Basically any field in a GraphQL response can be null, or missing\n      return readStoreResult;\n    }\n\n    // Returned value is an object, and the query has a sub-selection. Recurse.\n    return this.combineExecResults(\n      readStoreResult,\n      this.executeSelectionSet({\n        selectionSet: field.selectionSet,\n        rootValue: readStoreResult.result,\n        execContext,\n      }),\n    );\n  }\n\n  private combineExecResults<T>(\n    ...execResults: ExecResult<T>[]\n  ): ExecResult<T> {\n    let missing: ExecResultMissingField[] | undefined;\n    execResults.forEach(execResult => {\n      if (execResult.missing) {\n        missing = missing || [];\n        missing.push(...execResult.missing);\n      }\n    });\n    return {\n      result: execResults.pop()!.result,\n      missing,\n    };\n  }\n\n  private executeSubSelectedArray({\n    field,\n    array,\n    execContext,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: ExecResultMissingField[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      return childResult.result;\n    }\n\n    array = array.map(item => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          execContext,\n        }));\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          rootValue: item,\n          execContext,\n        }));\n      }\n\n      assertSelectionSetForIdValue(field, item);\n\n      return item;\n    });\n\n    if (this.freezeResults && process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  field: FieldNode,\n  value: any,\n) {\n  if (!field.selectionSet && isIdValue(value)) {\n    throw new InvariantError(\n      `Missing selection set for object of type ${\n        value.typename\n      } returned for query field ${field.name.value}`\n    );\n  }\n}\n\nfunction defaultFragmentMatcher() {\n  return true;\n}\n\nexport function assertIdValue(idValue: IdValue) {\n  invariant(isIdValue(idValue), `\\\nEncountered a sub-selection on the query, but the store doesn't have \\\nan object reference. This should never happen during normal use unless you have custom code \\\nthat is directly manipulating the store; please file an issue.`);\n}\n\nfunction readStoreResolver(\n  object: StoreObject,\n  typename: string | void,\n  fieldName: string,\n  args: any,\n  context: ReadStoreContext,\n  { resultKey, directives }: ExecInfo,\n): ExecResult<StoreValue> {\n  let storeKeyName = fieldName;\n  if (args || directives) {\n    // We happen to know here that getStoreKeyName returns its first\n    // argument unmodified if there are no args or directives, so we can\n    // avoid calling the function at all in that case, as a small but\n    // important optimization to this frequently executed code.\n    storeKeyName = getStoreKeyName(storeKeyName, args, directives);\n  }\n\n  let fieldValue: StoreValue | void = void 0;\n\n  if (object) {\n    fieldValue = object[storeKeyName];\n\n    if (\n      typeof fieldValue === 'undefined' &&\n      context.cacheRedirects &&\n      typeof typename === 'string'\n    ) {\n      // Look for the type in the custom resolver map\n      const type = context.cacheRedirects[typename];\n      if (type) {\n        // Look for the field in the custom resolver map\n        const resolver = type[fieldName];\n        if (resolver) {\n          fieldValue = resolver(object, args, {\n            getCacheKey(storeObj: StoreObject) {\n              const id = context.dataIdFromObject!(storeObj);\n              return id && toIdValue({\n                id,\n                typename: storeObj.__typename,\n              });\n            },\n          });\n        }\n      }\n    }\n  }\n\n  if (typeof fieldValue === 'undefined') {\n    return {\n      result: fieldValue,\n      missing: [{\n        object,\n        fieldName: storeKeyName,\n        tolerable: false,\n      }],\n    };\n  }\n\n  if (isJsonValue(fieldValue)) {\n    fieldValue = fieldValue.json;\n  }\n\n  return {\n    result: fieldValue,\n  };\n}\n","import { NormalizedCache, NormalizedCacheObject, StoreObject } from './types';\n\nexport class ObjectCache implements NormalizedCache {\n  constructor(protected data: NormalizedCacheObject = Object.create(null)) {}\n\n  public toObject() {\n    return this.data;\n  }\n\n  public get(dataId: string) {\n    return this.data[dataId]!;\n  }\n\n  public set(dataId: string, value: StoreObject) {\n    this.data[dataId] = value;\n  }\n\n  public delete(dataId: string) {\n    this.data[dataId] = void 0;\n  }\n\n  public clear() {\n    this.data = Object.create(null);\n  }\n\n  public replace(newData: NormalizedCacheObject) {\n    this.data = newData || Object.create(null);\n  }\n}\n\nexport function defaultNormalizedCacheFactory(\n  seed?: NormalizedCacheObject,\n): NormalizedCache {\n  return new ObjectCache(seed);\n}\n","import {\n  SelectionSetNode,\n  FieldNode,\n  DocumentNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n} from 'graphql';\nimport { FragmentMatcher } from './readFromStore';\n\nimport {\n  assign,\n  createFragmentMap,\n  FragmentMap,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getOperationDefinition,\n  IdValue,\n  isField,\n  isIdValue,\n  isInlineFragment,\n  isProduction,\n  resultKeyNameFromField,\n  shouldInclude,\n  storeKeyNameFromField,\n  StoreValue,\n  toIdValue,\n  isEqual,\n} from 'apollo-utilities';\n\nimport { invariant } from 'ts-invariant';\n\nimport { ObjectCache } from './objectCache';\nimport { defaultNormalizedCacheFactory } from './depTrackingCache';\n\nimport {\n  IdGetter,\n  NormalizedCache,\n  ReadStoreContext,\n  StoreObject,\n} from './types';\n\nexport class WriteError extends Error {\n  public type = 'WriteError';\n}\n\nexport function enhanceErrorWithDocument(error: Error, document: DocumentNode) {\n  // XXX A bit hacky maybe ...\n  const enhancedError = new WriteError(\n    `Error writing result to store for query:\\n ${JSON.stringify(document)}`,\n  );\n  enhancedError.message += '\\n' + error.message;\n  enhancedError.stack = error.stack;\n  return enhancedError;\n}\n\nexport type WriteContext = {\n  readonly store: NormalizedCache;\n  readonly processedData?: { [x: string]: FieldNode[] };\n  readonly variables?: any;\n  readonly dataIdFromObject?: IdGetter;\n  readonly fragmentMap?: FragmentMap;\n  readonly fragmentMatcherFunction?: FragmentMatcher;\n};\n\nexport class StoreWriter {\n  /**\n   * Writes the result of a query to the store.\n   *\n   * @param result The result object returned for the query document.\n   *\n   * @param query The query document whose result we are writing to the store.\n   *\n   * @param store The {@link NormalizedCache} used by Apollo for the `data` portion of the store.\n   *\n   * @param variables A map from the name of a variable to its value. These variables can be\n   * referenced by the query document.\n   *\n   * @param dataIdFromObject A function that returns an object identifier given a particular result\n   * object. See the store documentation for details and an example of this function.\n   *\n   * @param fragmentMatcherFunction A function to use for matching fragment conditions in GraphQL documents\n   */\n  public writeQueryToStore({\n    query,\n    result,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    query: DocumentNode;\n    result: Object;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    return this.writeResultToStore({\n      dataId: 'ROOT_QUERY',\n      result,\n      document: query,\n      store,\n      variables,\n      dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n  }\n\n  public writeResultToStore({\n    dataId,\n    result,\n    document,\n    store = defaultNormalizedCacheFactory(),\n    variables,\n    dataIdFromObject,\n    fragmentMatcherFunction,\n  }: {\n    dataId: string;\n    result: any;\n    document: DocumentNode;\n    store?: NormalizedCache;\n    variables?: Object;\n    dataIdFromObject?: IdGetter;\n    fragmentMatcherFunction?: FragmentMatcher;\n  }): NormalizedCache {\n    // XXX TODO REFACTOR: this is a temporary workaround until query normalization is made to work with documents.\n    const operationDefinition = getOperationDefinition(document)!;\n\n    try {\n      return this.writeSelectionSetToStore({\n        result,\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        context: {\n          store,\n          processedData: {},\n          variables: assign(\n            {},\n            getDefaultValues(operationDefinition),\n            variables,\n          ),\n          dataIdFromObject,\n          fragmentMap: createFragmentMap(getFragmentDefinitions(document)),\n          fragmentMatcherFunction,\n        },\n      });\n    } catch (e) {\n      throw enhanceErrorWithDocument(e, document);\n    }\n  }\n\n  public writeSelectionSetToStore({\n    result,\n    dataId,\n    selectionSet,\n    context,\n  }: {\n    dataId: string;\n    result: any;\n    selectionSet: SelectionSetNode;\n    context: WriteContext;\n  }): NormalizedCache {\n    const { variables, store, fragmentMap } = context;\n\n    selectionSet.selections.forEach(selection => {\n      if (!shouldInclude(selection, variables)) {\n        return;\n      }\n\n      if (isField(selection)) {\n        const resultFieldKey: string = resultKeyNameFromField(selection);\n        const value: any = result[resultFieldKey];\n\n        if (typeof value !== 'undefined') {\n          this.writeFieldToStore({\n            dataId,\n            value,\n            field: selection,\n            context,\n          });\n        } else {\n          let isDefered = false;\n          let isClient = false;\n          if (selection.directives && selection.directives.length) {\n            // If this is a defered field we don't need to throw / warn.\n            isDefered = selection.directives.some(\n              directive => directive.name && directive.name.value === 'defer',\n            );\n\n            // When using the @client directive, it might be desirable in\n            // some cases to want to write a selection set to the store,\n            // without having all of the selection set values available.\n            // This is because the @client field values might have already\n            // been written to the cache separately (e.g. via Apollo\n            // Cache's `writeData` capabilities). Because of this, we'll\n            // skip the missing field warning for fields with @client\n            // directives.\n            isClient = selection.directives.some(\n              directive => directive.name && directive.name.value === 'client',\n            );\n          }\n\n          if (!isDefered && !isClient && context.fragmentMatcherFunction) {\n            // XXX We'd like to throw an error, but for backwards compatibility's sake\n            // we just print a warning for the time being.\n            //throw new WriteError(`Missing field ${resultFieldKey} in ${JSON.stringify(result, null, 2).substring(0, 100)}`);\n            invariant.warn(\n              `Missing field ${resultFieldKey} in ${JSON.stringify(\n                result,\n                null,\n                2,\n              ).substring(0, 100)}`,\n            );\n          }\n        }\n      } else {\n        // This is not a field, so it must be a fragment, either inline or named\n        let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n        if (isInlineFragment(selection)) {\n          fragment = selection;\n        } else {\n          // Named fragment\n          fragment = (fragmentMap || {})[selection.name.value];\n          invariant(fragment, `No fragment named ${selection.name.value}.`);\n        }\n\n        let matches = true;\n        if (context.fragmentMatcherFunction && fragment.typeCondition) {\n          // TODO we need to rewrite the fragment matchers for this to work properly and efficiently\n          // Right now we have to pretend that we're passing in an idValue and that there's a store\n          // on the context.\n          const id = dataId || 'self';\n          const idValue = toIdValue({ id, typename: undefined });\n          const fakeContext: ReadStoreContext = {\n            // NOTE: fakeContext always uses ObjectCache\n            // since this is only to ensure the return value of 'matches'\n            store: new ObjectCache({ [id]: result }),\n            cacheRedirects: {},\n          };\n          const match = context.fragmentMatcherFunction(\n            idValue,\n            fragment.typeCondition.name.value,\n            fakeContext,\n          );\n          if (!isProduction() && match === 'heuristic') {\n            invariant.error('WARNING: heuristic fragment matching going on!');\n          }\n          matches = !!match;\n        }\n\n        if (matches) {\n          this.writeSelectionSetToStore({\n            result,\n            selectionSet: fragment.selectionSet,\n            dataId,\n            context,\n          });\n        }\n      }\n    });\n\n    return store;\n  }\n\n  private writeFieldToStore({\n    field,\n    value,\n    dataId,\n    context,\n  }: {\n    field: FieldNode;\n    value: any;\n    dataId: string;\n    context: WriteContext;\n  }) {\n    const { variables, dataIdFromObject, store } = context;\n\n    let storeValue: StoreValue;\n    let storeObject: StoreObject;\n\n    const storeFieldName: string = storeKeyNameFromField(field, variables);\n\n    // If this is a scalar value...\n    if (!field.selectionSet || value === null) {\n      storeValue =\n        value != null && typeof value === 'object'\n          ? // If the scalar value is a JSON blob, we have to \"escape\" it so it can’t pretend to be\n            // an id.\n            { type: 'json', json: value }\n          : // Otherwise, just store the scalar directly in the store.\n            value;\n    } else if (Array.isArray(value)) {\n      const generatedId = `${dataId}.${storeFieldName}`;\n\n      storeValue = this.processArrayValue(\n        value,\n        generatedId,\n        field.selectionSet,\n        context,\n      );\n    } else {\n      // It's an object\n      let valueDataId = `${dataId}.${storeFieldName}`;\n      let generated = true;\n\n      // We only prepend the '$' if the valueDataId isn't already a generated\n      // id.\n      if (!isGeneratedId(valueDataId)) {\n        valueDataId = '$' + valueDataId;\n      }\n\n      if (dataIdFromObject) {\n        const semanticId = dataIdFromObject(value);\n\n        // We throw an error if the first character of the id is '$. This is\n        // because we use that character to designate an Apollo-generated id\n        // and we use the distinction between user-desiginated and application-provided\n        // ids when managing overwrites.\n        invariant(\n          !semanticId || !isGeneratedId(semanticId),\n          'IDs returned by dataIdFromObject cannot begin with the \"$\" character.',\n        );\n\n        if (\n          semanticId ||\n          (typeof semanticId === 'number' && semanticId === 0)\n        ) {\n          valueDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(valueDataId, field, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: valueDataId,\n          result: value,\n          selectionSet: field.selectionSet,\n          context,\n        });\n      }\n\n      // We take the id and escape it (i.e. wrap it with an enclosing object).\n      // This allows us to distinguish IDs from normal scalars.\n      const typename = value.__typename;\n      storeValue = toIdValue({ id: valueDataId, typename }, generated);\n\n      // check if there was a generated id at the location where we're\n      // about to place this new id. If there was, we have to merge the\n      // data from that id with the data we're about to write in the store.\n      storeObject = store.get(dataId);\n      const escapedId =\n        storeObject && (storeObject[storeFieldName] as IdValue | undefined);\n      if (escapedId !== storeValue && isIdValue(escapedId)) {\n        const hadTypename = escapedId.typename !== undefined;\n        const hasTypename = typename !== undefined;\n        const typenameChanged =\n          hadTypename && hasTypename && escapedId.typename !== typename;\n\n        // If there is already a real id in the store and the current id we\n        // are dealing with is generated, we throw an error.\n        // One exception we allow is when the typename has changed, which occurs\n        // when schema defines a union, both with and without an ID in the same place.\n        // checks if we \"lost\" the read id\n        invariant(\n          !generated || escapedId.generated || typenameChanged,\n          `Store error: the application attempted to write an object with no provided id but the store already contains an id of ${\n            escapedId.id\n          } for this object. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        // checks if we \"lost\" the typename\n        invariant(\n          !hadTypename || hasTypename,\n          `Store error: the application attempted to write an object with no provided typename but the store already contains an object with typename of ${\n            escapedId.typename\n          } for the object of id ${escapedId.id}. The selectionSet that was trying to be written is:\\n${\n            JSON.stringify(field)\n          }`,\n        );\n\n        if (escapedId.generated) {\n          // We should only merge if it's an object of the same type,\n          // otherwise we should delete the generated object\n          if (typenameChanged) {\n            // Only delete the generated object when the old object was\n            // inlined, and the new object is not. This is indicated by\n            // the old id being generated, and the new id being real.\n            if (!generated) {\n              store.delete(escapedId.id);\n            }\n          } else {\n            mergeWithGenerated(escapedId.id, (storeValue as IdValue).id, store);\n          }\n        }\n      }\n    }\n\n    storeObject = store.get(dataId);\n    if (!storeObject || !isEqual(storeValue, storeObject[storeFieldName])) {\n      store.set(dataId, {\n        ...storeObject,\n        [storeFieldName]: storeValue,\n      });\n    }\n  }\n\n  private processArrayValue(\n    value: any[],\n    generatedId: string,\n    selectionSet: SelectionSetNode,\n    context: WriteContext,\n  ): any[] {\n    return value.map((item: any, index: any) => {\n      if (item === null) {\n        return null;\n      }\n\n      let itemDataId = `${generatedId}.${index}`;\n\n      if (Array.isArray(item)) {\n        return this.processArrayValue(item, itemDataId, selectionSet, context);\n      }\n\n      let generated = true;\n\n      if (context.dataIdFromObject) {\n        const semanticId = context.dataIdFromObject(item);\n\n        if (semanticId) {\n          itemDataId = semanticId;\n          generated = false;\n        }\n      }\n\n      if (!isDataProcessed(itemDataId, selectionSet, context.processedData)) {\n        this.writeSelectionSetToStore({\n          dataId: itemDataId,\n          result: item,\n          selectionSet,\n          context,\n        });\n      }\n\n      return toIdValue(\n        { id: itemDataId, typename: item.__typename },\n        generated,\n      );\n    });\n  }\n}\n\n// Checks if the id given is an id that was generated by Apollo\n// rather than by dataIdFromObject.\nfunction isGeneratedId(id: string): boolean {\n  return id[0] === '$';\n}\n\nfunction mergeWithGenerated(\n  generatedKey: string,\n  realKey: string,\n  cache: NormalizedCache,\n): boolean {\n  if (generatedKey === realKey) {\n    return false;\n  }\n\n  const generated = cache.get(generatedKey);\n  const real = cache.get(realKey);\n  let madeChanges = false;\n\n  Object.keys(generated).forEach(key => {\n    const value = generated[key];\n    const realValue = real[key];\n\n    if (\n      isIdValue(value) &&\n      isGeneratedId(value.id) &&\n      isIdValue(realValue) &&\n      !isEqual(value, realValue) &&\n      mergeWithGenerated(value.id, realValue.id, cache)\n    ) {\n      madeChanges = true;\n    }\n  });\n\n  cache.delete(generatedKey);\n  const newRealValue = { ...generated, ...real };\n\n  if (isEqual(newRealValue, real)) {\n    return madeChanges;\n  }\n\n  cache.set(realKey, newRealValue);\n  return true;\n}\n\nfunction isDataProcessed(\n  dataId: string,\n  field: FieldNode | SelectionSetNode,\n  processedData?: { [x: string]: (FieldNode | SelectionSetNode)[] },\n): boolean {\n  if (!processedData) {\n    return false;\n  }\n\n  if (processedData[dataId]) {\n    if (processedData[dataId].indexOf(field) >= 0) {\n      return true;\n    } else {\n      processedData[dataId].push(field);\n    }\n  } else {\n    processedData[dataId] = [field];\n  }\n\n  return false;\n}\n","// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\n\nimport { Cache, ApolloCache, Transaction } from 'apollo-cache';\n\nimport { addTypenameToDocument, canUseWeakMap } from 'apollo-utilities';\n\nimport { wrap } from 'optimism';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { HeuristicFragmentMatcher } from './fragmentMatcher';\nimport {\n  ApolloReducerConfig,\n  NormalizedCache,\n  NormalizedCacheObject,\n} from './types';\n\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { DepTrackingCache } from './depTrackingCache';\nimport { KeyTrie } from 'optimism';\nimport { ObjectCache } from './objectCache';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  freezeResults?: boolean;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  fragmentMatcher: new HeuristicFragmentMatcher(),\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  freezeResults: false,\n};\n\nexport function defaultDataIdFromObject(result: any): string | null {\n  if (result.__typename) {\n    if (result.id !== undefined) {\n      return `${result.__typename}:${result.id}`;\n    }\n    if (result._id !== undefined) {\n      return `${result.__typename}:${result._id}`;\n    }\n  }\n  return null;\n}\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nexport class OptimisticCacheLayer extends ObjectCache {\n  constructor(\n    public readonly optimisticId: string,\n    // OptimisticCacheLayer objects always wrap some other parent cache, so\n    // this.parent should never be null.\n    public readonly parent: NormalizedCache,\n    public readonly transaction: Transaction<NormalizedCacheObject>,\n  ) {\n    super(Object.create(null));\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  // All the other accessor methods of ObjectCache work without knowing about\n  // this.parent, but the get method needs to be overridden to implement the\n  // fallback this.parent.get(dataId) behavior.\n  public get(dataId: string) {\n    return hasOwn.call(this.data, dataId)\n      ? this.data[dataId]\n      : this.parent.get(dataId);\n  }\n}\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: NormalizedCache;\n  private optimisticData: NormalizedCache;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n  private cacheKeyRoot = new KeyTrie<object>(canUseWeakMap);\n\n  // Set this while in a transaction to prevent broadcasts...\n  // don't forget to turn it back on!\n  private silenceBroadcast: boolean = false;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n\n    // backwards compat\n    if ((this.config as any).customResolvers) {\n      invariant.warn(\n        'customResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating customResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).customResolvers;\n    }\n\n    if ((this.config as any).cacheResolvers) {\n      invariant.warn(\n        'cacheResolvers have been renamed to cacheRedirects. Please update your config as we will be deprecating cacheResolvers in the next major version.',\n      );\n      this.config.cacheRedirects = (this.config as any).cacheResolvers;\n    }\n\n    this.addTypename = !!this.config.addTypename;\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = this.config.resultCaching\n      ? new DepTrackingCache()\n      : new ObjectCache();\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter();\n    this.storeReader = new StoreReader({\n      cacheKeyRoot: this.cacheKeyRoot,\n      freezeResults: config.freezeResults,\n    });\n\n    const cache = this;\n    const { maybeBroadcastWatch } = cache;\n    this.maybeBroadcastWatch = wrap((c: Cache.WatchOptions) => {\n      return maybeBroadcastWatch.call(this, c);\n    }, {\n      makeCacheKey(c: Cache.WatchOptions) {\n        if (c.optimistic) {\n          // If we're reading optimistic data, it doesn't matter if this.data\n          // is a DepTrackingCache, since it will be ignored.\n          return;\n        }\n\n        if (c.previousResult) {\n          // If a previousResult was provided, assume the caller would prefer\n          // to compare the previous data to the new data to determine whether\n          // to broadcast, so we should disable caching by returning here, to\n          // give maybeBroadcastWatch a chance to do that comparison.\n          return;\n        }\n\n        if (cache.data instanceof DepTrackingCache) {\n          // Return a cache key (thus enabling caching) only if we're currently\n          // using a data store that can track cache dependencies.\n          return cache.cacheKeyRoot.lookup(\n            c.query,\n            JSON.stringify(c.variables),\n          );\n        }\n      }\n    });\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).toObject();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    if (typeof options.rootId === 'string' &&\n        typeof this.data.get(options.rootId) === 'undefined') {\n      return null;\n    }\n\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.readQueryFromStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(options.query),\n      variables: options.variables,\n      rootId: options.rootId,\n      fragmentMatcherFunction,\n      previousResult: options.previousResult,\n      config: this.config,\n    }) || null;\n  }\n\n  public write(write: Cache.WriteOptions): void {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    this.storeWriter.writeResultToStore({\n      dataId: write.dataId,\n      result: write.result,\n      variables: write.variables,\n      document: this.transformDocument(write.query),\n      store: this.data,\n      dataIdFromObject: this.config.dataIdFromObject,\n      fragmentMatcherFunction,\n    });\n\n    this.broadcastWatches();\n  }\n\n  public diff<T>(query: Cache.DiffOptions): Cache.DiffResult<T> {\n    const { fragmentMatcher } = this.config;\n    const fragmentMatcherFunction = fragmentMatcher && fragmentMatcher.match;\n\n    return this.storeReader.diffQueryAgainstStore({\n      store: query.optimistic ? this.optimisticData : this.data,\n      query: this.transformDocument(query.query),\n      variables: query.variables,\n      returnPartialData: query.returnPartialData,\n      previousResult: query.previousResult,\n      fragmentMatcherFunction,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n\n    return () => {\n      this.watches.delete(watch);\n    };\n  }\n\n  public evict(query: Cache.EvictOptions): Cache.EvictionResult {\n    throw new InvariantError(`eviction is not implemented on InMemory Cache`);\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.broadcastWatches();\n\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const toReapply: OptimisticCacheLayer[] = [];\n    let removedCount = 0;\n    let layer = this.optimisticData;\n\n    while (layer instanceof OptimisticCacheLayer) {\n      if (layer.optimisticId === idToRemove) {\n        ++removedCount;\n      } else {\n        toReapply.push(layer);\n      }\n      layer = layer.parent;\n    }\n\n    if (removedCount > 0) {\n      // Reset this.optimisticData to the first non-OptimisticCacheLayer object,\n      // which is almost certainly this.data.\n      this.optimisticData = layer;\n\n      // Reapply the layers whose optimistic IDs do not match the removed ID.\n      while (toReapply.length > 0) {\n        const layer = toReapply.pop()!;\n        this.performTransaction(layer.transaction, layer.optimisticId);\n      }\n\n      this.broadcastWatches();\n    }\n  }\n\n  public performTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    // This parameter is not part of the performTransaction signature inherited\n    // from the ApolloCache abstract class, but it's useful because it saves us\n    // from duplicating this implementation in recordOptimisticTransaction.\n    optimisticId?: string,\n  ) {\n    const { data, silenceBroadcast } = this;\n    this.silenceBroadcast = true;\n\n    if (typeof optimisticId === 'string') {\n      // Add a new optimistic layer and temporarily make this.data refer to\n      // that layer for the duration of the transaction.\n      this.data = this.optimisticData = new OptimisticCacheLayer(\n        // Note that there can be multiple layers with the same optimisticId.\n        // When removeOptimistic(id) is called for that id, all matching layers\n        // will be removed, and the remaining layers will be reapplied.\n        optimisticId,\n        this.optimisticData,\n        transaction,\n      );\n    }\n\n    try {\n      transaction(this);\n    } finally {\n      this.silenceBroadcast = silenceBroadcast;\n      this.data = data;\n    }\n\n    // This broadcast does nothing if this.silenceBroadcast is true.\n    this.broadcastWatches();\n  }\n\n  public recordOptimisticTransaction(\n    transaction: Transaction<NormalizedCacheObject>,\n    id: string,\n  ) {\n    return this.performTransaction(transaction, id);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches() {\n    if (!this.silenceBroadcast) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c));\n    }\n  }\n\n  // This method is wrapped in the constructor so that it will be called only\n  // if the data that would be broadcast has changed.\n  private maybeBroadcastWatch(c: Cache.WatchOptions) {\n    c.callback(\n      this.diff({\n        query: c.query,\n        variables: c.variables,\n        previousResult: c.previousResult && c.previousResult(),\n        optimistic: c.optimistic,\n      }),\n    );\n  }\n}\n","import { visit } from './visitor';\nimport { printBlockString } from './blockString';\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, {\n    leave: printDocASTReducer\n  });\n} // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    return join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: function SchemaDefinition(_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(function (x) {\n    return x;\n  }).join(separator || '') : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? '{\\n' + indent(join(array, '\\n')) + '\\n}' : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n\nfunction indent(maybeString) {\n  return maybeString && '  ' + maybeString.replace(/\\n/g, '\\n  ');\n}\n\nfunction isMultiline(string) {\n  return string.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray && maybeArray.some(isMultiline);\n}\n","/* tslint:disable */\n\nimport { ApolloLink, Observable, RequestHandler, fromError } from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  Body,\n  HttpOptions,\n  UriFunction as _UriFunction,\n} from 'apollo-link-http-common';\nimport { DefinitionNode } from 'graphql';\n\nexport namespace HttpLink {\n  //TODO Would much rather be able to export directly\n  export interface UriFunction extends _UriFunction {}\n  export interface Options extends HttpOptions {\n    /**\n     * If set to true, use the HTTP GET method for query operations. Mutations\n     * will still use the method specified in fetchOptions.method (which defaults\n     * to POST).\n     */\n    useGETForQueries?: boolean;\n  }\n}\n\n// For backwards compatibility.\nexport import FetchOptions = HttpLink.Options;\nexport import UriFunction = HttpLink.UriFunction;\n\nexport const createHttpLink = (linkOptions: HttpLink.Options = {}) => {\n  let {\n    uri = '/graphql',\n    // use default global fetch if nothing passed in\n    fetch: fetcher,\n    includeExtensions,\n    useGETForQueries,\n    ...requestOptions\n  } = linkOptions;\n\n  // dev warnings to ensure fetch is present\n  checkFetcher(fetcher);\n\n  //fetcher is set here rather than the destructuring to ensure fetch is\n  //declared before referencing it. Reference in the destructuring would cause\n  //a ReferenceError\n  if (!fetcher) {\n    fetcher = fetch;\n  }\n\n  const linkConfig = {\n    http: { includeExtensions },\n    options: requestOptions.fetchOptions,\n    credentials: requestOptions.credentials,\n    headers: requestOptions.headers,\n  };\n\n  return new ApolloLink(operation => {\n    let chosenURI = selectURI(operation, uri);\n\n    const context = operation.getContext();\n\n    // `apollographql-client-*` headers are automatically set if a\n    // `clientAwareness` object is found in the context. These headers are\n    // set first, followed by the rest of the headers pulled from\n    // `context.headers`. If desired, `apollographql-client-*` headers set by\n    // the `clientAwareness` object can be overridden by\n    // `apollographql-client-*` headers set in `context.headers`.\n    const clientAwarenessHeaders = {};\n    if (context.clientAwareness) {\n      const { name, version } = context.clientAwareness;\n      if (name) {\n        clientAwarenessHeaders['apollographql-client-name'] = name;\n      }\n      if (version) {\n        clientAwarenessHeaders['apollographql-client-version'] = version;\n      }\n    }\n\n    const contextHeaders = { ...clientAwarenessHeaders, ...context.headers };\n\n    const contextConfig = {\n      http: context.http,\n      options: context.fetchOptions,\n      credentials: context.credentials,\n      headers: contextHeaders,\n    };\n\n    //uses fallback, link, and then context to build options\n    const { options, body } = selectHttpOptionsAndBody(\n      operation,\n      fallbackHttpConfig,\n      linkConfig,\n      contextConfig,\n    );\n\n    let controller;\n    if (!(options as any).signal) {\n      const { controller: _controller, signal } = createSignalIfSupported();\n      controller = _controller;\n      if (controller) (options as any).signal = signal;\n    }\n\n    // If requested, set method to GET if there are no mutations.\n    const definitionIsMutation = (d: DefinitionNode) => {\n      return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n    };\n    if (\n      useGETForQueries &&\n      !operation.query.definitions.some(definitionIsMutation)\n    ) {\n      options.method = 'GET';\n    }\n\n    if (options.method === 'GET') {\n      const { newURI, parseError } = rewriteURIForGET(chosenURI, body);\n      if (parseError) {\n        return fromError(parseError);\n      }\n      chosenURI = newURI;\n    } else {\n      try {\n        (options as any).body = serializeFetchParameter(body, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n    }\n\n    return new Observable(observer => {\n      fetcher(chosenURI, options)\n        .then(response => {\n          operation.setContext({ response });\n          return response;\n        })\n        .then(parseAndCheckHttpResponse(operation))\n        .then(result => {\n          // we have data and can send it to back up the link chain\n          observer.next(result);\n          observer.complete();\n          return result;\n        })\n        .catch(err => {\n          // fetch was cancelled so it's already been cleaned up in the unsubscribe\n          if (err.name === 'AbortError') return;\n          // if it is a network error, BUT there is graphql result info\n          // fire the next observer before calling error\n          // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n          // to pass to UI\n          // this should only happen if we *also* have data as part of the response key per\n          // the spec\n          if (err.result && err.result.errors && err.result.data) {\n            // if we don't call next, the UI can only show networkError because AC didn't\n            // get any graphqlErrors\n            // this is graphql execution result info (i.e errors and possibly data)\n            // this is because there is no formal spec how errors should translate to\n            // http status codes. So an auth error (401) could have both data\n            // from a public field, errors from a private field, and a status of 401\n            // {\n            //  user { // this will have errors\n            //    firstName\n            //  }\n            //  products { // this is public so will have data\n            //    cost\n            //  }\n            // }\n            //\n            // the result of above *could* look like this:\n            // {\n            //   data: { products: [{ cost: \"$10\" }] },\n            //   errors: [{\n            //      message: 'your session has timed out',\n            //      path: []\n            //   }]\n            // }\n            // status code of above would be a 401\n            // in the UI you want to show data where you can, errors as data where you can\n            // and use correct http status codes\n            observer.next(err.result);\n          }\n          observer.error(err);\n        });\n\n      return () => {\n        // XXX support canceling this request\n        // https://developers.google.com/web/updates/2017/09/abortable-fetch\n        if (controller) controller.abort();\n      };\n    });\n  });\n};\n\n// For GET operations, returns the given URI rewritten with parameters, or a\n// parse error.\nfunction rewriteURIForGET(chosenURI: string, body: Body) {\n  // Implement the standard HTTP GET serialization, plus 'extensions'. Note\n  // the extra level of JSON serialization!\n  const queryParams = [];\n  const addQueryParam = (key: string, value: string) => {\n    queryParams.push(`${key}=${encodeURIComponent(value)}`);\n  };\n\n  if ('query' in body) {\n    addQueryParam('query', body.query);\n  }\n  if (body.operationName) {\n    addQueryParam('operationName', body.operationName);\n  }\n  if (body.variables) {\n    let serializedVariables;\n    try {\n      serializedVariables = serializeFetchParameter(\n        body.variables,\n        'Variables map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('variables', serializedVariables);\n  }\n  if (body.extensions) {\n    let serializedExtensions;\n    try {\n      serializedExtensions = serializeFetchParameter(\n        body.extensions,\n        'Extensions map',\n      );\n    } catch (parseError) {\n      return { parseError };\n    }\n    addQueryParam('extensions', serializedExtensions);\n  }\n\n  // Reconstruct the URI with added query params.\n  // XXX This assumes that the URI is well-formed and that it doesn't\n  //     already contain any of these query params. We could instead use the\n  //     URL API and take a polyfill (whatwg-url@6) for older browsers that\n  //     don't support URLSearchParams. Note that some browsers (and\n  //     versions of whatwg-url) support URL but not URLSearchParams!\n  let fragment = '',\n    preFragment = chosenURI;\n  const fragmentStart = chosenURI.indexOf('#');\n  if (fragmentStart !== -1) {\n    fragment = chosenURI.substr(fragmentStart);\n    preFragment = chosenURI.substr(0, fragmentStart);\n  }\n  const queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n  const newURI =\n    preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n  return { newURI };\n}\n\nexport class HttpLink extends ApolloLink {\n  public requester: RequestHandler;\n  constructor(opts?: HttpLink.Options) {\n    super(createHttpLink(opts).request);\n  }\n}\n"],"sourceRoot":""}